
在 UNIX/Linux 中比较流行的常见的 Shell 有 bash、zsh、ksh、csh 等等,Ubuntu 终端默认使用的是 bash,默认的桌面环境是 GNOME 或者 Unity(基于 GNOME),但实验室的环境中使用的分别是 zsh 和 xfce。

基本概念及操作
一、实验介绍
二、桌面环境
三、linux终端
 3.1Shell
 3.2 命令行操作体验
四、作业

基本概念及操作
1.1 实验内容
实验楼环境介绍
常用 Shell 命令及快捷键
Linux 使用小技巧
1.2 实验知识点
Linux 基本命令
通配符的使用
查看帮助文档
二、桌面环境
一、实验介绍
1.Linux 桌面环境介绍
相对于现在的 Windows 系统,UNIX/Linux 本身是没有图形界面的,我们通常在 UNIX/Linux 发行版上看到的图形界面实际都只是运行在 Linux 系统之上的一套软件,类似 Windows95 之前的 Windows 的图形界面实则也只是运行在 DOS 环境的一套软件。而 Linux 上的这套软件以前是 XFree86,现在则是 xorg(X.Org),而这套软件又是通过 X 窗口系统(X Window System,也常被称为 X11 或 X)实现的,X 本身只是工具包及架构协议,而 xorg 便是 X 架构规范的一个实现体,也就是说它是实现了 X 协议规范的一个提供图形界面服务的服务器,就像实现了 http 协议提供 web 服务的 Apache 。如果只有服务器也是不能实现一个完整的桌面环境的,当然还需要一个客户端,我们称为 X Client,像如下几个大家熟知也最流行的实现了客户端功能的桌面环境 KDE,GNOME,XFCE,LXDE 。其中就有你看到的,实验楼目前使用的 XFCE 桌面环境,部分老用户可能可以回想起,实验楼之前使用的环境是 LXDE 。这也意味着在 Linux 上你可以自己选择安装不同的桌面环境,甚至可以定制自己的专属桌面。



这里讲这么多,主要是为了帮助你更好地理解 Linux 的桌面环境是一个怎样的概念,以及它跟 Windows 操作系统桌面的差异,实际它们之间是有着本质的差别的,希望清楚这些内容之后可以让你忽略那些体验上的差异,专心把精力放到 Linux 系统本身或者你正准备学习的某一门技术之上,这门实验课后面的内容和实验楼的其它课程便是为了帮助你实现以上两个目标。

2.Linux 桌面环境的使用
如果你对当前实验桌面环境(xfce)的使用有任何困难,建议你先学习实验楼入门基础课程,对于其它桌面环境的使用,不在本课程的范围之内,有兴趣的用户可以在自己的计算机中安装完整的 Linux 发行版或其 Live CD 体验。
三、linux终端
一、实验介绍
1.Linux 桌面环境介绍
相对于现在的 Windows 系统,UNIX/Linux 本身是没有图形界面的,我们通常在 UNIX/Linux 发行版上看到的图形界面实际都只是运行在 Linux 系统之上的一套软件,类似 Windows95 之前的 Windows 的图形界面实则也只是运行在 DOS 环境的一套软件。而 Linux 上的这套软件以前是 XFree86,现在则是 xorg(X.Org),而这套软件又是通过 X 窗口系统(X Window System,也常被称为 X11 或 X)实现的,X 本身只是工具包及架构协议,而 xorg 便是 X 架构规范的一个实现体,也就是说它是实现了 X 协议规范的一个提供图形界面服务的服务器,就像实现了 http 协议提供 web 服务的 Apache 。如果只有服务器也是不能实现一个完整的桌面环境的,当然还需要一个客户端,我们称为 X Client,像如下几个大家熟知也最流行的实现了客户端功能的桌面环境 KDE,GNOME,XFCE,LXDE 。其中就有你看到的,实验楼目前使用的 XFCE 桌面环境,部分老用户可能可以回想起,实验楼之前使用的环境是 LXDE 。这也意味着在 Linux 上你可以自己选择安装不同的桌面环境,甚至可以定制自己的专属桌面。



这里讲这么多,主要是为了帮助你更好地理解 Linux 的桌面环境是一个怎样的概念,以及它跟 Windows 操作系统桌面的差异,实际它们之间是有着本质的差别的,希望清楚这些内容之后可以让你忽略那些体验上的差异,专心把精力放到 Linux 系统本身或者你正准备学习的某一门技术之上,这门实验课后面的内容和实验楼的其它课程便是为了帮助你实现以上两个目标。

2.Linux 桌面环境的使用
如果你对当前实验桌面环境(xfce)的使用有任何困难,建议你先学习实验楼入门基础课程,对于其它桌面环境的使用,不在本课程的范围之内,有兴趣的用户可以在自己的计算机中安装完整的 Linux 发行版或其 Live CD 体验。
 3.1Shell
 一、实验介绍
1.Linux 桌面环境介绍
相对于现在的 Windows 系统,UNIX/Linux 本身是没有图形界面的,我们通常在 UNIX/Linux 发行版上看到的图形界面实际都只是运行在 Linux 系统之上的一套软件,类似 Windows95 之前的 Windows 的图形界面实则也只是运行在 DOS 环境的一套软件。而 Linux 上的这套软件以前是 XFree86,现在则是 xorg(X.Org),而这套软件又是通过 X 窗口系统(X Window System,也常被称为 X11 或 X)实现的,X 本身只是工具包及架构协议,而 xorg 便是 X 架构规范的一个实现体,也就是说它是实现了 X 协议规范的一个提供图形界面服务的服务器,就像实现了 http 协议提供 web 服务的 Apache 。如果只有服务器也是不能实现一个完整的桌面环境的,当然还需要一个客户端,我们称为 X Client,像如下几个大家熟知也最流行的实现了客户端功能的桌面环境 KDE,GNOME,XFCE,LXDE 。其中就有你看到的,实验楼目前使用的 XFCE 桌面环境,部分老用户可能可以回想起,实验楼之前使用的环境是 LXDE 。这也意味着在 Linux 上你可以自己选择安装不同的桌面环境,甚至可以定制自己的专属桌面。



这里讲这么多,主要是为了帮助你更好地理解 Linux 的桌面环境是一个怎样的概念,以及它跟 Windows 操作系统桌面的差异,实际它们之间是有着本质的差别的,希望清楚这些内容之后可以让你忽略那些体验上的差异,专心把精力放到 Linux 系统本身或者你正准备学习的某一门技术之上,这门实验课后面的内容和实验楼的其它课程便是为了帮助你实现以上两个目标。

2.Linux 桌面环境的使用
如果你对当前实验桌面环境(xfce)的使用有任何困难,建议你先学习实验楼入门基础课程,对于其它桌面环境的使用,不在本课程的范围之内,有兴趣的用户可以在自己的计算机中安装完整的 Linux 发行版或其 Live CD 体验。
 3.2 命令行操作体验
 写在前面
在linux中,最最重要的就是命令,这就包含了2个过程,输入和输出

输入：输入当然就是打开终端,然后按键盘输入,然后按回车,输入格式一般就是这类的
#创建一个名为 file 的文件,touch是一个命令
$ touch file 

#进入一个目录,cd是一个命令
$ cd /etc/

#查看当前所在目录
$ pwd
输出：输出会返回你想要的结果,比如你要看什么文件,就会返回文件的内容。如果只是执行,执行失败会告诉你哪里错了,如果执行成功那么会没有输出,因为linux的哲学就是：没有结果就是最好的结果
开始
如图,双击桌面上的 Xfce 终端 图标打开终端后系统会自动运行 Shell 程序,然后我们就可以输入命令让系统来执行了：



1) 重要快捷键：
真正学习命令行之前,你先要掌握几个十分有用、必需掌握的小技巧：

[Tab]
使用Tab键来进行命令补全,Tab键一般是在字母Q旁边,这个技巧给你带来的最大的好处就是当你忘记某个命令的全称时可以只输入它的开头的一部分,然后按下Tab键就可以得到提示或者帮助完成：



当然不止补全命令,补全目录、补全命令参数都是没问题的：



[Ctrl+c]
想想你有没有遇到过这种情况,当你在 Linux 命令行中无意输入了一个不知道的命令,或者错误地使用了一个命令,导致在终端里出现了你无法预料的情况,比如,屏幕上只有光标在闪烁却无法继续输入命令,或者不停地输出一大堆你不想要的结果。你想要立即停止并恢复到你可控的状态,那该怎么办呢？这时候你就可以使用Ctrl+c键来强行终止当前程序(你可以放心它并不会使终端退出)。

尝试输入以下命令：

$ tail
然后你会发现你接下来的输入都没有任何反应了,只是将你输入的东西显示出来,现在你可以使用Ctrl+c,来中断这个你目前可能还不知道是什么的程序(在后续课程中我们会具体解释这个tail命令是什么)。

又或者输入：

$ find /


显然这不是你想的结果,可以使用Ctrl+c结束。

虽然这个按着很方便,但不要随便按,因为有时候,当你看到终端没有任何反应或提示,也不能接受你的输入时,可能只是运行的程序需要你耐心等一下,就不要急着按Ctrl+c了。

其他一些常用快捷键
按键	作用
Ctrl+d	键盘输入结束或退出终端
Ctrl+s	暂停当前程序,暂停后按下任意键恢复运行
Ctrl+z	将当前程序放到后台运行,恢复到前台为命令fg
Ctrl+a	将光标移至输入行头,相当于Home键
Ctrl+e	将光标移至输入行末,相当于End键
Ctrl+k	删除从光标所在位置到行末
Alt+Backspace	向前删除一个单词
Shift+PgUp	将终端显示向上滚动
Shift+PgDn	将终端显示向下滚动
2) 学会利用历史输入命令
很简单,你可以使用键盘上的方向上键↑,恢复你之前输入过的命令,你一试便知。

3) 学会使用通配符
通配符是一种特殊语句,主要有星号(*)和问号(?),用来对字符串进行模糊匹配(比如文件名、参数名)。当查找文件夹时,可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时,常常使用通配符代替一个或多个真正字符。

终端里面输入的通配符是由 Shell 处理的,不是由所涉及的命令语句处理的,它只会出现在命令的“参数值”里(它不能出现在命令名称里, 命令不记得,那就用Tab补全)。当 Shell 在“参数值”中遇到了通配符时,Shell 会将其当作路径或文件名在磁盘上搜寻可能的匹配：若符合要求的匹配存在,则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给“命令”,然后再由命令进行处理。总之,通配符实际上就是一种 Shell 实现的路径扩展功能。在通配符被处理后, Shell 会先完成该命令的重组,然后继续处理重组后的命令,直至执行该命令。

首先回到用户家目录：

$ cd /home/shiyanlou
然后使用 touch 命令创建 2 个文件,后缀都为 txt：

$ touch asd.txt fgh.txt
可以给文件随意命名,假如过了很长时间,你已经忘了这两个文件的文件名,现在你想在一大堆文件中找到这两个文件,就可以使用通配符：

$ ls *.txt


在创建文件的时候,如果需要一次性创建多个文件,比如：“love_1_linux.txt,love_2_linux.txt,... love_10_linux.txt”。在 Linux 中十分方便：

$ touch love_{1..10}_shiyanlou.txt


Shell 常用通配符：

字符	含义
*	匹配 0 或多个字符
?	匹配任意一个字符
[list]	匹配 list 中的任意单一字符
[^list]	匹配 除list 中的任意单一字符以外的字符
[c1-c2]	匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]
{string1,string2,...}	匹配 string1 或 string2 (或更多)其一字符串
{c1..c2}	匹配 c1-c2 中全部字符 如{1..10}
4) 学会在命令行中获取帮助
在 Linux 环境中,如果你遇到困难,可以使用man命令,它是Manual pages的缩写。

Manual pages 是 UNIX 或类 UNIX 操作系统中在线软件文档的一种普遍的形式, 内容包括计算机程序(包括库和系统调用)、正式的标准和惯例,甚至是抽象的概念。用户可以通过执行man命令调用手册页。

你可以使用如下方式来获得某个命令的说明和使用方式的详细介绍：

$ man <command_name>
比如你想查看 man 命令本身的使用方式,你可以输入：

man man
通常情况下,man 手册里面的内容都是英文的,这就要求你有一定的英文基础。man 手册的内容很多,涉及了 Linux 使用过程中的方方面面。为了便于查找,man 手册被进行了分册(分区段)处理,在 Research UNIX、BSD、OS X 和 Linux 中,手册通常被分为8个区段,安排如下：

区段	说明
1	一般命令
2	系统调用
3	库函数,涵盖了C标准函数库
4	特殊文件(通常是/dev中的设备)和驱动程序
5	文件格式和约定
6	游戏和屏保
7	杂项
8	系统管理命令和守护进程
要查看相应区段的内容,就在 man 后面加上相应区段的数字即可,如：

$ man 1 ls
会显示第一区段中的ls命令 man 页面。

所有的手册页遵循一个常见的布局,为了通过简单的 ASCII 文本展示而被优化,而这种情况下可能没有任何形式的高亮或字体控制。一般包括以下部分内容：

NAME(名称)

该命令或函数的名称,接着是一行简介。

SYNOPSIS(概要)

对于命令,正式的描述它如何运行,以及需要什么样的命令行参数。对于函数,介绍函数所需的参数,以及哪个头文件包含该函数的定义。

DESCRIPTION(说明)

命令或函数功能的文本描述。

EXAMPLES(示例)

常用的一些示例。

SEE ALSO(参见)

相关命令或函数的列表。

也可能存在其它部分内容,但这些部分没有得到跨手册页的标准化。常见的例子包括：OPTIONS(选项),EXIT STATUS(退出状态),ENVIRONMENT(环境),BUGS(程序漏洞),FILES(文件),AUTHOR(作者),REPORTING BUGS(已知漏洞),HISTORY(历史)和 COPYRIGHT(版权)。

通常 man 手册中的内容很多,你可能不太容易找到你想要的结果,不过幸运的是你可以在 man 中使用搜索/<你要搜索的关键字>,查找完毕后你可以使用n键切换到下一个关键字所在处,shift+n为上一个关键字所在处。使用Space(空格键)翻页,Enter(回车键)向下滚动一行,或者使用k,j(vim 编辑器的移动键)进行向前向后滚动一行。按下h键为显示使用帮助(因为 man 使用 less 作为阅读器,实为less工具的帮助),按下q退出。

想要获得更详细的帮助,你还可以使用info命令,不过通常使用man就足够了。如果你知道某个命令的作用,只是想快速查看一些它的某个具体参数的作用,那么你可以使用--help参数,大部分命令都会带有这个参数,如：

$ ls --help
四、作业
本课程会在每一节实验结束部分介绍一个有趣的 Linux 命令,这一节介绍一个可以输出图形字符的命令banner,先看效果：



你可以先使用如下命令安装：

$ sudo apt-get update
$ sudo apt-get install sysvbanner
然后：

$ banner shiyanlou
或者你觉得这字体不好看,那么你还可以使用默认已经安装的一个命令printerbanner：

$ printerbanner -w 50 A


-w参数指定打印宽度,因为我们的环境在屏幕中显示比较小,必须要加上宽度限制。

还有两个类似的命令toilet,figlet,作为作业安装试用。



#创建一个名为 file 的文件(加后缀就是文本),touch是一个命令
$ touch file 

#创建一个名为 file 到文本并编辑
$ vi file.txt 

#进入一个目录,cd是一个命令
$ cd /etc/

#查看当前所在目录
$ pwd

tail file.txt #file文本最后10行内容显示到终端上。

echo 'hello python' # 显示字符串
sudo apt-get update # 超级权限 获取更新

Ubuntu 基本命令行操作
一、文件/文件夹管理 

ls 列出当前目录文件(不包括隐含文件) 
ls -a 列出当前目录文件(包括隐含文件) 
ls -l 列出当前目录下文件的详细信息 

cd .. 回当前目录的上一级目录 
cd - 回上一次所在的目录 
cd ~ 或 cd 回当前用户的宿主目录 
mkdir 目录名 创建一个目录 
rmdir 空目录名 删除一个空目录 
rm 文件名 文件名 删除一个文件或多个文件 
rm -rf 非空目录名 删除一个非空目录下的一切

[Tab]
使用Tab键来进行命令补全,Tab键一般是在字母Q旁边,这个技巧给你带来的最大的好处就是当你忘记某个命令的全称时可以只输入它的开头的一部分,然后按下Tab键就可以得到提示或者帮助完成：



当然不止补全命令,补全目录、补全命令参数都是没问题的：



[Ctrl+c]
想想你有没有遇到过这种情况,当你在 Linux 命令行中无意输入了一个不知道的命令,或者错误地使用了一个命令,导致在终端里出现了你无法预料的情况,比如,屏幕上只有光标在闪烁却无法继续输入命令,或者不停地输出一大堆你不想要的结果。你想要立即停止并恢复到你可控的状态,那该怎么办呢？这时候你就可以使用Ctrl+c键来强行终止当前程序(你可以放心它并不会使终端退出)。

尝试输入以下命令：

$ tail
然后你会发现你接下来的输入都没有任何反应了,只是将你输入的东西显示出来,现在你可以使用Ctrl+c,来中断这个你目前可能还不知道是什么的程序(在后续课程中我们会具体解释这个tail命令是什么)。

又或者输入：

$ find /


显然这不是你想的结果,可以使用Ctrl+c结束。

虽然这个按着很方便,但不要随便按,因为有时候,当你看到终端没有任何反应或提示,也不能接受你的输入时,可能只是运行的程序需要你耐心等一下,就不要急着按Ctrl+c了。

其他一些常用快捷键
按键	作用
Ctrl+d	键盘输入结束或退出终端
Ctrl+s	暂停当前程序,暂停后按下任意键恢复运行
Ctrl+z	将当前程序放到后台运行,恢复到前台为命令fg
Ctrl+a	将光标移至输入行头,相当于Home键
Ctrl+e	将光标移至输入行末,相当于End键
Ctrl+k	删除从光标所在位置到行末
Alt+Backspace	向前删除一个单词
Shift+PgUp	将终端显示向上滚动
Shift+PgDn	将终端显示向下滚动
2) 学会利用历史输入命令
很简单,你可以使用键盘上的方向上键↑,恢复你之前输入过的命令,你一试便知。

3) 学会使用通配符
通配符是一种特殊语句,主要有星号(*)和问号(?),用来对字符串进行模糊匹配(比如文件名、参数名)。当查找文件夹时,可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时,常常使用通配符代替一个或多个真正字符。

终端里面输入的通配符是由 Shell 处理的,不是由所涉及的命令语句处理的,它只会出现在命令的“参数值”里(它不能出现在命令名称里, 命令不记得,那就用Tab补全)。当 Shell 在“参数值”中遇到了通配符时,Shell 会将其当作路径或文件名在磁盘上搜寻可能的匹配：若符合要求的匹配存在,则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给“命令”,然后再由命令进行处理。总之,通配符实际上就是一种 Shell 实现的路径扩展功能。在通配符被处理后, Shell 会先完成该命令的重组,然后继续处理重组后的命令,直至执行该命令。

首先回到用户家目录：

$ cd /home/shiyanlou
然后使用 touch 命令创建 2 个文件,后缀都为 txt：

$ touch asd.txt fgh.txt
可以给文件随意命名,假如过了很长时间,你已经忘了这两个文件的文件名,现在你想在一大堆文件中找到这两个文件,就可以使用通配符：

$ ls *.txt


在创建文件的时候,如果需要一次性创建多个文件,比如：“love_1_linux.txt,love_2_linux.txt,... love_10_linux.txt”。在 Linux 中十分方便：

$ touch love_{1..10}_shiyanlou.txt


Shell 常用通配符：

字符	含义
*	匹配 0 或多个字符
?	匹配任意一个字符
[list]	匹配 list 中的任意单一字符
[^list]	匹配 除list 中的任意单一字符以外的字符
[c1-c2]	匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]
{string1,string2,...}	匹配 string1 或 string2 (或更多)其一字符串
{c1..c2}	匹配 c1-c2 中全部字符 如{1..10}
4) 学会在命令行中获取帮助
在 Linux 环境中,如果你遇到困难,可以使用man命令,它是Manual pages的缩写。

Manual pages 是 UNIX 或类 UNIX 操作系统中在线软件文档的一种普遍的形式, 内容包括计算机程序(包括库和系统调用)、正式的标准和惯例,甚至是抽象的概念。用户可以通过执行man命令调用手册页。

你可以使用如下方式来获得某个命令的说明和使用方式的详细介绍：

$ man <command_name>
比如你想查看 man 命令本身的使用方式,你可以输入：

man man
通常情况下,man 手册里面的内容都是英文的,这就要求你有一定的英文基础。man 手册的内容很多,涉及了 Linux 使用过程中的方方面面。为了便于查找,man 手册被进行了分册(分区段)处理,在 Research UNIX、BSD、OS X 和 Linux 中,手册通常被分为8个区段,安排如下：

区段	说明
1	一般命令
2	系统调用
3	库函数,涵盖了C标准函数库
4	特殊文件(通常是/dev中的设备)和驱动程序
5	文件格式和约定
6	游戏和屏保
7	杂项
8	系统管理命令和守护进程
要查看相应区段的内容,就在 man 后面加上相应区段的数字即可,如：

$ man 1 ls
会显示第一区段中的ls命令 man 页面。

所有的手册页遵循一个常见的布局,为了通过简单的 ASCII 文本展示而被优化,而这种情况下可能没有任何形式的高亮或字体控制。一般包括以下部分内容：

NAME(名称)

该命令或函数的名称,接着是一行简介。

SYNOPSIS(概要)

对于命令,正式的描述它如何运行,以及需要什么样的命令行参数。对于函数,介绍函数所需的参数,以及哪个头文件包含该函数的定义。

DESCRIPTION(说明)

命令或函数功能的文本描述。

EXAMPLES(示例)

常用的一些示例。

SEE ALSO(参见)

相关命令或函数的列表。

也可能存在其它部分内容,但这些部分没有得到跨手册页的标准化。常见的例子包括：OPTIONS(选项),EXIT STATUS(退出状态),ENVIRONMENT(环境),BUGS(程序漏洞),FILES(文件),AUTHOR(作者),REPORTING BUGS(已知漏洞),HISTORY(历史)和 COPYRIGHT(版权)。

通常 man 手册中的内容很多,你可能不太容易找到你想要的结果,不过幸运的是你可以在 man 中使用搜索/<你要搜索的关键字>,查找完毕后你可以使用n键切换到下一个关键字所在处,shift+n为上一个关键字所在处。使用Space(空格键)翻页,Enter(回车键)向下滚动一行,或者使用k,j(vim 编辑器的移动键)进行向前向后滚动一行。按下h键为显示使用帮助(因为 man 使用 less 作为阅读器,实为less工具的帮助),按下q退出。

想要获得更详细的帮助,你还可以使用info命令,不过通常使用man就足够了。如果你知道某个命令的作用,只是想快速查看一些它的某个具体参数的作用,那么你可以使用--help参数,大部分命令都会带有这个参数,如：

$ ls --help


1.1 实验内容
Linux 中创建、删除用户,及用户组等操作。
Linux 中的文件权限设置。
1.2 实验知识点
Linux 用户管理
Linux 权限管理

通过第一节课程的学习,你应该已经知道,Linux 是一个可以实现多用户登陆的操作系统,比如“李雷”和“韩梅梅”都可以同时登陆同一台主机,他们共享一些主机的资源,但他们也分别有自己的用户空间,用于存放各自的文件。但实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里,但是由于 Linux 的 用户管理 和 权限机制,不同用户不可以轻易地查看、修改彼此的文件。

下面我们就来学习一下 Linux 下的账户管理的基础知识。

请打开终端,输入命令：

$ who am i

或者

$ who mom likes
3-2.1-1 输出的第一列表示打开当前伪终端的用户的用户名(要查看当前登录用户的用户名,去掉空格直接使用 whoami 即可),第二列的 pts/0 中 pts 表示伪终端,所谓伪是相对于 /dev/tty 设备而言的,还记得上一节讲终端时的那七个使用 [Ctrl]+[Alt]+[F1]～[F7] 进行切换的 /dev/tty 设备么,这是“真终端”,伪终端就是当你在图形用户界面使用 /dev/tty7 时每打开一个终端就会产生一个伪终端, pts/0 后面那个数字就表示打开的伪终端序号,你可以尝试再打开一个终端,然后在里面输入 who am i ,看第二列是不是就变成 pts/1 了,第三列则表示当前伪终端的启动时间。

who 命令其它常用参数

参数	说明
-a	打印能打印的全部
-d	打印死掉的进程
-m	同am i,mom likes
-q	打印当前登录用户数及用户名
-u	打印当前登录用户登录信息
-r	打印运行等级

在 Linux 系统里, root 账户拥有整个系统至高无上的权利,比如 新建/添加 用户。

root 权限,系统权限的一种,与 SYSTEM 权限可以理解成一个概念,但高于 Administrator 权限,root 是 Linux 和 UNIX 系统中的超级管理员用户帐户,该帐户拥有整个系统至高无上的权力,所有对象他都可以操作,所以很多黑客在入侵系统的时候,都要把权限提升到 root 权限,用 Windows 的方法理解也就是将自己的非法帐户添加到 Administrators 用户组。更比如安卓操作系统中(基于 Linux 内核)获得 root 权限之后就意味着已经获得了手机的最高权限,这时候你可以对手机中的任何文件(包括系统文件)执行所有增、删、改、查的操作。

我们一般登录系统时都是以普通账户的身份登录的,要创建用户需要 root 权限,这里就要用到 sudo 这个命令了。不过使用这个命令有两个大前提,一是你要知道当前登录用户的密码,二是当前用户必须在 sudo 用户组。shiyanlou 用户也属于 sudo 用户组(稍后会介绍如何查看和添加用户组)。

su,su- 与 sudo
需要注意 Linux 环境下输入密码是不会显示的。

su <user> 可以切换到用户 user,执行时需要输入目标用户的密码,sudo <cmd> 可以以特权级别运行 cmd 命令,需要当前用户属于 sudo 组,且需要输入当前用户的密码。su - <user> 命令也是切换用户,同时环境变量也会跟着改变成目标用户的环境变量。

现在我们新建一个叫 lilei 的用户：

$ sudo adduser python2019
实验楼的环境目前设置为 shiyanlou 用户执行 sudo 不需要输入密码,通常此处需要按照提示输入 shiyanlou 密码(Linux 下密码输入是不显示任何内容的),shiyanlou 用户密码可以通过点击右侧边栏的SSH直连查看。然后是给 lilei 用户设置密码,后面的选项的一些内容你可以选择直接回车使用默认值：

3-2.2-1

这个命令不但可以添加用户到系统,同时也会默认为新用户创建 home 目录：

$ ls /home
现在你已经创建好一个用户,并且你可以使用你创建的用户登录了,使用如下命令切换登录用户：

$ su -l lilei
输入刚刚设置的 lilei 的密码,然后输入如下命令并查看输出：

$ who am i
$ whoami
$ pwd
退出当前用户跟退出终端一样可以使用 exit 命令或者使用快捷键 Ctrl+d。

在 Linux 里面每个用户都有一个归属(用户组),用户组简单地理解就是一组用户的集合,它们共享一些资源和权限,同时拥有私有资源,就跟家的形式差不多,你的兄弟姐妹(不同的用户)属于同一个家(用户组),你们可以共同拥有这个家(共享资源),爸妈对待你们都一样(共享权限),你偶尔写写日记,其他人未经允许不能查看(私有资源和权限)。当然一个用户是可以属于多个用户组的,正如你既属于家庭,又属于学校或公司。

在 Linux 里面如何知道自己属于哪些用户组呢？

方法一：使用 groups 命令
$ groups shiyanlou
此处输入图片的描述

其中冒号之前表示用户,后面表示该用户所属的用户组。这里可以看到 shiyanlou 用户属于 shiyanlou 用户组,每次新建用户如果不指定用户组的话,默认会自动创建一个与用户名相同的用户组(差不多就相当于家长的意思,或者说是老总)。默认情况下在 sudo 用户组里的可以使用 sudo 命令获得 root 权限。shiyanlou 用户也可以使用 sudo 命令,为什么这里没有显示在 sudo 用户组里呢？可以查看下 /etc/sudoers.d/shiyanlou 文件,我们在 /etc/sudoers.d 目录下创建了这个文件,从而给 shiyanlou 用户赋予了 sudo 权限：

此处输入图片的描述

方法二：查看 /etc/group 文件
$ cat /etc/group | sort
这里 cat 命令用于读取指定文件的内容并打印到终端输出,后面会详细讲它的使用。 | sort 表示将读取的文本进行一个字典排序再输出,然后你将看到如下一堆输出,你可以在最下面看到 shiyanlou 的用户组信息：

3-2.3-3

没找到,没关系,你可以使用命令过滤掉一些你不想看到的结果：

$ cat /etc/group | grep -E "shiyanlou"
此处输入图片的描述

/etc/group 文件格式说明
/etc/group 的内容包括用户组(Group)、用户组口令、GID 及该用户组所包含的用户(User),每个用户组一条记录。格式如下：

group_name:password:GID:user_list

你看到上面的 password 字段为一个 x 并不是说密码就是它,只是表示密码不可见而已。

这里需要注意,如果用户主用户组,即用户的 GID 等于用户组的 GID,那么最后一个字段 user_list 就是空的,比如 shiyanlou 用户,在 /etc/group 中的 shiyanlou 用户组后面是不会显示的。lilei 用户,在 /etc/group 中的 lilei 用户组后面是不会显示的。

将其它用户加入 sudo 用户组
默认情况下新创建的用户是不具有 root 权限的,也不在 sudo 用户组,可以让其加入 sudo 用户组从而获取 root 权限：

# 注意 Linux 上输入密码是不会显示的
$ su -l lilei
$ sudo ls
会提示 lilei 不在 sudoers 文件中,意思就是 lilei 不在 sudo 用户组中,至于 sudoers 文件(/etc/sudoers)你现在最好不要动它,操作不慎会导致比较麻烦的后果。

使用 usermod 命令可以为用户添加用户组,同样使用该命令你必需有 root 权限,你可以直接使用 root 用户为其它用户添加用户组,或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。

这里我用 shiyanlou 用户执行 sudo 命令将 lilei 添加到 sudo 用户组,让它也可以使用 sudo 命令获得 root 权限：

$ su shiyanlou # 此处需要输入shiyanlou用户密码,点击右侧工具栏“SSH直连”,可以看到密码。
$ groups lilei
$ sudo usermod -G sudo lilei
$ groups lilei
然后你再切换回 lilei 用户,现在就可以使用 sudo 获取 root 权限了。

删除用户是很简单的事：
$ sudo deluser lilei --remove-home

文件权限就是文件的访问控制权限,即哪些用户和组群可以访问文件以及可以执行什么样的操作。

Unix/Linux系统是一个典型的多用户系统,不同的用户处于不同的地位,对文件和目录有不同的访问权限。为了保护系统的安全性,Unix/Linux系统除了对用户权限作了严格的界定外,还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。

在 Unix/Linux中的每一个文件或目录都包含有访问权限,这些访问权限决定了谁能访问和如何访问这些文件和目录。


我们之前已经很多次用到 ls 命令了,如你所见,我们用它来列出并显示当前目录下的文件,当然这是在不带任何参数的情况下,它能做的当然不止这么多,现在我们就要用它来查看文件权限。

使用较长格式列出文件：

$ ls -l


你可能除了知道最后面那一项是文件名之外,其它项就不太清楚了,那么到底是什么意思呢：



可能你还是不太明白,比如第一项文件类型和权限那一堆东西具体指什么,链接又是什么,何为最后修改时间,下面一一道来：



文件类型
关于文件类型,这里有一点你必需时刻牢记 Linux 里面一切皆文件,正因为这一点才有了设备文件( /dev 目录下有各种设备文件,大都跟具体的硬件设备相关)这一说。 socket：网络套接字,具体是什么,感兴趣的用户可以自己去了解或期待实验楼的后续相关课程。pipe 管道,这个东西很重要,我们以后将会讨论到,这里你先知道有它的存在即可。软链接文件：链接文件是分为两种的,另一种当然是“硬链接”(硬链接不常用,具体内容不作为本课程讨论重点,而软链接等同于 Windows 上的快捷方式,你记住这一点就够了)。

文件权限
读权限,表示你可以使用 cat <file name> 之类的命令来读取某个文件的内容；写权限,表示你可以编辑和修改某个文件； 执行权限,通常指可以运行的二进制程序文件或者脚本文件,如同 Windows 上的 exe 后缀的文件,不过 Linux 上不是通过文件后缀名来区分文件的类型。你需要注意的一点是,一个目录同时具有读权限和执行权限才可以打开并查看内部文件,而一个目录要有写权限才允许在其中创建其它文件,这是因为目录文件实际保存着该目录里面的文件的列表等信息。

所有者权限,这一点相信你应该明白了,至于所属用户组权限,是指你所在的用户组中的所有其它用户对于该文件的权限,比如,你有一个 iPad,那么这个用户组权限就决定了你的兄弟姐妹有没有权限使用它破坏它和占有它。

链接数
链接到该文件所在的 inode 结点的文件名数目(关于这个概念涉及到 Linux 文件系统的相关概念知识,不在本课程的讨论范围,感兴趣的用户可以自己去了解)。

文件大小
以 inode 结点大小为单位来表示的文件大小,你可以给 ls 加上 -lh 参数来更直观的查看文件的大小。

明白了文件权限的一些概念,我们顺带补充一下关于 ls 命令的一些其它常用的用法：

显示除了 .(当前目录)和 ..(上一级目录)之外的所有文件,包括隐藏文件(Linux 下以 . 开头的文件为隐藏文件)。
$ ls -A
3-2.3-4

当然,你可以同时使用 -A 和 -l 参数：

$ ls -Al
查看某一个目录的完整属性,而不是显示目录里面的文件属性：

$ ls -dl <目录名>
显示所有文件大小,并以普通人类能看懂的方式呈现：
$ ls -AsSh
其中小 s 为显示文件大小,大 S 为按文件大小排序,若需要知道如何按其它方式排序,请使用“man”命令查询。
# 以上是用户及文件权限管理 3.1 查看文件权限



若前面已经执行删除lilei用户的命令,这里重新创建一下。

假设目前是 lilei 用户登录,新建一个文件,命名为 “ iphone6 ”：

# 注意当前的用户必须是 lilei
# 如果是 shiyanlou 用户需要切换到 lilei(如果之前已经删除需要重新创建下)
$ su lilei
$ cd /home/lilei
$ touch iphone6
可见文件所有者是 lilei ：

3-3.2-1

现在,换回到 shiyanlou 用户身份,使用以下命令变更文件所有者为 shiyanlou ：

# 需要切换到 shiyanlou 用户执行以下操作
$ cd /home/lilei
$ ls iphone6
$ sudo chown shiyanlou iphone6
现在查看,发现 文件所有者成功修改为 shiyanlou ：

3-3.2-2

在讲 Linux 目录结构之前,你首先要清楚一点,那就是 Linux 的目录与 Windows 的目录的区别,或许对于一般操作上的感受来说没有多大不同,但从它们的实现机制来说是完全不同的。

一种不同是体现在目录与存储介质(磁盘,内存,DVD 等)的关系上,以往的 Windows 一直是以存储介质为主的,主要以盘符(C 盘,D 盘...)及分区来实现文件管理,然后之下才是目录,目录就显得不是那么重要,除系统文件之外的用户文件放在任何地方任何目录也是没有多大关系。所以通常 Windows 在使用一段时间后,磁盘上面的文件目录会显得杂乱无章(少数善于整理的用户除外吧)。然而 UNIX/Linux 恰好相反,UNIX 是以目录为主的,Linux 也继承了这一优良特性。 Linux 是以树形目录结构的形式来构建整个系统的,可以理解为树形目录是一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的,但从逻辑上来说 Linux 的磁盘是“挂在”(挂载在)目录上的,每一个目录不仅能使用本地磁盘分区的文件系统,也可以使用网络上的文件系统。举例来说,可以利用网络文件系统(Network File System,NFS)服务器载入某特定目录等。


Linux 的目录结构说复杂很复杂,说简单也很简单。复杂在于,因为系统的正常运行是以目录结构为基础的,对于初学者来说里面大部分目录都不知道其作用,重要与否,特别对于那些曾经的重度 Windows 用户,他们会纠结很长时间,关于我安装的软件在哪里这类问题。说它简单是因为,其中大部分目录结构是规定好了的(FHS 标准),是死的,当你掌握后,你在里面的一切操作都会变得井然有序。

FHS(英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准),多数 Linux 版本采用这种文件组织形式,FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。

FHS 定义了两层规范,第一层是, / 下面的各个目录应该要放什么文件数据,例如 /etc 应该放置设置文件,/bin 与 /sbin 则应该放置可执行文件等等。

第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统日志文件,/usr/share 放置共享数据等等。

FHS_2.3 标准文档

如果觉得图片不清晰,建议另存为到本地放大查看：

路径
有人可能不明白这路径是指什么,有什么用。顾名思义,路径就是你要去哪儿的路线嘛。如果你想进入某个具体的目录或者想获得某个目录的文件(目录本身也是文件)那就得用路径来找到了。

使用 cd 命令可以切换目录,在 Linux 里面使用 . 表示当前目录,.. 表示上一级目录(注意,我们上一节介绍过的,以 . 开头的文件都是隐藏文件,所以这两个目录必然也是隐藏的,你可以使用 ls -a 命令查看隐藏文件), - 表示上一次所在目录,～ 通常表示当前用户的 home 目录。使用 pwd 命令可以获取当前所在路径(绝对路径)。

进入上一级目录：

$ cd ..
进入你的 home 目录：

$ cd ~ 
# 或者 cd /home/<你的用户名> 
使用 pwd 获取当前路径：

$ pwd
4-2.2-1

绝对路径
关于绝对路径,简单地说就是以根" / "目录为起点的完整路径,以你所要到的目录为终点,表现形式如： /usr/local/bin,表示根目录下的 usr 目录中的 local 目录中的 bin 目录。

相对路径
相对路径,也就是相对于你当前的目录的路径,相对路径是以当前目录 . 为起点,以你所要到的目录为终点,表现形式如： usr/local/bin (这里假设你当前目录为根目录)。你可能注意到,我们表示相对路径实际并没有加上表示当前目录的那个 . ,而是直接以目录名开头,因为这个 usr 目录为 / 目录下的子目录,是可以省略这个 . 的(以后会讲到一个类似不能省略的情况)；如果是当前目录的上一级目录,则需要使用 .. ,比如你当前目录为 home 目录,根目录就应该表示为 ../../ ,表示上一级目录( home 目录)的上一级目录( / 目录)。

下面我们以你的 home目录为起点,分别以绝对路径和相对路径的方式进入 /usr/local/bin 目录：

# 绝对路径
$ cd /usr/local/bin
# 相对路径
$ cd ../../usr/local/bin
4-2.2-2

进入一个目录,可以使用绝对路径也可以使用相对路径,那我们应该在什么时候选择正确的方式进入某个目录呢。就是凭直觉嘛,你觉得怎样方便就使用哪一个,而不用特意只使用某一种。比如假设我当前在 /usr/local/bin 目录,我想进入上一级的 local 目录你说是使用 cd .. 方便还是 cd /usr/local 方便？而如果要进入的是 usr 目录,那么 cd /usr ,就比 cd ../.. 方便一点了。

提示：在进行目录切换的过程中请多使用 Tab 键自动补全,可避免输入错误,连续按两次 Tab 可以显示全部候选结果。

如果你觉得看这个不明白,那么可以试试最真实最直观的方式,执行如下命令：

$ tree /
如果提示" command not found ",就先安装：

# 因为我们的环境的原因,每次新启动实验会清除系统恢复到初始状态,所以需要手动更新软件包索引,以便我们安装时能找到相应软件包的源。

sudo apt-get update

sudo apt-get install tree
关于上面提到的 FHS,这里还有个很重要的内容你一定要明白,FHS 是根据以往无数 Linux 用户和开发者的经验总结出来的,并且会维持更新,FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动(注意,不是不能,学习过程中,不要怕这些),将目录定义为四种交互作用的形态,如下表所示：

此处输入图片的描述

下一步
隐藏工具栏
21:15 
 
这一节我们主要讲解文件常用的基本操作,包括：新建、复制、删除、移动文件与文件重命名、查看文件、查看文件类型、以及编辑文件。


新建空白文件
使用 touch 命令创建空白文件,关于 touch 命令,其主要作用是来更改已有文件的时间戳的(比如,最近访问时间,最近修改时间),但其在不加任何参数的情况下,只指定一个文件名,则可以创建一个指定文件名的空白文件(不会覆盖已有同名文件),当然你也可以同时指定该文件的时间戳,更多关于 touch 命令的用法,会在下一讲文件搜索中涉及。

创建名为 test 的空白文件,因为在其它目录没有权限,所以需要先 cd ~ 切换回用户的 /home/shiyanlou 目录：

$ cd /home/shiyanlou
$ touch test
新建目录
使用 mkdir(make directories)命令可以创建一个空目录,也可同时指定创建目录的权限属性。

创建名为“ mydir ”的空目录：

$ mkdir mydir
使用 -p 参数,同时创建父目录(如果不存在该父目录),如下我们同时创建一个多级目录(这在安装软件、配置安装路径时非常有用)：

$ mkdir -p father/son/grandson
4-3.1-1

后面的目录路径,以绝对路径的方式表示也是可以的。


新建空白文件
使用 touch 命令创建空白文件,关于 touch 命令,其主要作用是来更改已有文件的时间戳的(比如,最近访问时间,最近修改时间),但其在不加任何参数的情况下,只指定一个文件名,则可以创建一个指定文件名的空白文件(不会覆盖已有同名文件),当然你也可以同时指定该文件的时间戳,更多关于 touch 命令的用法,会在下一讲文件搜索中涉及。

创建名为 test 的空白文件,因为在其它目录没有权限,所以需要先 cd ~ 切换回用户的 /home/shiyanlou 目录：

$ cd /home/shiyanlou
$ touch test
新建目录
使用 mkdir(make directories)命令可以创建一个空目录,也可同时指定创建目录的权限属性。

创建名为“ mydir ”的空目录：

$ mkdir mydir
使用 -p 参数,同时创建父目录(如果不存在该父目录),如下我们同时创建一个多级目录(这在安装软件、配置安装路径时非常有用)：

$ mkdir -p father/son/grandson
4-3.1-1

后面的目录路径,以绝对路径的方式表示也是可以的。

删除文件
使用 rm(remove files or directories)命令删除一个文件：

$ rm test
有时候你会遇到想要删除一些为只读权限的文件,直接使用 rm 删除会显示一个提示,如下：

4-3.3-1

你如果想忽略这提示,直接删除文件,可以使用 -f 参数强制删除：

$ rm -f test
删除目录
跟复制目录一样,要删除一个目录,也需要加上 -r 或 -R 参数：

$ rm -r family

移动文件
使用 mv(move or rename files)命令移动文件(剪切)。将文件“ file1 ”移动到 Documents 目录：

mv 源目录文件 目的目录：

$ mkdir Documents
$ touch file1
$ mv file1 Documents
4-3.4-1

重命名文件
将文件“ file1 ”重命名为“ myfile ”：

mv 旧的文件名 新的文件名：

$ mv file1 myfile
批量重命名
要实现批量重命名,mv 命令就有点力不从心了,我们可以使用一个看起来更专业的命令 rename 来实现。不过它要用 perl 正则表达式来作为参数,关于正则表达式我们要在后面才会介绍到,这里只做演示,你只要记得这个 rename 命令可以批量重命名就好了,以后再重新学习也不会有任何问题,毕竟你已经掌握了一个更常用的 mv 命令。

$ cd /home/shiyanlou/

# 使用通配符批量创建 5 个文件:
$ touch file{1..5}.txt

# 批量将这 5 个后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件:
$ rename 's/\.txt/\.c/' *.txt

# 批量将这 5 个文件,文件名和后缀改为大写:
$ rename 'y/a-z/A-Z/' *.c
简单解释一下上面的命令,rename 是先使用第二个参数的通配符匹配所有后缀为 .txt 的文件,然后使用第一个参数提供的正则表达式将匹配的这些文件的 .txt 后缀替换为 .c,这一点在我们后面学习了 sed 命令后,相信你会更好地理解。

使用 cat,tac 和 nl 命令查看文件
前两个命令都是用来打印文件内容到标准输出(终端),其中 cat 为正序显示,tac 为倒序显示。

标准输入输出：当我们执行一个 shell 命令行时通常会自动打开三个标准文件,即标准输入文件(stdin),默认对应终端的键盘、标准输出文件(stdout)和标准错误输出文件(stderr),后两个文件都对应被重定向到终端的屏幕,以便我们能直接看到输出内容。进程将从标准输入文件中得到输入数据,将正常输出数据输出到标准输出文件,而将错误信息送到标准错误文件中。

比如我们要查看之前从 /etc 目录下拷贝来的 passwd 文件：

$ cd /home/shiyanlou
$ cp /etc/passwd passwd
$ cat passwd
可以加上 -n 参数显示行号：

$ cat -n passwd
4-3.4-1

nl 命令,添加行号并打印,这是个比 cat -n 更专业的行号打印命令。

这里简单列举它的常用的几个参数：

-b : 指定添加行号的方式,主要有两种：
    -b a:表示无论是否为空行,同样列出行号("cat -n"就是这种方式)
    -b t:只列出非空行的编号并列出(默认为这种方式)
-n : 设置行号的样式,主要有三种：
    -n ln:在行号字段最左端显示
    -n rn:在行号字段最右边显示,且不加 0
    -n rz:在行号字段最右边显示,且加 0
-w : 行号字段占用的位数(默认为 6 位)
4-3.5-2

你会发现使用这几个命令,默认的终端窗口大小,一屏显示不完文本的内容,得用鼠标拖动滚动条或者滑动滚轮才能继续往下翻页,要是可以直接使用键盘操作翻页就好了,那么你就可以使用下面要介绍的命令。

使用 more 和 less 命令分页查看文件
如果说上面的 cat 是用来快速查看一个文件的内容的,那么这个 more 和 less 就是天生用来"阅读"一个文件的内容的,比如说 man 手册内部就是使用的 less 来显示内容。其中 more 命令比较简单,只能向一个方向滚动,而 less 为基于 more 和 vi (一个强大的编辑器,我们有单独的课程来让你学习)开发,功能更强大。less 的使用基本和 more 一致,具体使用请查看 man 手册,这里只介绍 more 命令的使用。

使用 more 命令打开 passwd 文件：

$ more passwd
4-3.5-3

打开后默认只显示一屏内容,终端底部显示当前阅读的进度。可以使用 Enter 键向下滚动一行,使用 Space 键向下滚动一屏,按下 h 显示帮助,q 退出。

使用 head 和 tail 命令查看文件
这两个命令,那些性子比较急的人应该会喜欢,因为它们一个是只查看文件的头几行(默认为 10 行,不足 10 行则显示全部)和尾几行。还是拿 passwd 文件举例,比如当我们想要查看最近新增加的用户,那么我们可以查看这个 /etc/passwd 文件,不过我们前面也看到了,这个文件里面一大堆乱糟糟的东西,看起来实在费神啊。因为系统新增加一个用户,会将用户的信息添加到 passwd 文件的最后,那么这时候我们就可以使用 tail 命令了：

$ tail /etc/passwd
甚至更直接的只看一行, 加上 -n 参数,后面紧跟行数：

$ tail -n 1 /etc/passwd
4-3.5-4

关于 tail 命令,不得不提的还有它一个很牛的参数 -f,这个参数可以实现不停地读取某个文件的内容并显示。这可以让我们动态查看日志,达到实时监视的目的。不过我不会在这门基础课程中介绍它的更多细节,感兴趣的用户可以自己去了解。


前面我提到过,在 Linux 中文件的类型不是根据文件后缀来判断的,我们通常使用 file 命令查看文件的类型：

$ file /bin/ls
4-3.6-1

说明这是一个可执行文件,运行在 64 位平台,并使用了动态链接文件(共享库)。


在 Linux 下面编辑文件通常我们会直接使用专门的命令行编辑器比如(emacs,vim,nano),由于涉及 Linux 上的编辑器的内容比较多,且非常重要,故我们有一门单独的基础课专门介绍这中一个编辑器 vim 。强烈希望正在学习这门 Linux 基础课的你先在这里暂停一下,去学习 vim 编辑器 的使用(至少掌握基本的操作),然后再继续本课程后面的内容,因为后面的内容会假设你已经学会了 vim 编辑器的使用。如果你想更加快速地入门,可以直接使用 Linux 内部的 vim 学习教程,输入如下命令即可开始：

$ vimtutor

轻松一下
你是不是觉得在我们的环境中学习轻松愉快毫无压力,所以偶尔偷偷懒也是没有问题的呢？要真是这样可不太好啊,要学会给自己一点压力,严格要求自己才行。你或许会想,要是有人能监督就好了,这样能学得更快。好吧,今天就教你怎么召唤一双眼睛出来监督你：

$ xeyes
你可以使用如下命令将它放到后台运行：

$ nohup xeyes &
4-4-1

1. 创建一个 homework 目录,建立名为 1.txt～10.txt 文件,并删除 1.txt～5.txt 。
2. Linux 的日志文件在哪个目录？

1.1 实验内容
本节实验介绍环境变量的作用与用法,及几种搜索文件的方法。学会这些技巧可以高效地使用 Linux 。

1.2 实验知识点
环境变量的设置
环境变量的修改

变量
要解释环境变量,得先明白变量是什么,准确的说应该是 Shell 变量,所谓变量就是计算机中用于记录一个值(不一定是数值,也可以是字符或字符串)的符号,而这些符号将用于不同的运算处理中。通常变量与值是一对一的关系,可以通过表达式读取它的值并赋值给其它变量,也可以直接指定数值赋值给任意变量。为了便于运算和处理,大部分的编程语言会区分变量的类型,用于分别记录数值、字符或者字符串等等数据类型。Shell 中的变量也基本如此,有不同类型(但不用专门指定类型名),可以参与运算,有作用域限定。

变量的作用域即变量的有效范围(比如一个函数中、一个源文件中或者全局范围),在该范围内只能有一个同名变量。一旦离开则该变量无效,如同不存在这个变量一般。

在 Shell 中如何创建一个变量,如何给变量赋值和如何读取变量的值呢？这部分内容会在 bash 脚本编程 这门课中详细介绍,这里我简单举例说明一下：

使用 declare 命令创建一个变量名为 tmp 的变量：

$ declare tmp
其实也可以不用 declare 预声明一个变量,直接即用即创建,这里只是告诉你 declare 的作用,这在创建其它指定类型的变量(如数组)时会用到。

使用 = 号赋值运算符,将变量 tmp 赋值为 shiyanlou：

$ tmp=shiyanlou
读取变量的值,使用 echo 命令和 $ 符号($ 符号用于表示引用一个变量的值,初学者经常忘记输入)：

$ echo $tmp
此处输入图片的描述

注意：并不是任何形式的变量名都是可用的,变量名只能是英文字母、数字或者下划线,且不能以数字作为开头。

简单理解了变量的概念,就很容易理解环境变量了。环境变量的作用域比自定义变量的要大,如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中,每个进程都有其各自的环境变量设置,且默认情况下,当一个进程被创建时,除了创建过程中明确指定的话,它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上,而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。



通常我们会涉及到的变量类型有三种：

当前 Shell 进程私有用户自定义变量,如上面我们创建的 tmp 变量,只在当前 Shell 中有效。
Shell 本身内建的变量。
从自定义变量导出的环境变量。
也有三个与上述三种环境变量相关的命令：set,env,export。这三个命令很相似,都是用于打印环境变量信息,区别在于涉及的变量范围不同。详见下表：

命 令	说 明
set	显示当前 Shell 所有变量,包括其内建环境变量(与 Shell 外观等相关),用户自定义变量及导出的环境变量。
env	显示与当前用户相关的环境变量,还可以让命令在指定环境中运行。
export	显示从 Shell 中导出成环境变量的变量,也能通过它将自定义变量导出为环境变量。


你可以更直观的使用 vimdiff 工具比较一下它们之间的差别：

$ temp=shiyanlou
$ export temp_env=shiyanlou
$ env|sort>env.txt
$ export|sort>export.txt
$ set|sort>set.txt
上述操作将命令输出通过管道 | 使用 sort 命令排序,再重定向到对象文本文件中。

$ vimdiff env.txt export.txt set.txt
使用 vimdiff 工具比较导出的几个文件的内容：



关于哪些变量是环境变量,可以简单地理解成在当前进程的子进程有效则为环境变量,否则不是(有些人也将所有变量统称为环境变量,只是以全局环境变量和局部环境变量进行区分,我们只要理解它们的实质区别即可)。我们这里用 export 命令来体会一下,先在 Shell 中设置一个变量 temp=shiyanlou,然后再新创建一个子 Shell 查看 temp 变量的值：

此处输入图片的描述

注意：为了与普通变量区分,通常我们习惯将环境变量名设为大写。

永久生效
但是问题来了,当你关机后,或者关闭当前的 shell 之后,环境变量就没了啊。怎么才能让环境变量永久生效呢？

按变量的生存周期来划分,Linux 变量可分为两类：

永久的：需要修改配置文件,变量永久生效；

临时的：使用 export 命令行声明即可,变量在关闭 shell 时失效。

这里介绍两个重要文件 /etc/bashrc(有的 Linux 没有这个文件) 和 /etc/profile ,它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件：

.profile 可以用 ls -a 查看
cd /home/shiyanlou
ls -a 
这个 .profile 只对当前用户永久生效。而写在 /etc/profile 里面的是对所有用户永久生效,所以如果想要添加一个永久生效的环境变量,只需要打开 /etc/profile,在最后加上你想添加的环境变量就好啦。

你可能很早之前就有疑问,我们在 Shell 中输入一个命令,Shell 是怎么知道去哪找到这个命令然后执行的呢？这是通过环境变量 PATH 来进行搜索的,熟悉 Windows 的用户可能知道 Windows 中的也是有这么一个 PATH 环境变量。这个 PATH 里面就保存了 Shell 中执行的命令的搜索路径。

查看 PATH 环境变量的内容：

$ echo $PATH
默认情况下你会看到如下输出：

/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
如果你还记得 Linux 目录结构那一节的内容,你就应该知道上面这些目录下放的是哪一类文件了。通常这一类目录下放的都是可执行文件,当我们在 Shell 中执行一个命令时,系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找,如果存在同名的命令,则执行先找到的那个。

下面我们将练习创建一个最简单的可执行 Shell 脚本和一个使用 C 语言创建的“ hello world ”程序,如果这两部分内容你之前没有学习过,那么你可以进行一个入门学习： C 语言入门教程 高级 Bash 脚本编程指南 Linux Shell Scripting Tutorial (LSST) v2.0 。

创建一个 Shell 脚本文件：

$ cd /home/shiyanlou
$ touch hello_shell.sh
$ gedit hello_shell.sh
在脚本中添加如下内容,保存并退出(注意不要省掉第一行,这不是注释,论坛有用户反映有语法错误,就是因为没有了第一行)：

#!/bin/bash

for ((i=0; i<10; i++));do
    echo "hello shell"
done

exit 0
为文件添加可执行权限：

$ chmod 755 hello_shell.sh
执行脚本：

$ cd /home/shiyanlou
$ ./hello_shell.sh
创建一个 C 语言“ hello world ”程序：

$ cd /home/shiyanlou
$ gedit hello_world.c
#include <stdio.h>

int main(void)
{
    printf("hello world!\n");
    return 0;
}
保存后使用 gcc 生成可执行文件：

$ gcc -o hello_world hello_world.c
gcc 生成二进制文件默认具有可执行权限,不需要修改

在 /home/shiyanlou 家目录创建一个 mybin 目录,并将上述 hello_shell.sh 和 hello_world 文件移动到其中：

$ cd /home/shiyanlou
$ mkdir mybin
$ mv hello_shell.sh hello_world mybin/
现在你可以在 mybin 目录中分别运行你刚刚创建的两个程序：

$ cd mybin
$ ./hello_shell.sh
$ ./hello_world
此处输入图片的描述

回到上一级目录,也就是 shiyanlou 家目录,当再想运行那两个程序时,会发现提示命令找不到,除非加上命令的完整路径,但那样很不方便,如何做到像使用系统命令一样执行自己创建的脚本文件或者程序呢？那就要将命令所在路径添加到 PATH 环境变量了。


在前面我们应该注意到 PATH 里面的路径是以 : 作为分割符的,所以我们可以这样添加自定义路径：

$ PATH=$PATH:/home/shiyanlou/mybin
注意这里一定要使用绝对路径。

现在你就可以在任意目录执行那两个命令了(注意需要去掉前面的 ./)。你可能会意识到这样还并没有很好的解决问题,因为我给 PATH 环境变量追加了一个路径,它也只是在当前 Shell 有效,我一旦退出终端,再打开就会发现又失效了。有没有方法让添加的环境变量全局有效？或者每次启动 Shell 时自动执行上面添加自定义路径到 PATH 的命令？下面我们就来说说后一种方式——让它自动执行。

在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本,以初始化环境,包括添加一些用户自定义环境变量等等。zsh 的配置文件是 .zshrc,相应 Bash 的配置文件为 .bashrc 。它们在 etc 下还都有一个或多个全局的配置文件,不过我们一般只修改用户目录下的配置文件。

我们可以简单地使用下面命令直接添加内容到 .zshrc 中：

$ echo "PATH=$PATH:/home/shiyanlou/mybin" >> .zshrc
上述命令中 >> 表示将标准输出以追加的方式重定向到一个文件中,注意前面用到的 > 是以覆盖的方式重定向到一个文件中,使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。

变量修改
变量的修改有以下几种方式：

变量设置方式	说明
${变量名#匹配字串}	从头向后开始匹配,删除符合匹配字串的最短数据
${变量名##匹配字串}	从头向后开始匹配,删除符合匹配字串的最长数据
${变量名%匹配字串}	从尾向前开始匹配,删除符合匹配字串的最短数据
${变量名%%匹配字串}	从尾向前开始匹配,删除符合匹配字串的最长数据
${变量名/旧的字串/新的字串}	将符合旧字串的第一个字串替换为新的字串
${变量名//旧的字串/新的字串}	将符合旧字串的全部字串替换为新的字串
比如要修改我们前面添加到 PATH 的环境变量。为了避免操作失误导致命令找不到,我们先将 PATH 赋值给一个新的自定义变量 path：

$ path=$PATH
$ echo $path
$ path=${path%/home/shiyanlou/mybin}
# 或使用通配符,*表示任意多个任意字符
$ path=${path%*/mybin}
变量删除
可以使用 unset 命令删除一个环境变量：

$ unset temp

前面我们在 Shell 中修改了一个配置脚本文件之后(比如 zsh 的配置文件 home 目录下的 .zshrc),每次都要退出终端重新打开甚至重启主机之后其才能生效,很是麻烦,我们可以使用 source 命令来让其立即生效,如：

$ cd /home/shiyanlou
$ source .zshrc
source 命令还有一个别名就是 .,上面的命令如果替换成 . 的方式就该是：

$ . ./.zshrc
在使用.的时候,需要注意与表示当前路径的那个点区分开。

注意第一个点后面有一个空格,而且后面的文件必须指定完整的绝对或相对路径名,source 则不需要。

与搜索相关的命令常用的有 whereis(简单快速),which(小而精),find(精而细) 和 locate(快而全) 。

whereis 简单快速
$ whereis who
$ whereis find
此处输入图片的描述

你会看到 whereis find 找到了三个路径,两个可执行文件路径和一个 man 在线帮助文件所在路径,这个搜索很快,因为它并没有从硬盘中依次查找,而是直接从数据库中查询。whereis 只能搜索二进制文件(-b),man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。

locate 快而全
通过“ /var/lib/mlocate/mlocate.db ”数据库查找,不过这个数据库也不是实时更新的,系统会使用定时任务每天自动执行 updatedb 命令更新一次,所以有时候你刚添加的文件,它可能会找不到,需要手动执行一次 updatedb 命令(在我们的环境中必须先执行一次该命令)。它可以用来查找指定目录下的不同文件类型,如查找 /etc 下所有以 sh 开头的文件：

$ sudo apt-get update
$ sudo apt-get install locate
$ locate /etc/sh
注意,它不只是在 /bin 目录下查找,还会自动递归子目录进行查找。

查找 /usr/share/ 下所有 jpg 文件：

$ locate /usr/share/\*.jpg
注意要添加 * 号前面的反斜杠转义,否则会无法找到。

如果想只统计数目可以加上 -c 参数,-i 参数可以忽略大小写进行查找,whereis 的 -b、-m、-s 同样可以使用。

which 小而精
which 本身是 Shell 内建的一个命令,我们通常使用 which 来确定是否安装了某个指定的软件,因为它只从 PATH 环境变量指定的路径中去搜索命令：

$ which man
find 精而细
find 应该是这几个命令中最强大的了,它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性(如文件的时间戳,文件的权限等)进行搜索。find 命令强大到,要把它讲明白至少需要单独好几节课程才行,我们这里只介绍一些常用的内容。

这条命令表示去 /etc/ 目录下面 ,搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式,千万记住 find 的第一个参数是要搜索的地方：

$ sudo find /etc/ -name interfaces
注意 find 命令的路径是作为第一个参数的, 基本命令格式为 find [path] [option] [action] 。

与时间相关的命令参数：

参数	说明
-atime	最后访问时间
-ctime	最后修改文件内容的时间
-mtime	最后修改文件属性的时间
下面以 -mtime 参数举例：

-mtime n：n 为数字,表示为在 n 天之前的“一天之内”修改过的文件
-mtime +n：列出在 n 天之前(不包含 n 天本身)被修改过的文件
-mtime -n：列出在 n 天之内(包含 n 天本身)被修改过的文件
-newer file：file 为一个已存在的文件,列出比 file 还要新的文件名


列出 home 目录中,当天(24 小时之内)有改动的文件：

$ find ~ -mtime 0
列出用户家目录下比 Code 文件夹新的文件：

$ find ~ -newer /home/shiyanlou/Code

轻松一下
《黑客帝国》电影里满屏幕代码的“数字雨”,在 Linux 里面你也可以轻松实现这样的效果,你只需要一个命令 cmatrix 。

需要先安装,因为 Ubuntu 没有预装：

$ sudo apt-get update; sudo apt-get install cmatrix
装好之后先不要急着执行,为了看到更好的效果,我们需要先修改终端的主题配色,在终端上面的【选项】中修改,修改为黑底绿字：

此处输入图片的描述

然后按下 F11 可以全屏显示。

还可以改变代码的颜色：

cmatrix -C red

寻找文件
找出 /etc/ 目录下的所有以 .list 结尾的文件。

文件打包与解压缩
一、实验介绍
二、概念讲解
三、实战
 3.1 zip 压缩打包程序
 3.2 使用 unzip 命令解压缩 zip 文件
 3.3 tar 打包工具
四、总结
 轻松一下
五、作业

1.1 实验内容
介绍 Linux 上常用的压缩/解压工具,主要讲解 zip,tar 的使用。

1.2 知识点
zip 命令
tar 命令
压缩与解压常用组合

在讲 Linux 上的压缩工具之前,有必要先了解一下常见常用的压缩包文件格式。在 Windows 上最常见的不外乎这两种 *.zip,*.7z 后缀的压缩文件。而在 Linux 上面常见的格式除了以上两种外,还有 .rar,*.gz,*.xz,*.bz2,*.tar,*.tar.gz,*.tar.xz,*.tar.bz2,简单介绍如下：

文件后缀名	说明
*.zip	zip 程序打包压缩的文件
*.rar	rar 程序压缩的文件
*.7z	7zip 程序压缩的文件
*.tar	tar 程序打包,未压缩的文件
*.gz	gzip 程序(GNU zip)压缩的文件
*.xz	xz 程序压缩的文件
*.bz2	bzip2 程序压缩的文件
*.tar.gz	tar 打包,gzip 程序压缩的文件
*.tar.xz	tar 打包,xz 程序压缩的文件
*tar.bz2	tar 打包,bzip2 程序压缩的文件
*.tar.7z	tar 打包,7z 程序压缩的文件
讲了这么多种压缩文件,这么多个命令,不过我们一般只需要掌握几个命令即可,包括 zip,tar。下面会依次介绍这几个命令及对应的解压命令。

本小节主要讲解使用zip、tar对文件进行打包压缩以及解压缩的具体命令行的使用。

使用 zip 打包文件夹：
$ cd /home/shiyanlou
$ zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop
$ du -h shiyanlou.zip
$ file shiyanlou.zip
上面命令将目录 /home/shiyanlou/Desktop 打包成一个文件,并查看了打包后文件的大小和类型。第一行命令中,-r 参数表示递归打包包含子目录的全部内容,-q 参数表示为安静模式,即不向屏幕输出信息,-o,表示输出文件,需在其后紧跟打包输出文件名。后面使用 du 命令查看打包后文件的大小(后面会具体说明该命令)。

设置压缩级别为 9 和 1(9 最大,1 最小),重新打包：
$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip
$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip
这里添加了一个参数用于设置压缩级别 -[1-9],1 表示最快压缩但体积大,9 表示体积最小但耗时最久。最后那个 -x 是为了排除我们上一次创建的 zip 文件,否则又会被打包进这一次的压缩文件中,注意：这里只能使用绝对路径,否则不起作用。

我们再用 du 命令分别查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小：

$ du -h -d 0 *.zip ~ | sort
通过 man 手册可知：

h, --human-readable(顾名思义,你可以试试不加的情况)
d, --max-depth(所查看文件的深度)
这样一目了然,你可以看到默认压缩级别应该是最高的,效果很明显,不过你在环境中操作之后看到的压缩文件大小可能跟图上的有些不同,因为系统在使用过程中,会随时生成一些缓存文件在当前用户的家目录中,这对于我们学习命令使用来说,是无关紧要的,可以忽略这些不同。

创建加密 zip 包
使用 -e 参数可以创建加密压缩包：

$ zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop
注意： 关于 zip 命令,因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题,比如换行符(为不可见字符),在 Windows 为 CR+LF(Carriage-Return+Line-Feed：回车加换行),而在 Linux/Unix 上为 LF(换行),所以如果在不加处理的情况下,在 Linux 上编辑的文本,在 Windows 系统上打开可能看起来是没有换行的。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题,那么你还需要对命令做一些修改：

$ zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop
需要加上 -l 参数将 LF 转换为 CR+LF 来达到以上目的。

将 shiyanlou.zip 解压到当前目录：
$ unzip shiyanlou.zip
使用安静模式,将文件解压到指定目录：

$ unzip -q shiyanlou.zip -d ziptest
上述指定目录不存在,将会自动创建。如果你不想解压只想查看压缩包的内容你可以使用 -l 参数：

$ unzip -l shiyanlou.zip
注意： 使用 unzip 解压文件时我们同样应该注意兼容问题,不过这里我们关心的不再是上面的问题,而是中文编码的问题,通常 Windows 系统上面创建的压缩文件,如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码,而 Linux 上面默认使用的是 UTF-8 编码,如果不加任何处理,直接解压的话可能会出现中文乱码的问题(有时候它会自动帮你处理),为了解决这个问题,我们可以在解压时指定编码类型。

使用 -O(英文字母,大写 o)参数指定编码类型：

unzip -O GBK 中文压缩文件.zip
下一步

在 Linux 上面更常用的是 tar 工具,tar 原本只是一个打包工具,只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持,这些压缩工具本身只能实现对文件或目录(单独压缩目录中的文件)的压缩,没有实现对文件的打包压缩,所以我们也无需再单独去学习其他几个工具,tar 的解压和压缩都是同一个命令,只需参数不同,使用比较方便。

下面先掌握 tar 命令一些基本的使用方式,即不进行压缩只是进行打包(创建归档文件)和解包的操作。

创建一个 tar 包：
$ cd /home/shiyanlou
$ tar -cf shiyanlou.tar /home/shiyanlou/Desktop
上面命令中,-c 表示创建一个 tar 包文件,-f 用于指定创建的文件名,注意文件名必须紧跟在 -f 参数之后,比如不能写成 tar -fc shiyanlou.tar,可以写成 tar -f shiyanlou.tar -c ~。你还可以加上 -v 参数以可视的的方式输出打包的文件。上面会自动去掉表示绝对路径的 /,你也可以使用 -P 保留绝对路径符。

解包一个文件(-x 参数)到指定路径的已存在目录(-C 参数)：
$ mkdir tardir
$ tar -xf shiyanlou.tar -C tardir
只查看不解包文件 -t 参数：
$ tar -tf shiyanlou.tar
保留文件属性和跟随链接(符号链接或软链接),有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性(-p 参数)和备份链接指向的源文件而不是链接本身(-h 参数)：
$ tar -cphf etc.tar /etc
对于创建不同的压缩格式的文件,对于 tar 来说是相当简单的,需要的只是换一个参数,这里我们就以使用 gzip 工具创建 *.tar.gz 文件为例来说明。

我们只需要在创建 tar 文件的基础上添加 -z 参数,使用 gzip 来压缩文件：
$ tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop
解压 *.tar.gz 文件：
$ tar -xzf shiyanlou.tar.gz
此处输入图片的描述

现在我们要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可：

压缩文件格式	参数
*.tar.gz	-z
*.tar.xz	-J
*tar.bz2	-j
tar 命令的参数很多,不过常用的就是上述这些,需要了解更多你可以查看 man 手册获取帮助。
下一步

说了这么多,其实平常使用的参数并没有那么复杂,只需要记住常用的组合就可以了。 常用命令：

zip：
打包 ：zip something.zip something (目录请加 -r 参数)
解包：unzip something.zip
指定路径：-d 参数
tar：
打包：tar -cf something.tar something
解包：tar -xf something.tar
指定路径：-C 参数
下一步

天冷的时候,要是有个火炉就好了。这里有个有趣的程序：

$ sudo apt-get install libaa-bin 
# 提示 command not found ,请自行解决
$ aafire
下一步

创建一个名为 test 的文件,分别用 zip 和 tar 打包成压缩包,再解压到 /home/shiyanlou 目录。

下一步

文件系统操作与磁盘管理
一、实验介绍
二、基本操作
三、简单的磁盘管理
 3.1 创建虚拟磁盘
四、作业

1.1 实验内容
本节实验的文件系统操作的内容十分简单,只会包含几个命令的几个参数的讲解,但掌握这些也将对你在学习 Linux 和实验楼后续其他课程的过程中有极大帮助。

因为本课程的定位为入门基础,尽快上手,故没有打算涉及太多理论内容,前面省略了关于 Linux 文件系统的一些基本知识,也因为我们是在线实验环境,所以也避开了很少一部分但又十分重要的关于硬件的内容,我们只能期待用户能够抱着提高自学能力的心态自己去补充相关的知识。

1.2 实验知识点
df,du,mount命令的使用
磁盘相关知识学习

2.1 查看磁盘和目录的容量
使用 df 命令查看磁盘的容量
$ df
在实验楼的环境中你将看到如下的输出内容： 此处输入图片的描述

但在实际的物理主机上会更像这样：



物理主机上的 /dev/sda2 是对应着主机硬盘的分区,后面的数字表示分区号,数字前面的字母 a 表示第几块硬盘(也可能是可移动磁盘),你如果主机上有多块硬盘则可能还会出现 /dev/sdb,/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。

接着你还会看到"1k-块"这个陌生的东西,它表示以磁盘块大小的方式显示容量,后面为相应的以块大小表示的已用和可用容量,在你了解 Linux 的文件系统之前这个就先不管吧,我们以一种你应该看得懂的方式展示：

$ df -h
此处输入图片的描述

现在你就可以使用命令查看你主机磁盘的使用情况了。至于挂载点如果你还记得前面第 4 节介绍 Linux 目录树结构的内容,那么你就应该能很好的理解挂载的概念,这里就不再赘述。

使用 du 命令查看目录的容量
这个命令前面其实已经用了很多次了：

# 默认同样以 块 的大小展示
$ du 
# 加上`-h`参数,以更易读的方式展示
$ du -h
-d参数指定查看目录的深度

# 只查看1级目录的信息
$ du -h -d 0 ~
# 查看2级
$ du -h -d 1 ~
常用参数

du -h #同--human-readable 以K,M,G为单位,提高信息的可读性。
du -a #同--all 显示目录中所有文件的大小。
du -s #同--summarize 仅显示总计,只列出最后加总的值。

来自: http://man.linuxde.net/du
此处输入图片的描述

du(estimate file space usage)命令与df(report file system disk space usage)命令只有一字之差,希望大家注意不要弄混淆了,你可以像我这样从man手册中获取命令的完整描述,记全称就不会搞混了。



2.1 查看磁盘和目录的容量
使用 df 命令查看磁盘的容量
$ df
在实验楼的环境中你将看到如下的输出内容： 此处输入图片的描述

但在实际的物理主机上会更像这样：



物理主机上的 /dev/sda2 是对应着主机硬盘的分区,后面的数字表示分区号,数字前面的字母 a 表示第几块硬盘(也可能是可移动磁盘),你如果主机上有多块硬盘则可能还会出现 /dev/sdb,/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。

接着你还会看到"1k-块"这个陌生的东西,它表示以磁盘块大小的方式显示容量,后面为相应的以块大小表示的已用和可用容量,在你了解 Linux 的文件系统之前这个就先不管吧,我们以一种你应该看得懂的方式展示：

$ df -h
此处输入图片的描述

现在你就可以使用命令查看你主机磁盘的使用情况了。至于挂载点如果你还记得前面第 4 节介绍 Linux 目录树结构的内容,那么你就应该能很好的理解挂载的概念,这里就不再赘述。

使用 du 命令查看目录的容量
这个命令前面其实已经用了很多次了：

# 默认同样以 块 的大小展示
$ du 
# 加上`-h`参数,以更易读的方式展示
$ du -h
-d参数指定查看目录的深度

# 只查看1级目录的信息
$ du -h -d 0 ~
# 查看2级
$ du -h -d 1 ~
常用参数

du -h #同--human-readable 以K,M,G为单位,提高信息的可读性。
du -a #同--all 显示目录中所有文件的大小。
du -s #同--summarize 仅显示总计,只列出最后加总的值。

来自: http://man.linuxde.net/du
此处输入图片的描述

du(estimate file space usage)命令与df(report file system disk space usage)命令只有一字之差,希望大家注意不要弄混淆了,你可以像我这样从man手册中获取命令的完整描述,记全称就不会搞混了。

下面涉及的命令具有一定的危险性,操作不当可能会丢失你的个人数据,初学者建议在虚拟环境中进行操作

通常情况下,这一小节应该直接讲如何挂载卸载磁盘,如何格式化磁盘,如何分区,但如你所见,由于实验环境的限制,环境中没有额外的磁盘可以挂载,也没有空闲空间测试分区命令,所以首先我们会先创建一个虚拟磁盘来进行后续的练习操作。

dd 命令简介(部分说明来自dd (Unix) wiki)
dd命令用于转换和复制文件,不过它的复制不同于cp。之前提到过关于 Linux 的很重要的一点,一切即文件,在 Linux 上,硬件的设备驱动(如硬盘)和特殊设备文件(如/dev/zero和/dev/random)都像普通文件一样,只是在各自的驱动程序中实现了对应的功能,dd 也可以读取文件或写入这些文件。这样,dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。dd程序也可以在复制时处理数据,例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。

dd的命令行语句与其他的 Linux 程序不同,因为它的命令行选项格式为选项=值,而不是更标准的--选项 值或-选项=值。dd默认从标准输入中读取,并写入到标准输出中,但可以用选项if(input file,输入文件)和of(output file,输出文件)改变。

我们先来试试用dd命令从标准输入读入用户的输入到标准输出或者一个文件中：

# 输出到文件
$ dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1
# 输出到标准输出
$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1
# 注
在打完了这个命令后,继续在终端打字,作为你的输入
此处输入图片的描述

上述命令从标准输入设备读入用户输入(缺省值,所以可省略)然后输出到 test 文件,bs(block size)用于指定块大小(缺省单位为 Byte,也可为其指定如'K','M','G'等单位),count用于指定块数量。如上图所示,我指定只读取总共 10 个字节的数据,当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节(一个英文字符占一个字节)内容,显然超过了设定大小。使用du和cat命令看到的写入完成文件实际内容确实只有 10 个字节(那个黑底百分号表示这里没有换行符),而其他的多余输入将被截取并保留在标准输入。

前面说到dd在拷贝的同时还可以实现数据转换,那下面就举一个简单的例子：将输出的英文字符转换为大写再写入文件：

$ dd if=/dev/stdin of=test bs=10 count=1 conv=ucase
此处输入图片的描述

你可以在man文档中查看其他所有转换参数。

使用 dd 命令创建虚拟镜像文件
通过上面一小节,你应该掌握了dd的基本使用,下面就来使用dd命令来完成创建虚拟磁盘的第一步。

从/dev/zero设备创建一个容量为 256M 的空文件：

$ dd if=/dev/zero of=virtual.img bs=1M count=256
$ du -h virtual.img
此处输入图片的描述

然后我们要将这个文件格式化(写入文件系统),这里我们要学到一个(准确的说是一组)新的命令来完成这个需求。

使用 mkfs 命令格式化磁盘(我们这里是自己创建的虚拟磁盘镜像)
你可以在命令行输入 sudo mkfs 然后按下Tab键,你可以看到很多个以 mkfs 为前缀的命令,这些不同的后缀其实就是表示着不同的文件系统,可以用 mkfs 格式化成的文件系统。

我们可以简单的使用下面的命令来将我们的虚拟磁盘镜像格式化为ext4文件系统：

$ sudo mkfs.ext4 virtual.img
此处输入图片的描述

可以看到实际 mkfs.ext4 是使用 mke2fs 来完成格式化工作的。mke2fs 的参数很多,不过我们也不会经常格式化磁盘来玩,所以就掌握这基本用法吧,等你有特殊需求时,再查看 man 文档解决。

更多关于文件系统的知识,请查看wiki： 文件系统 ext3,ext4

如果你想知道 Linux 支持哪些文件系统你可以输入ls -l /lib/modules/$(uname -r)/kernel/fs(我们的环境中无法查看)查看。

使用 mount 命令挂载磁盘到目录树
用户在 Linux/UNIX 的机器上打开一个文件以前,包含该文件的文件系统必须先进行挂载的动作,此时用户要对该文件系统执行 mount 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上,而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备,所以可以挂载一个包含文件系统的文件到目录树。

Linux/UNIX 命令行的 mount 指令是告诉操作系统,对应的文件系统已经准备好,可以使用了,而该文件系统会对应到一个特定的点(称为挂载点)。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。

我们先来使用mount来查看下主机已经挂载的文件系统：

$ sudo mount
此处输入图片的描述

输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名,然后是 on 后面是挂载点,type 后面表示文件系统类型,再后面是挂载选项(比如可以在挂载时设定以只读方式挂载等等)。

那么我们如何挂载真正的磁盘到目录树呢,mount命令的一般格式如下：

mount [options] [source] [directory]
一些常用操作：

mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]
注意：由于实验楼的环境限制,mount 命令挂载及 umount 卸载都无法进行操作,可以简单了解这些步骤。

现在直接来挂载我们创建的虚拟磁盘镜像到/mnt目录：

$ mount -o loop -t ext4 virtual.img /mnt 
# 也可以省略挂载类型,很多时候 mount 会自动识别

# 以只读方式挂载
$ mount -o loop --ro virtual.img /mnt
# 或者mount -o loop,ro virtual.img /mnt
使用 umount 命令卸载已挂载磁盘
注意：由于实验楼的环境限制,mount 命令挂载及 umount 卸载都无法进行操作,可以简单了解这些步骤。

# 命令格式 sudo umount 已挂载设备名或者挂载点,如：
$ sudo umount /mnt
不过遗憾的是,由于我们环境的问题(环境中使用的 Linux 内核在编译时没有添加对 Loop device的支持),所以你将无法挂载成功：

此处输入图片的描述

另外关于 loop 设备,你可能会有诸多疑问,那么请看下面来自维基百科/dev/loop的说明：

在类 UNIX 系统中,/dev/loop(或称vnd (vnode disk)、lofi(循环文件接口))是一种伪设备,这种设备使得文件可以如同块设备一般被访问。

在使用之前,循环设备必须与现存文件系统上的文件相关联。这种关联将提供给用户一个应用程序接口,接口将允许文件视为块特殊文件(参见设备文件系统)使用。因此,如果文件中包含一个完整的文件系统,那么这个文件就能如同磁盘设备一般被挂载。

这种设备文件经常被用于光盘或是磁盘镜像。通过循环挂载来挂载包含文件系统的文件,便使处在这个文件系统中的文件得以被访问。这些文件将出现在挂载点目录。如果挂载目录中本身有文件,这些文件在挂载后将被禁止使用。

使用 fdisk 为磁盘分区(关于分区的一些概念不清楚的用户请参看主引导记录)
注意：由于实验楼的环境限制,fdisk 命令无法进行操作,可以简单了解这些步骤。

同样因为环境中没有物理磁盘,也无法创建虚拟磁盘的原因我们就无法实验练习使用该命令了,下面我将以我的物理主机为例讲解如何为磁盘分区。

# 查看硬盘分区表信息
$ sudo fdisk -l


输出结果中开头显示了我主机上的磁盘的一些信息,包括容量扇区数,扇区大小,I/O 大小等信息。

我们重点看一下中间的分区信息,/dev/sda1,/dev/sda2 为主分区分别安装了 Windows 和 Linux 操作系统,/dev/sda3 为交换分区(可以理解为虚拟内存),/dev/sda4 为扩展分区其中包含 /dev/sda5,/dev/sda6,/dev/sda7,/dev/sda8 四个逻辑分区,因为主机上有几个分区之间有空隙,没有对齐边界扇区,所以分区之间不是完全连续的。

# 进入磁盘分区模式
$ sudo fdisk virtual.img


在进行操作前我们首先应先规划好我们的分区方案,这里我将在使用 128M(可用 127M 左右)的虚拟磁盘镜像创建一个 30M 的主分区剩余部分为扩展分区包含 2 个大约 45M 的逻辑分区。

操作完成后输入p查看结果如下:



最后不要忘记输入w写入分区表。

使用 losetup 命令建立镜像与回环设备的关联
注意：由于实验楼的环境限制,losetup 命令无法进行操作,可以简单了解这些步骤。

同样因为环境原因中没有物理磁盘,也没有 loop device 的原因我们就无法实验练习使用该命令了,下面我将以我的物理主机为例讲解。

$ sudo losetup /dev/loop0 virtual.img
# 如果提示设备忙你也可以使用其它的回环设备,"ls /dev/loop*"参看所有回环设备

# 解除设备关联
$ sudo losetup -d /dev/loop0
然后再使用mkfs格式化各分区(前面我们是格式化整个虚拟磁盘镜像文件或磁盘),不过格式化之前,我们还要为各分区建立虚拟设备的映射,用到kpartx工具,需要先安装：

$ sudo apt-get install kpartx
$ sudo kpartx -av /dev/loop0

# 取消映射
$ sudo kpartx -dv /dev/loop0


接着再是格式化,我们将其全部格式化为 ext4：

$ sudo mkfs.ext4 -q /dev/mapper/loop0p1
$ sudo mkfs.ext4 -q /dev/mapper/loop0p5
$ sudo mkfs.ext4 -q /dev/mapper/loop0p6
格式化完成后在/media目录下新建四个空目录用于挂载虚拟磁盘：

$ mkdir -p /media/virtualdisk_{1..3}
# 挂载磁盘分区
$ sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1
$ sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2
$ sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3

# 卸载磁盘分区
$ sudo umount /dev/mapper/loop0p1
$ sudo umount /dev/mapper/loop0p5
$ sudo umount /dev/mapper/loop0p6
然后：

$ df -h


轻松一下
cowsay命令,可以让你在终端里以一种动物说话的形式打印出一段话。

# 更新软件包
$ sudo apt update

# 安装
$ sudo apt install -y cowsay

# 默认是一只牛
$ cowsay hello shiyanlou

# 加上'-l'参数打印所有支持的动物(其实不只是动物)种类
$ cowsay -l

# 使用'-f'参数选择动物种类
$ cowsay -f elephant hello shiyanlou

# 安装 fortune-zh
$ sudo apt-get install fortune-zh

# 此外它还可以结合我们之前的作业讲过的 fortune 命令一起使用
$ /usr/games/fortune | cowsay -f daemon
此处输入图片的描述


小明在管理服务器的时候发现空间不足了,他找到了一个目录,这个目录占用的空间异常的大,他需要找到这个目录中占用最大的前10个文件,但是这个目录下面的内容太多了,或许一条命令就能够帮助到他,这条命令该怎么写呢？

简而言之：找出当前目录下面占用最大的前十个文件。


Linux下的帮助命令
一、实验介绍
二、内建命令与外部命令
三、帮助命令的使用
 1. help 命令
 2. man 命令
 3. info 命令
四、实验总结


1.1 实验内容
我们时常使用 Linux 的命令,一些常用的命令即使不背我们也能记住,而一些较长的命令或是一些不常用的参数甚至是不常用的命令需要用时怎么也想不出来。本课程将带你好好利用 Linux 系统自带的帮助工具与文档。

1.2 实验知识点
内建命令与外部命令之分
help , man , info命令的使用以及区别

什么是内建命令,什么是外部命令呢？这和帮助命令又有什么关系呢？

因为有一些查看帮助的工具在内建命令与外建命令上是有区别对待的。

内建命令实际上是 shell 程序的一部分,其中包含的是一些比较简单的 Linux 系统命令,这些命令是写在bash源码的builtins里面的,由 shell 程序识别并在 shell 程序内部完成运行,通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程,因此其执行速度比外部命令快。比如：history、cd、exit 等等。

外部命令是 Linux 系统中的实用程序部分,因为实用程序的功能通常都比较强大,所以其包含的程序量也会很大,在系统加载时并不随系统一起被加载到内存中,而是在需要时才将其调入内存。虽然其不包含在 shell 中,但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的,通常放在/bin,/usr/bin,/sbin,/usr/sbin等等。比如：ls、vi等。

简单来说就是：一个是天生自带的天赋技能,一个是后天得来的附加技能。我们可以使用　type 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的

type exit

type vim
得到的是两种结果,若是对ls你还能得到第三种结果

此处输入图片的描述

#得到这样的结果说明是内建命令,正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中
xxx is a shell builtin
#得到这样的结果说明是外部命令,正如上文所说,外部命令在/usr/bin or /usr/sbin等等中
xxx is /usr/bin/xxx
#若是得到alias的结果,说明该指令为命令别名所设定的名称；
xxx is an alias for xx --xxx
下一步

本小节我们将会给大家介绍几个常用的帮助命令。

下一步

本实验环境是 zsh,而 zsh 中内置并没有 help 命令,我们可以进入 bash 中,在 bash 中内置有该命令

bash
做好了以上的准备,我们就可以愉快的使用 help 命令了,我们可以尝试下这个命令:

help ls
得到的结果如图所示,为什么是这样的结果？

此处输入图片的描述

因为 help 命令是用于显示 shell 内建命令的简要帮助信息。帮助信息中显示有该命令的简要说明以及一些参数的使用以及说明,一定记住 help 命令只能用于显示内建命令的帮助信息,不然就会得到你刚刚得到的结果。

那如果是外部命令怎么办,不能就这么抛弃它呀。其实外部命令基本上都有一个参数--help,这样就可以得到相应的帮助,看到你想要的东西了。试试下面这个命令是不是能看到你想要的东西了。

ls --help
此处输入图片的描述

下一步

你可以尝试下这个命令

man ls
实验楼

得到的内容比用 help 更多更详细,而且　man　没有内建与外部命令的区分,因为 man 工具是显示系统手册页中的内容,也就是一本电子版的字典,这些内容大多数都是对命令的解释信息,还有一些相关的描述。通过查看系统文档中的 man 也可以得到程序的更多相关信息和 Linux 的更多特性。

是不是好用许多,当然也不代表 help 就没有存在的必要,当你非常紧急只是忘记该用哪个参数的时候,help 这种显示简单扼要的信息就特别实用,若是不太紧急的时候就可以用 man 这种详细描述的查询方式

在尝试上面这个命令时我们会发现最左上角显示“ LS (1)”,在这里,“ LS ”表示手册名称,而“(1)”表示该手册位于第一章节。这个章节又是什么？在 man 手册中一共有这么几个章节

章节数	说明
1	Standard commands (标准命令)
2	System calls (系统调用)
3	Library functions (库函数)
4	Special devices (设备说明)
5	File formats (文件格式)
6	Games and toys (游戏和娱乐)
7	Miscellaneous (杂项)
8	Administrative Commands (管理员命令)
9	其他(Linux特定的), 用来存放内核例行程序的文档。
打开手册之后我们可以通过 pgup 与 pgdn 或者上下键来上下翻看,可以按 q 退出当前页面

下一步

要是你觉得man显示的信息都还不够,满足不了你的需求,那试试 info 命令,注意实验楼的环境中没有安装 info,可以手动安装,安装和操作步骤如下：

# 安装 info
$ sudo apt-get update
$ sudo apt-get install info
# 查看 ls 命令的 info
$ info ls
Info_for_ls

得到的信息是不是比 man 还要多了,info 来自自由软件基金会的 GNU 项目,是 GNU 的超文本帮助系统,能够更完整的显示出 GNU 信息。所以得到的信息当然更多

man 和 info 就像两个集合,它们有一个交集部分,但与 man 相比,info 工具可显示更完整的　GNU　工具信息。若 man 页包含的某个工具的概要信息在 info 中也有介绍,那么 man 页中会有“请参考 info 页更详细内容”的字样。

下一步

本节我们讲解了内建与外部命令的差别,以及相关的帮助命令的使用。这样通过官方的文档帮助我们最快最有效率的解决当前所遇到的窘境。灵活的使用三个帮助命令,能够很大的提高我们的工作效率

下一步

Linux任务计划crontab
一、实验介绍
二、crontab 的使用
 2.1 crontab 简介
 2.2 crontab 准备
 2.3 crontab 使用
三、crontab 的深入
 进一步学习参考
四、实验总结

1.1 实验内容
我们时常会有一些定期定时的任务,如周期性的清理一下／tmp,周期性的去备份一次数据库,周期性的分析日志等等。而且有时候因为某些因素的限制,执行该任务的时间会很尴尬。本课程将带你很好的利用 Linux 系统的计划工具

1.2 实验知识点
crontab语法
1.3 参考资料
本节部分内容参考以下文档制作：

例行性工作排程(crontab) - 鸟哥私房菜
Linux Crontab 百度百科
下一步

crontab 命令常见于 Unix 和类 Unix 的操作系统之中(Linux 就属于类 Unix 操作系统),用于设置周期性被执行的指令。

下一步
crontab 命令从输入设备读取指令,并将其存放于 crontab 文件中,以供之后读取和执行。通常,crontab 储存的指令被守护进程激活,crond 为其守护进程,crond 常常在后台运行,每一分钟会检查一次是否有预定的作业需要执行。

通过 crontab 命令,我们可以在固定的间隔时间执行指定的系统指令或 shell　script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。

这里我们看一看crontab 的格式

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
下一步
crontab 在本实验环境中需要做一些特殊的准备,首先我们会启动 rsyslog,以便我们可以通过日志中的信息来了解我们的任务是否真正的被执行了(在本实验环境中需要手动启动,而在自己本地中 Ubuntu 会默认自行启动不需要手动启动)

sudo apt-get install -y rsyslog
sudo service rsyslog start
service-rsyslog-start

在本实验环境中 crontab 也是不被默认启动的,同时不能在后台由 upstart 来管理,所以需要我们来启动它:

sudo cron －f &
此处输入图片的描述

下一步
下面将开始 crontab 的使用了,我们通过下面一个命令来添加一个计划任务

crontab -e
第一次启动会出现这样一个画面,这是让我们选择编辑的工具,选择第二个基本的 vim 就可以了

此处输入图片的描述

而选择后我们会进入这样一个画面,这就是添加计划的地方了,与一般的配置文档相同,以#号开头的都是注释,通过文档的最后一排我们可以猜猜 crontab 的格式是什么样的呢？

实验楼

详细的格式可以使用上一节中学习到的 man 命令查看：

man crontab
在了解命令格式之后,我们通过这样的一个例子来完成一个任务的添加,在文档的最后一排加上这样一排命令,该任务是每分钟我们会在/home/shiyanlou目录下创建一个以当前的年月日时分秒为名字的空白文件

*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)
注意 “ % ” 在 crontab 文件中,有结束命令行、换行、重定向的作用,前面加 ” \ ” 符号转义,否则,“ % ” 符号将执行其结束命令行或者换行的作用,并且其后的内容会被做为标准输入发送给前面的命令。

添加成功后我们会得到最后一排 installing new crontab 的一个提示

实验楼

当然我们也可以通过这样的一个指令来查看我们添加了哪些任务

crontab -l 
通过图中的显示,我们也可以看出,我们正确的保存并且添加成功了该任务的

实验楼

虽然我们添加了任务,但是如果 cron 的守护进程并没有启动,它根本都不会监测到有任务,当然也就不会帮我们执行,我们可以通过以下2种方式来确定我们的 cron 是否成功的在后台启动,默默的帮我们做事,若是没有就得执行上文准备中的第二步了

ps aux | grep cron

or

pgrep cron
此处输入图片的描述

通过下图可以看到任务在创建之后,执行了几次,生成了一些文件,且每分钟生成一个：

此处输入图片的描述

我们通过这样一个命令可以查看到执行任务命令之后在日志中的信息反馈

sudo tail -f /var/log/syslog
从图中我们可以看到分别在13点28、29、30分的01秒为我们在 shiyanlou 用户的家目录下创建了文件

此处输入图片的描述

当我们并不需要这个任务的时候我们可以使用这么一个命令去删除任务

crontab -r
通过图中我们可以看出我们删除之后再查看任务列表,系统已经显示该用户并没有任务哦

此处输入图片的描述

下一步
每个用户使用 crontab -e 添加计划任务,都会在 /var/spool/cron/crontabs 中添加一个该用户自己的任务文档,这样目的是为了隔离。

实验楼

如果是系统级别的定时任务,应该如何处理？只需要以 sudo 权限编辑 /etc/crontab 文件就可以。

cron 服务监测时间最小单位是分钟,所以 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron/crontabs 里面的內容。

在 /etc 目录下,cron 相关的目录有下面几个：

实验楼

每个目录的作用：

/etc/cron.daily,目录下的脚本会每天执行一次,在每天的6点25分时运行；
/etc/cron.hourly,目录下的脚本会每个小时执行一次,在每小时的17分钟时运行；
/etc/cron.monthly,目录下的脚本会每月执行一次,在每月1号的6点52分时运行；
/etc/cron.weekly,目录下的脚本会每周执行一次,在每周第七天的6点47分时运行；
系统默认执行时间可以根据需求进行修改。

下一步
本章部分描述参考下面的文档实现,想进一步的学习该知识或者相关知识推荐查看：

例行性工作排程(crontab) - 鸟哥私房菜
下一步
本节我们讲解了 crontab 的一些简单的应用和一些简单的概念。crontab 是 Linux 系统中添加计划任务,定时执行一些必要的脚本所必不可少的工具。


一、实验介绍
二、命令执行顺序的控制
 2.1 顺序执行多条命令
 2.2 有选择的执行命令
 思考
三、管道
 3.1 试用
 3.2 cut 命令,打印每一行的某一字段
 3.3 grep 命令,在文本中或 stdin 中查找匹配字符串
 3.4 wc 命令,简单小巧的计数工具
 3.5 sort 排序命令
 3.6 uniq 去重命令
四、作业
1.1 实验内容
顺序执行、选择执行、管道、cut 命令、grep 命令、wc 命令、sort 命令等,高效率使用 Linux 的技巧。

1.2 实验知识点
cut,grep,wc,sort命令的使用
管道的理解
下一步

1.1 实验内容
顺序执行、选择执行、管道、cut 命令、grep 命令、wc 命令、sort 命令等,高效率使用 Linux 的技巧。

1.2 实验知识点
cut,grep,wc,sort命令的使用
管道的理解
下一步
通常情况下,我们每次只能在终端输入一条命令,按下回车执行,执行完成后,我们再输入第二条命令,然后再按回车执行……,当有时候我们会一次输入多条命令,这个时候的执行过程又是如何的呢？下面我们将为大家详细讲解下命令的执行顺序的控制问题。

下一步
当我们需要使用apt-get安装一个软件,然后安装完成后立即运行安装的软件(或命令工具),又恰巧你的主机才更换的软件源还没有更新软件列表(比如之前我们的环境中,每次重新开始实验就得sudo apt-get update,现在已经没有这个问题了),那么你可能会有如下一系列操作：

$ sudo apt-get update
# 等待——————————然后输入下面的命令
$ sudo apt-get install some-tool //这里some-tool是指具体的软件包,例如：banner
# 等待——————————然后输入下面的命令
$ some-tool
这时你可能就会想：要是我可以一次性输入完,让它自己去依次执行各命令就好了,这就是我们这一小节要解决的问题。

简单的顺序执行你可以使用;来完成,比如上述操作你可以：

$ sudo apt-get update;sudo apt-get install some-tool;some-tool
# 让它自己运行
下一步
关于上面的操作,不知你有没有思考过一个问题,如果我们在让它自动顺序执行命令时,前面的命令执行不成功,而后面的命令又依赖于上一条命令的结果,那么就会造成花了时间,最终却得到一个错误的结果,而且有时候直观的看你还无法判断结果是否正确。那么我们需要能够有选择性的来执行命令,比如上一条命令执行成功才继续下一条,或者不成功又该做出其它什么处理,比如我们使用which来查找是否安装某个命令,如果找到就执行该命令,否则什么也不做(虽然这个操作没有什么实际意义,但可帮你更好的理解一些概念)：

$ which cowsay>/dev/null && cowsay -f head-in ohch~
你如果没有安装cowsay,你可以先执行一次上述命令,你会发现什么也没发生,你再安装好之后你再执行一次上述命令,你也会发现一些惊喜。

上面的&&就是用来实现选择性执行的,它表示如果前面的命令执行结果(不是表示终端输出的内容,而是表示命令执行状态的结果)返回0则执行后面的,否则不执行,你可以从$?环境变量获取上一次命令的返回结果：

此处输入图片的描述

学习过 C 语言的用户应该知道在 C 语言里面&&表示逻辑与,而且还有一个||表示逻辑或,同样 Shell 也有一个||,它们的区别就在于,shell中的这两个符号除了也可用于表示逻辑与和或之外,就是可以实现这里的命令执行顺序的简单控制。||在这里就是与&&相反的控制效果,当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令：

$ which cowsay>/dev/null || echo "cowsay has not been install, please run 'sudo apt-get install cowsay' to install"
除了上述基本的使用之外,我们还可以结合着&&和||来实现一些操作,比如：

$ which cowsay>/dev/null && echo "exist" || echo "not exist"
此处输入图片的描述

我画个流程图来解释一下上面的流程：



下一步
上面我们讲到将&&和||结合起来使用,那么是否以任意顺序都行？比如上面我们是&&在前||在后,反过来可以么？会不会有问题？

下一步
管道是什么？管道是一种通信机制,通常用于进程间的通信(也可通过socket进行网络通信),它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。

管道又分为匿名管道和具名管道(这里将不会讨论在源程序中使用系统调用创建并使用管道的情况,它与命令行的管道在内核中实际都是采用相同的机制)。我们在使用一些过滤程序时经常会用到的就是匿名管道,在命令行中由|分隔符表示,|在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道,通常只会在源程序中用到具名管道。下面我们就将通过一些常用的可以使用管道的"过滤程序"来帮助你熟练管道的使用。

下一步
先试用一下管道,比如查看/etc目录下有哪些文件和目录,使用ls命令来查看：

$ ls -al /etc
有太多内容,屏幕不能完全显示,这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道：

$ ls -al /etc | less
通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入,然后就可以一行一行地看。

下一步
打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和其家目录：

$ cut /etc/passwd -d ':' -f 1,6
此处输入图片的描述

打印/etc/passwd文件中每一行的前N个字符：

# 前五个(包含第五个)
$ cut /etc/passwd -c -5
# 前五个之后的(包含第五个)
$ cut /etc/passwd -c 5-
# 第五个
$ cut /etc/passwd -c 5
# 2到5之间的(包含第五个)
$ cut /etc/passwd -c 2-5
下一步

grep命令是很强大的,也是相当常用的一个命令,它结合正则表达式可以实现很复杂却很高效的匹配和查找,不过在学习正则表达式之前,这里介绍它简单的使用,而关于正则表达式后面将会有单独一小节介绍到时会再继续学习grep命令和其他一些命令。

grep命令的一般形式为：

grep [命令选项]... 用于匹配的表达式 [文件]...
还是先体验一下,我们搜索/home/shiyanlou目录下所有包含"shiyanlou"的文本文件,并显示出现在文本中的行号：

$ grep -rnI "shiyanlou" ~
此处输入图片的描述

-r 参数表示递归搜索子目录中的文件,-n表示打印匹配项行号,-I表示忽略二进制文件。这个操作实际没有多大意义,但可以感受到grep命令的强大与实用。

当然也可以在匹配字段中使用正则表达式,下面简单的演示：

# 查看环境变量中以"yanlou"结尾的字符串
$ export | grep ".*yanlou$"
此处输入图片的描述

其中$就表示一行的末尾。

下一步
wc 命令用于统计并输出一个文件中行、单词和字节的数目,比如输出/etc/passwd文件的统计信息：

$ wc /etc/passwd
分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：

# 行数
$ wc -l /etc/passwd
# 单词数
$ wc -w /etc/passwd
# 字节数
$ wc -c /etc/passwd
# 字符数
$ wc -m /etc/passwd
# 最长行字节数
$ wc -L /etc/passwd
注意：对于西文字符来说,一个字符就是一个字节,但对于中文字符一个汉字是大于2个字节的,具体数目是由字符编码决定的

此处输入图片的描述

再来结合管道来操作一下,下面统计 /etc 下面所有目录数：

$ ls -dl /etc/*/ | wc -l
此处输入图片的描述

下一步
这个命令前面我们也是用过多次,功能很简单就是将输入按照一定方式排序,然后再输出,它支持的排序有按字典排序,数字排序,按月份排序,随机排序,反转排序,指定特定字段进行排序等等。

默认为字典排序：

$ cat /etc/passwd | sort
反转排序：

$ cat /etc/passwd | sort -r
按特定字段排序：

$ cat /etc/passwd | sort -t':' -k 3
上面的-t参数用于指定字段的分隔符,这里是以":"作为分隔符；-k 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字,默认情况下是以字典序排序的,如果要按照数字排序就要加上-n参数：

$ cat /etc/passwd | sort -t':' -k 3 -n
注意观察第二个冒号后的数字： 此处输入图片的描述

下一步
uniq命令可以用于过滤或者输出重复行。

过滤重复行
我们可以使用history命令查看最近执行过的命令(实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件),不过你可能只想查看使用了哪个命令而不需要知道具体干了什么,那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：

$ history | cut -c 8- | cut -d ' ' -f 1 | uniq
然后经过层层过滤,你会发现确是只输出了执行的命令那一列,不过去重效果好像不明显,仔细看你会发现它确实去重了,只是不那么明显,之所以不明显是因为uniq命令只能去连续重复的行,不是全文去重,所以要达到预期效果,我们先排序：

$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq
# 或者$ history | cut -c 8- | cut -d ' ' -f 1 | sort -u
这就是 Linux/UNIX 哲学吸引人的地方,大繁至简,一个命令只干一件事却能干到最好。

输出重复行
# 输出重复过的行(重复的只输出一个)及重复次数
$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -dc
# 输出所有重复的行
$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -D
文本处理命令还有很多,下一节将继续介绍一些常用的文本处理的命令。

轻松一下
使用以前介绍过的方法,安装aview和imagemagick,然后用asciiview命令显示图片,使用方法可以用 man 命令查看。

Linus大神的照片地址 http://labfile.oss.aliyuncs.com/courses/1/Linus.png



执行以下命令安装工具包并下载图片：

shiyanlou:~/ $ sudo apt update

shiyanlou:~/ $ sudo apt install -y aview imagemagick 

shiyanlou:~/ $ wget http://labfile.oss.aliyuncs.com/courses/1/Linus.png
执行 asciiview [图片文件名] 即可打开图片：

图片描述

下一步
熟悉 cut,sort,uniq命令以及参数

下一步

简单的文本处理
一、实验介绍
二、文本处理命令
 2.1 tr 命令
 2.2 col 命令
 2.3 join命令
 2.4 paste命令
三、实验总结
四、作业
1.1 实验内容
这一节我们将介绍这几个命令tr(注意不是tar),col,join,paste。实际这一节是上一节关于能实现管道操作的命令的延续,所以我们依然将结合管道来熟悉这些命令的使用。

1.2 实验知识点
常见文本处理命令
如何简单处理文本
下一步
1.1 实验内容
这一节我们将介绍这几个命令tr(注意不是tar),col,join,paste。实际这一节是上一节关于能实现管道操作的命令的延续,所以我们依然将结合管道来熟悉这些命令的使用。

1.2 实验知识点
常见文本处理命令
如何简单处理文本
下一步
本节讲解几个常见的文本处理命令。

下一步
tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。

使用方式：
tr [option]...SET1 [SET2]
常用的选项有：
选项	说明
-d	删除和set1匹配的字符,注意不是全词匹配也不是按字符顺序匹配
-s	去除set1指定的在输入文本中连续并重复的字符
操作举例：
# 删除 "hello shiyanlou" 中所有的'o','l','h'
$ echo 'hello shiyanlou' | tr -d 'olh'
# 将"hello" 中的ll,去重为一个l
$ echo 'hello' | tr -s 'l'
# 将输入文本,全部转换为大写或小写输出
$ echo 'input some text here' | tr '[:lower:]' '[:upper:]'
# 上面的'[:lower:]' '[:upper:]'你也可以简单的写作'[a-z]' '[A-Z]',当然反过来将大写变小写也是可以的
此处输入图片的描述

更多 tr 的使用,你可以使用--help或者man tr获得。

下一步
col 命令可以将Tab换成对等数量的空格键,或反转这个操作。

使用方式：
col [option]
常用的选项有：
选项	说明
-x	将Tab转换为空格
-h	将空格转换为Tab(默认选项)
操作举例：
# 查看 /etc/protocols 中的不可见字符,可以看到很多 ^I ,这其实就是 Tab 转义成可见字符的符号
$ cat -A /etc/protocols
# 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格,然后再使用 cat 查看,你发现 ^I 不见了
$ cat /etc/protocols | col -x | cat -A
此处输入图片的描述

下一步
学过数据库的用户对这个应该不会陌生,这个命令就是用于将两个文件中包含相同内容的那一行合并在一起。

使用方式：
join [option]... file1 file2
常用的选项有：
选项	说明
-t	指定分隔符,默认为空格
-i	忽略大小写的差异
-1	指明第一个文件要用哪个字段来对比,默认对比第一个字段
-2	指明第二个文件要用哪个字段来对比,默认对比第一个字段
操作举例：
$ cd /home/shiyanlou
# 创建两个文件
$ echo '1 hello' > file1
$ echo '1 shiyanlou' > file2
$ join file1 file2
# 将/etc/passwd与/etc/shadow两个文件合并,指定以':'作为分隔符
$ sudo join -t':' /etc/passwd /etc/shadow
# 将/etc/passwd与/etc/group两个文件合并,指定以':'作为分隔符, 分别比对第4和第3个字段
$ sudo join -t':' -1 4 /etc/passwd -2 3 /etc/group
此处输入图片的描述 此处输入图片的描述

下一步
paste这个命令与join 命令类似,它是在不对比数据的情况下,简单地将多个文件合并一起,以Tab隔开。

使用方式：
paste [option] file...
常用的选项有：
选项	说明
-d	指定合并的分隔符,默认为Tab
-s	不合并到一行,每个文件为一行
操作举例：
$ echo hello > file1
$ echo shiyanlou > file2
$ echo www.shiyanlou.com > file3
$ paste -d ':' file1 file2 file3
$ paste -s file1 file2 file3
此处输入图片的描述

下一步
上面这些命令不是所有你都会经常用到,不过它们确是很实用的,熟练掌握之后,可以减轻很多工作量,比如不停的用鼠标操作在 gedit 里面复制粘贴复制粘贴,将两个文件的内容合并为一个文件,这原本只需要一个命令就能完成。

轻松一下
还记得小时候在小霸王上面玩的小蜜蜂游戏么？它的正统名字应该是Space Invaders:太空侵略者。

使用下面这个命令可以安装,之所以叫 ninvaders 是因为这款游戏是基于 ncurses 命令行图形库做的：

$ sudo apt-get install ninvaders
$ /usr/games/ninvaders


下一步
1、在《文件打包与解压缩》一节实验中提到 Windows/dos 与 Linux/UNIX 文本文件一些特殊字符不一致

如断行符 Windows 为 CR+LF(\r\n),Linux/UNIX 为 LF(\n)。使用cat -A 文本 可以看到文本中包含的不可见特殊字符。Linux 的\n表现出来就是一个$,而 Windows/dos的表现为^M$,可以直接使用dos2unix和unix2dos工具在两种格式之间进行转换,使用file命令可以查看文件的具体类型。

不过现在希望你在不使用上述两个转换工具的情况下,使用前面学过的命令手动完成 dos 文本格式到 UNIX 文本格式的转换。

下一步


变量和参数
一、变量定义
二、使用变量
三、只读变量
四、特殊变量

四、特殊变量
1.局部变量
这种变量只有在代码块或者函数中才可见。后面的实验会详细讲解。

2.环境变量
这种变量将影响用户接口和 shell 的行为。

在通常情况下,每个进程都有自己的“环境”,这个环境是由一组变量组成的,这些变量中存有进程可能需要引用的信息。在这种情况下,shell 与一个一般的进程没什么区别。

3.位置参数
从命令行传递到脚本的参数：$0,$1,$2,$3...

$0就是脚本文件自身的名字,$1 是第一个参数,$2 是第二个参数,$3 是第三个参数,然后是第四个。$9 之后的位置参数就必须用大括号括起来了,比如,${10},${11},${12}。

$# ： 传递到脚本的参数个数
$* ： 以一个单字符串显示所有向脚本传递的参数。与位置变量不同,此选项参数可超过 9个
$$ ： 脚本运行的当前进程 ID号
$! ： 后台运行的最后一个进程的进程 ID号
$@ ： 与$*相同,但是使用时加引号,并在引号中返回每个参数
$： 显示shell使用的当前选项,与 set命令功能相同
$? ： 显示最后命令的退出状态。 0表示没有错误,其他任何值表明有错误。
4.位置参数实例
这个十分重要,在我们运行一套脚本的时候,有时候是需要参数的,这里我们教大家如何获取参数

$ vim test30.sh
输入代码（中文皆为注释,不用输入）：

#!/bin/bash

# 作为用例, 调用这个脚本至少需要10个参数, 比如:
# bash test.sh 1 2 3 4 5 6 7 8 9 10
MINPARAMS=10

echo

echo "The name of this script is \"$0\"."

echo "The name of this script is \"`basename $0`\"."


echo

if [ -n "$1" ]              # 测试变量被引用.
then
echo "Parameter #1 is $1"  # 需要引用才能够转义"#"
fi 

if [ -n "$2" ]
then
echo "Parameter #2 is $2"
fi 

if [ -n "${10}" ]  # 大于$9的参数必须用{}括起来.
then
echo "Parameter #10 is ${10}"
fi 

echo "-----------------------------------"
echo "All the command-line parameters are: "$*""

if [ $# -lt "$MINPARAMS" ]
then
 echo
 echo "This script needs at least $MINPARAMS command-line arguments!"
fi  

echo

exit 0
运行代码：

$ bash test30.sh 1 2 10


The name of this script is "test.sh".
The name of this script is "test.sh".

Parameter #1 is 1
Parameter #2 is 2
-----------------------------------
All the command-line parameters are: 1 2 10

This script needs at least 10 command-line arguments!

3.位置参数
从命令行传递到脚本的参数：$0,$1,$2,$3...

$0就是脚本文件自身的名字,$1 是第一个参数,$2 是第二个参数,$3 是第三个参数,然后是第四个。$9 之后的位置参数就必须用大括号括起来了,比如,${10},${11},${12}。

$# ： 传递到脚本的参数个数
$* ： 以一个单字符串显示所有向脚本传递的参数。与位置变量不同,此选项参数可超过 9个
$$ ： 脚本运行的当前进程 ID号
$! ： 后台运行的最后一个进程的进程 ID号
$@ ： 与$*相同,但是使用时加引号,并在引号中返回每个参数
$： 显示shell使用的当前选项,与 set命令功能相同
$? ： 显示最后命令的退出状态。 0表示没有错误,其他任何值表明有错误。


函数
一、函数定义
shell中函数的定义格式如下：

[ function ] funname [()]

{

    action;

    [return int;]

}
说明：

可以带function fun() 定义,也可以直接fun() 定义,不带任何参数。
参数返回,可以显示加：return 返回,如果不加,将以最后一条命令运行结果,作为返回值。 return后跟数值n(0-255)
下面的例子定义了一个函数并进行调用：

#!/bin/bash

demoFun(){
    echo "This is my first shell function!"
}
echo "-----Execution-----"
demoFun
echo "-----Finished-----"


Output the result：
-----Execution-----
This is my first shell function!
-----Finished-----
下面定义一个带有return语句的函数：

#!/bin/bash
funWithReturn(){
    echo "This function will add the two numbers of the input..."
    echo "Enter the first number: "
    read aNum
    echo "Enter the second number: "
    read anotherNum
    echo "The two numbers are $aNum and $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "The sum of the two numbers entered is $? !"
输出类似下面：

This function will add the two numbers of the input...
Enter the first number: 
1
Enter the second number: 
2
The two numbers are 1 and  2 !
The sum of the two numbers entered is 3 !
函数返回值在调用该函数后通过 $? 来获得
所有函数在使用前必须定义。
下一步
二、函数参数
在Shell中,调用函数时可以向其传递参数。在函数体内部,通过 $n 的形式来获取参数的值,例如,$1表示第一个参数,$2表示第二个参数... 带参数的函数示例：

#!/bin/bash
funWithParam(){
    echo "The first parameter is $1 !"
    echo "The second parameter is $2 !"
    echo "The tenth parameter is $10 !"
    echo "The tenth parameter is ${10} !"
    echo "The eleventh parameter is ${11} !"
    echo "The total number of parameters is $# !"
    echo "Outputs all parameters as a string $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
输出结果：

The first parameter is 1 !
The second parameter is 2 !
The tenth parameter is 10 !
The tenth parameter is 34 !
The eleventh parameter is 73 !
The total number of parameters is 11 !
Outputs all parameters as a string 1 2 3 4 5 6 7 8 9 34 73 !
注意

$10 不能获取第十个参数,获取第十个参数需要${10}。当n>=10时,需要使用${n}来获取参数。

下一步
三、思考
猜数字游戏：

首先让系统随机生成一个数字,给这个数字一个范围,让用户猜数字,对输入作出判断,并且给出提示。

请用while语句实现。

下一步


正则表达式基础
一、实验介绍
1.1 实验内容
虽然我们这一节的标题是正则表达式,但实际这一节实验只是介绍grep,sed,awk这三个命令,而正则表达式作为这三个命令的一种使用方式（命令输出中可以包含正则表达式）。正则表达式本身的内容很多,要把它说明清楚需要单独一门课程来实现,不过我们这一节中涉及到的相关内容通常也能够满足很多情况下的需求了。

1.2 实验知识点
掌握基本命令：sed ,grep ,awk的用法
掌握正则表达式符号和语法
想要更深入地学习使用正则表达式,在这里 正则表达式基础。

下一步

二、正则表达式
什么是正则表达式呢？

正则表达式,又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression,在代码中常简写为 regex、regexp 或 RE）,计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里,正则表达式通常被用来检索、替换那些符合某个模式的文本。

许多程序设计语言都支持利用正则表达式进行字符串操作。例如,在 Perl 中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由 UNIX 中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”,单数有 regexp、regex,复数有 regexps、regexes、regexen。

简单的说形式和功能上正则表达式和我们前面讲的通配符很像,不过它们之间又有很大差别,特别在于一些特殊的匹配字符的含义上,希望初学者注意不要将两者弄混淆。

下一步

 2.1 举例

假设我们有这样一个文本文件,包含"shiyanlou",和"shilouyan"这两个字符串,同样一个表达式：

shi*
如果这作为一个正则表达式,它将只能匹配 shi,而如果不是作为正则表达式*作为一个通配符,则将同时匹配这两个字符串。这是为什么呢？因为在正则表达式中*表示匹配前面的子表达式（这里就是它前面一个字符）零次或多次,比如它可以匹配"sh","shii","shish","shiishi"等等,而作为通配符表示匹配通配符后面任意多个任意字符,所以它可以匹配"shiyanlou",和"shilouyan"两个字符。

体验完了,下面就来开始正式学习正则表达式吧。

下一步 
 2.2 基本语法
 一个正则表达式通常被称为一个模式（pattern）,为用来描述或者匹配一系列符合某个句法规则的字符串。

选择
|竖直分隔符表示选择,例如"boy|girl"可以匹配"boy"或者"girl"

数量限定
数量限定除了我们举例用的*,还有+加号,?问号,如果在一个模式中不加数量限定符则表示出现一次且仅出现一次：

+表示前面的字符必须出现至少一次(1次或多次),例如,"goo+gle",可以匹配"gooogle","goooogle"等；
?表示前面的字符最多出现一次(0次或1次),例如,"colou?r",可以匹配"color"或者"colour";
*星号代表前面的字符可以不出现,也可以出现一次或者多次（0次、或1次、或多次）,例如,“0*42”可以匹配42、042、0042、00042等。
范围和优先级
()圆括号可以用来定义模式字符串的范围和优先级,这可以简单的理解为是否将括号内的模式串作为一个整体。例如,"gr(a|e)y"等价于"gray|grey",（这里体现了优先级,竖直分隔符用于选择a或者e而不是gra和ey）,"(grand)?father"匹配father和grandfather（这里体验了范围,?将圆括号内容作为一个整体匹配）。

语法（部分）
正则表达式有多种不同的风格,下面列举一些常用的作为 PCRE 子集的适用于perl和python编程语言及grep或egrep的正则表达式匹配规则：(由于markdown表格解析的问题,下面的竖直分隔符用全角字符代替,实际使用时请换回半角字符)

PCRE（Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库,由菲利普.海泽(Philip Hazel)编写。PCRE是一个轻量级的函数库,比Boost 之类的正则表达式库小得多。PCRE 十分易用,同时功能也很强大,性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。

字符	描述
\	将下一个字符标记为一个特殊字符、或一个原义字符。例如,“n”匹配字符“n”。“\n”匹配一个换行符。序列“\\”匹配“\”而“\(”则匹配“(”。
^	匹配输入字符串的开始位置。
$	匹配输入字符串的结束位置。
{n}	n是一个非负整数。匹配确定的n次。例如,“o{2}”不能匹配“Bob”中的“o”,但是能匹配“food”中的两个o。
{n,}	n是一个非负整数。至少匹配n次。例如,“o{2,}”不能匹配“Bob”中的“o”,但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。
{n,m}	m和n均为非负整数,其中n<=m。最少匹配n次且最多匹配m次。例如,“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。
*	匹配前面的子表达式零次或多次。例如,zo*能匹配“z”、“zo”以及“zoo”。*等价于{0,}。
+	匹配前面的子表达式一次或多次。例如,“zo+”能匹配“zo”以及“zoo”,但不能匹配“z”。+等价于{1,}。
?	匹配前面的子表达式零次或一次。例如,“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。
?	当该字符紧跟在任何一个其他限制符（*,+,?,{n},{n,},{n,m}）后面时,匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串,而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如,对于字符串“oooo”,“o+?”将匹配单个“o”,而“o+”将匹配所有“o”。
.	匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符,请使用像“(.｜\n)”的模式。
(pattern)	匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。要匹配圆括号字符,请使用“\(”或“\)”。
x｜y	匹配x或y。例如,“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”。
[xyz]	字符集合（character class）。匹配所包含的任意一个字符。例如,“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线\保持特殊含义,用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符。
[^xyz]	排除型（negate）字符集合。匹配未列出的任意字符。例如,“[^abc]”可以匹配“plain”中的“plin”。
[a-z]	字符范围。匹配指定范围内的任意字符。例如,“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。
[^a-z]	排除型的字符范围。匹配任何不在指定范围内的任意字符。例如,“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。
优先级
优先级为从上到下从左到右,依次降低：

运算符	说明
\	转义符
(), (?:), (?=), []	括号和中括号
*、+、?、{n}、{n,}、{n,m}	限定符
^、$、\任何元字符	定位点和序列
｜	选择
更多正则表达式的内容可以参考以下链接：

正则表达式wiki
几种正则表达式引擎的语法差异
各语言各平台对正则表达式的支持
regex的思导图：
下一步
三、grep模式匹配命令
上面空谈了那么多正则表达式的内容也并没有提及具体该如何使用它,实在枯燥,如果说正则表达式是一门武功,那它也只能算得上一些口诀招式罢了,要把它真正练起来还得需要一些兵器在手才行,这里我们要介绍的grep命令以及后面要讲的sed,awk这些就该算作是这样的兵器了。

下一步

 3.1 基本操作
 grep命令用于打印输出文本中匹配的模式串,它使用正则表达式作为模式匹配的条件。grep支持三种正则表达式引擎,分别用三个参数指定：

参数	说明
-E	POSIX扩展正则表达式,ERE
-G	POSIX基本正则表达式,BRE
-P	Perl正则表达式,PCRE
不过在你没学过perl语言的大多数情况下你将只会使用到ERE和BRE,所以我们接下来的内容都不会讨论到PCRE中特有的一些正则表达式语法（它们之间大部分内容是存在交集的,所以你不用担心会遗漏多少重要内容）

在通过grep命令使用正则表达式之前,先介绍一下它的常用参数：

参数	说明
-b	将二进制文件作为文本来进行匹配
-c	统计以模式匹配的数目
-i	忽略大小写
-n	显示匹配文本所在行的行号
-v	反选,输出不匹配行的内容
-r	递归匹配查找
-A n	n为正整数,表示after的意思,除了列出匹配行之外,还列出后面的n行
-B n	n为正整数,表示before的意思,除了列出匹配行之外,还列出前面的n行
--color=auto	将输出中的匹配项设置为自动颜色显示
注：在大多数发行版中是默认设置了grep的颜色的,你可以通过参数指定或修改GREP_COLOR环境变量。

此处输入图片的描述

下一步
 
 3.2 使用正则表达式
使用基本正则表达式,BRE
位置
查找/etc/group文件中以"shiyanlou"为开头的行

$ grep 'shiyanlou' /etc/group
$ grep '^shiyanlou' /etc/group
此处输入图片的描述

数量
# 将匹配以'z'开头以'o'结尾的所有字符串
$ echo 'zero\nzo\nzoo' | grep 'z.*o'
# 将匹配以'z'开头以'o'结尾,中间包含一个任意字符的字符串
$ echo 'zero\nzo\nzoo' | grep 'z.o'
# 将匹配以'z'开头,以任意多个'o'结尾的字符串
$ echo 'zero\nzo\nzoo' | grep 'zo*'
注意：其中\n为换行符

此处输入图片的描述

选择
# grep默认是区分大小写的,这里将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[a-z]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[0-9]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[[:digit:]]'
# 将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[[:lower:]]'
# 将匹配所有的大写字母
$ echo '1234\nabcd' | grep '[[:upper:]]'
# 将匹配所有的字母和数字,包括0-9,a-z,A-Z
$ echo '1234\nabcd' | grep '[[:alnum:]]'
# 将匹配所有的字母
$ echo '1234\nabcd' | grep '[[:alpha:]]'
此处输入图片的描述

下面包含完整的特殊符号及说明：

特殊符号	说明
[:alnum:]	代表英文大小写字母及数字,亦即 0-9, A-Z, a-z
[:alpha:]	代表任何英文大小写字母,亦即 A-Z, a-z
[:blank:]	代表空白键与 [Tab] 按键两者
[:cntrl:]	代表键盘上面的控制按键,亦即包括 CR, LF, Tab, Del.. 等等
[:digit:]	代表数字而已,亦即 0-9
[:graph:]	除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键
[:lower:]	代表小写字母,亦即 a-z
[:print:]	代表任何可以被列印出来的字符
[:punct:]	代表标点符号 (punctuation symbol),亦即：" ' ? ! ; : # $...
[:upper:]	代表大写字母,亦即 A-Z
[:space:]	任何会产生空白的字符,包括空白键, [Tab], CR 等等
[:xdigit:]	代表 16 进位的数字类型,因此包括： 0-9, A-F, a-f 的数字与字节
注意：之所以要使用特殊符号,是因为上面的[a-z]不是在所有情况下都管用,这还与主机当前的语系有关,即设置在LANG环境变量的值,zh_CN.UTF-8的话[a-z],即为所有小写字母,其它语系可能是大小写交替的如,"a A b B...z Z",[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响,使用[:lower:]则不会有这个问题。

# 排除字符
$ $ echo 'geek\ngood' | grep '[^o]'
注意:当^放到中括号内为排除字符,否则表示行首。

此处输入图片的描述

使用扩展正则表达式,ERE
要通过grep使用扩展正则表达式需要加上-E参数,或使用egrep。

数量
# 只匹配"zo"
$ echo 'zero\nzo\nzoo' | grep -E 'zo{1}'
# 匹配以"zo"开头的所有单词
$ echo 'zero\nzo\nzoo' | grep -E 'zo{1,}'
注意：推荐掌握{n,m}即可,+,?,*,这几个不太直观,且容易弄混淆。

选择
# 匹配"www.shiyanlou.com"和"www.google.com"
$ echo 'www.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -E 'www\.(shiyanlou|google)\.com'
# 或者匹配不包含"baidu"的内容
$ echo 'www.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -Ev 'www\.baidu\.com'
注意：因为.号有特殊含义,所以需要转义。

此处输入图片的描述

关于正则表达式和grep命令的内容就介绍这么多,下面会介绍两个更强大的工具sed和awk,但同样也正是因为这两个工具的强大,我们的内容无法包含它们的全部,这里将只对基本内容作介绍。

下一步
四、sed 流编辑器
sed工具在 man 手册里面的全名为"sed - stream editor for filtering and transforming text ",意即,用于过滤和转换文本的流编辑器。

在 Linux/UNIX 的世界里敢称为编辑器的工具,大都非等闲之辈,比如前面的"vi/vim(编辑器之神)","emacs(神的编辑器)","gedit"这些个编辑器。sed与上述的最大不同之处在于它是一个非交互式的编辑器,下面我们就开始介绍sed这个编辑器。

下一步
 4.1 sed常用参数介绍
sed 命令基本格式：

sed [参数]... [执行命令] [输入文件]...
# 形如：
$ sed -i 's/sad/happy/' test # 表示将test文件中的"sad"替换为"happy"
参数	说明
-n	安静模式,只打印受影响的行,默认打印输入数据的全部内容
-e	用于在脚本中添加多个执行命令一次执行,在命令行中执行多个命令通常不需要加该参数
-f filename	指定执行filename文件中的命令
-r	使用扩展正则表达式,默认为标准正则表达式
-i	将直接修改输入文件内容,而不是打印到标准输出设备
下一步 
 4.2 sed编辑器的执行命令（这里”执行“解释为名词）
 sed执行命令格式：

[n1][,n2]command
[n1][~step]command
# 其中一些命令可以在后面加上作用范围,形如：
$ sed -i 's/sad/happy/g' test # g表示全局范围
$ sed -i 's/sad/happy/4' test # 4表示指定行中的第四个匹配字符串
其中n1,n2表示输入内容的行号,它们之间为,逗号则表示从n1到n2行,如果为～波浪号则表示从n1开始以step为步进的所有行；command为执行动作,下面为一些常用动作指令：

命令	说明
s	行内替换
c	整行替换
a	插入到指定行的后面
i	插入到指定行的前面
p	打印指定行,通常与-n参数配合使用
d	删除指定行
下一步

 4.3 sed操作举例
我们先找一个用于练习的文本文件：

$ cp /etc/passwd ~
打印指定行
# 打印2-5行
$ nl passwd | sed -n '2,5p'
# 打印奇数行
$ nl passwd | sed -n '1~2p'
此处输入图片的描述

行内替换
# 将输入文本中"shiyanlou" 全局替换为"hehe",并只打印替换的那一行,注意这里不能省略最后的"p"命令
$ sed -n 's/shiyanlou/hehe/gp' passwd
注意： 行内替换可以结合正则表达式使用。

行间替换
$ nl passwd | grep "shiyanlou"
# 删除第21行
$ sed -n '21c\www.shiyanlou.com' passwd
（这里我们只把要删的行打印出来了,并没有真正的删除,如果要删除的话,请使用-i参数）
此处输入图片的描述

关于sed命令就介绍这么多,你如果希望了解更多sed的高级用法,你可以参看如下链接：

sed简明教程
sed单行脚本快速参考
sed完全手册
下一步
 
五、awk文本处理语言
看到上面的标题,你可能会感到惊异,难道我们这里要学习的是一门“语言”么,确切的说,我们是要在这里学习awk文本处理语言,只是我们并不会在这里学习到比较完整的关于awk的内容,还是因为前面的原因,它太强大了,它的应用无处不在,我们无法在这里以简短的文字描述面面俱到,如果你有目标成为一个linux系统管理员,确实想学好awk,你一不用担心,实验楼会在之后陆续上线linux系统管理员的学习路径,里面会有单独的关于正则表达式,awk,sed等相关课程,敬请期待吧。下面的内容,我们就作为一个关于awk的入门体验章节吧,其中会介绍一些awk的常用操作。

下一步

 5.1 awk介绍
 AWK是一种优良的文本处理工具,Linux及Unix环境中现有的功能最强大的数据处理引擎之一.其名称得自于它的创始人Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和Brian Wilson Kernighan（布莱恩·柯林汉)姓氏的首个字母.AWK程序设计语言,三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序,这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表,还有无数其他的功能。最简单地说,AWK是一种用于处理文本的编程语言工具。

在大多数linux发行版上面,实际我们使用的是gawk（GNU awk,awk的GNU版本）,在我们的环境中ubuntu上,默认提供的是mawk,不过我们通常可以直接使用awk命令（awk语言的解释器）,因为系统已经为我们创建好了awk指向mawk的符号链接。

$ ll /usr/bin/awk
ubuntu2018@linux:~$ whereis awk
awk: /usr/bin/awk /usr/share/man/man1/awk.1.gz
ubuntu2018@linux:~$ ll /usr/bin/awk
lrwxrwxrwx 1 root root 21 12月 14 20:03 /usr/bin/awk -> /etc/alternatives/awk*
ubuntu2018@linux:~$ ll /usr/bin/mawk
-rwxr-xr-x 1 root root 125416 4月   3  2018 /usr/bin/mawk*

此处输入图片的描述

nawk： 在 20 世纪 80 年代中期,对 awk语言进行了更新,并不同程度地使用一种称为 nawk(new awk) 的增强版本对其进行了替换。许多系统中仍然存在着旧的awk 解释器,但通常将其安装为 oawk (old awk) 命令,而 nawk 解释器则安装为主要的 awk 命令,也可以使用 nawk 命令。Dr. Kernighan 仍然在对 nawk 进行维护,与 gawk 一样,它也是开放源代码的,并且可以免费获得; gawk： 是 GNU Project 的awk解释器的开放源代码实现。尽管早期的 GAWK 发行版是旧的 AWK 的替代程序,但不断地对其进行了更新,以包含 NAWK 的特性; mawk 也是awk编程语言的一种解释器,mawk遵循 POSIX 1003.2 （草案 11.3）定义的 AWK 语言,包含了一些没有在AWK 手册中提到的特色,同时 mawk 提供一小部分扩展,另外据说mawk是实现最快的awk

下一步

 5.2 awk的一些基础概念
 awk所有的操作都是基于pattern(模式)—action(动作)对来完成的,如下面的形式：

$ pattern {action}
你可以看到就如同很多编程语言一样,它将所有的动作操作用一对{}花括号包围起来。其中pattern通常是表示用于匹配输入的文本的“关系式”或“正则表达式”,action则是表示匹配后将执行的动作。在一个完整awk操作中,这两者可以只有其中一个,如果没有pattern则默认匹配输入的全部文本,如果没有action则默认为打印匹配内容到屏幕。

awk处理文本的方式,是将文本分割成一些“字段”,然后再对这些字段进行处理,默认情况下,awk以空格作为一个字段的分割符,不过这不是固定的,你可以任意指定分隔符,下面将告诉你如何做到这一点。

下一步

 5.3 awk命令基本格式
 awk [-F fs] [-v var=value] [-f prog-file | 'program text'] [file...]
其中-F参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ,-v用于预先为awk程序指定变量,-f参数用于指定awk命令要执行的程序文件,或者在不加-f参数的情况下直接将程序语句放在这里,最后为awk需要处理的文本输入,且可以同时输入多个文本文件。现在我们还是直接来具体体验一下吧。

下一步

 5.4 awk操作体验
 先用vim新建一个文本文档

$ vim test
包含如下内容：

I like linux
www.shiyanlou.com
使用awk将文本内容打印到终端
# "quote>" 不用输入
$ awk '{
> print
> }' test
# 或者写到一行
$ awk '{print}' test
此处输入图片的描述

说明:在这个操作中我是省略了pattern,所以awk会默认匹配输入文本的全部内容,然后在"{}"花括号中执行动作,即print打印所有匹配项,这里是全部文本内容

将test的第一行的每个字段单独显示为一行
$ awk '{
> if(NR==1){
> print $1 "\n" $2 "\n" $3
> } else {
> print}
> }' test

# 或者
$ awk '{
> if(NR==1){
> OFS="\n"
> print $1, $2, $3
> } else {
> print}
> }' test
此处输入图片的描述

说明:你首先应该注意的是,这里我使用了awk语言的分支选择语句if,它的使用和很多高级语言如C/C++语言基本一致,如果你有这些语言的基础,这里将很好理解。另一个你需要注意的是NR与OFS,这两个是awk内建的变量,NR表示当前读入的记录数,你可以简单的理解为当前处理的行数,OFS表示输出时的字段分隔符,默认为" "空格,如上图所见,我们将字段分隔符设置为\n换行符,所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是$N其中N为相应的字段号,这也是awk的内建变量,它表示引用相应的字段,因为我们这里第一行只有三个字段,所以只引用到了$3。除此之外另一个这里没有出现的$0,它表示引用当前记录（当前行）的全部内容。

将test的第二行的以点为分段的字段换成以空格为分隔
$ awk -F'.' '{
> if(NR==2){
> print $1 "\t" $2 "\t" $3
> }}' test

# 或者
$ awk '
> BEGIN{
> FS="."
> OFS="\t"  # 如果写为一行,两个动作语句之间应该以";"号分开  
> }{
> if(NR==2){
> print $1, $2, $3
> }}' test
此处输入图片的描述

说明：这里的-F参数,前面已经介绍过,它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定OFS我们还可以在print 语句中直接打印特殊符号如这里的\t,print打印的非变量内容都需要用""一对引号包围起来。上面另一个版本,展示了实现预先指定变量分隔符的另一种方式,即使用BEGIN,就这个表达式指示了,其后的动作将在所有动作之前执行,这里是FS赋值了新的"."点号代替默认的" "空格

注意:首先说明一点,我们在学习和使用awk的时候应该尽可能将其作为一门程序语言来理解,这样将会使你学习起来更容易,所以初学阶段在练习awk时应该尽量按照我那样的方式分多行按照一般程序语言的换行和缩进来输入,而不是全部写到一行（当然这在你熟练了之后是没有任何问题的）。

下一步
 5.5 awk常用的内置变量

变量名	说明
FILENAME	当前输入文件名,若有多个文件,则只表示第一个。如果输入是来自标准输入,则为空字符串
$0	当前记录的内容
$N	N表示字段号,最大值为NF变量的值
FS	字段分隔符,由正则表达式表示,默认为" "空格
RS	输入记录分隔符,默认为"\n",即一行为一个记录
NF	当前记录字段数
NR	已经读入的记录数
FNR	当前输入文件的记录数,请注意它与NR的区别
OFS	输出字段分隔符,默认为" "空格
ORS	输出记录分隔符,默认为"\n"
关于awk的内容本课程将只会包含这些内容,如果你想了解更多,请期待后续课程,或者参看一下链接内容：

awk程序设计语言
awk简明教程
awk用户指南
下一步

六、作业
1、练习其他几个命令动作的使用。

练习1: 结合正则表达式做更多练习。

练习2: 参考下面的链接,掌握 sed 处理文本的基本原理,理解 pattern space 和 hold space 概念。 sed简明教程 sed单行脚本快速参考 sed完全手册

练习3: 基于 pattern space 和 hold space 实现将一个文本倒序输出和交换奇数行和偶数行。

2、一个在线游戏,当然我们主要目的是学习,这个游戏也是有寓教于乐的性质,让你快速学会vim的基础操作：

vim大冒险

挑战：数据提取
介绍
小明在做数据分析的时候需要提取文件中关于数字的部分,同时还要提取用户的邮箱部分,但是有的行不是数组也不是邮箱,现在需要你在 data2 这个文件中帮助他用正则表达式匹配出数字部分和邮箱部分。

数据文件可以使用以下命令下载：

$ cd /home/shiyanlou
$ wget http://labfile.oss.aliyuncs.com/courses/1/data2
下载后的数据文件路径为 /home/shiyanlou/data2。

目标
在文件 /home/shiyanlou/data2 中匹配数字开头的行,将所有以数字开头的行都写入 /home/shiyanlou/num 文件。
在文件 /home/shiyanlou/data2 中匹配出正确格式的邮箱,将所有的邮箱写入 /home/shiyanlou/mail 文件,注意该文件中每行为一个邮箱。
提示
邮箱的格式匹配
注意符号 . 的处理
来源
2016 年 TapFun 校招面试题

参考答案
注意：请务必自己独立思考解决问题之后再对照参考答案,一开始直接看参考答案收获不大。

$ grep '^[0-9]' /home/shiyanlou/data2 > /home/shiyanlou/num


$ grep -E '^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$' /home/shiyanlou/data2 > /home/shiyanlou/mail
有BUG,单简便$ grep '^[0-9].*@.*' data2 > mail



下一步
Linux下软件安装
一、实验介绍
1.1 实验内容
介绍 Ubuntu 下软件安装的几种方式,及 apt,dpkg 工具的使用。

1.2 实验知识点
通常 Linux 上的软件安装主要有四种方式：

在线安装
从磁盘安装deb软件包
从二进制软件包安装
从源代码编译安装
这几种安装方式各有优劣,而大多数软件包会采用多种方式发布软件,所以我们常常需要全部掌握这几种软件安装方式,以便适应各种环境。下面将介绍前三种安装方式,从源码编译安装你将在 Linux 程序设计中学习到。


二、开始
试想一下,平时我们在使用 Windows 的时候,想要安装一个软件,我们需要在网上去下载对应软件的安装包,接着安装的时候就是不断的去点击下一步,这些流程想必大家已经经历无数回了,但是在 Linux 下,一个命令加回车,等待一下,软件就安装好了,这就是方便的在线安装软件的方式。在学习这种安装方式之前有一点需要说明的是,在不同的linux发行版上面在线安装方式会有一些差异包括使用的命令及它们的包管理工具,因为我们的开发环境是基于ubuntu的,所以这里我们涉及的在线安装方式将只适用于ubuntu发行版,或其它基于ubuntu的发行版如国内的ubuntukylin(优麒麟),ubuntu又是基于debian的发行版,它使用的是debian的包管理工具dpkg,所以一些操作也适用与debian。而在一些采用其它包管理工具的发行版如redhat,centos,fedora等将不适用(redhat和centos使用rpm)。

提醒：非会员用户不能链接外网,若在线安装的软件需从外网下载资源将无法成功安装。

下一步
 2.1 先体验一下
 比如我们想安装一个软件,名字叫做 w3m(w3m是一个命令行的简易网页浏览器),那么输入如下命令：

$ sudo apt-get install w3m
这样的操作你应该在前面的章节中看到过很多次了,它就表示将会安装一个软件包名为w3m的软件

我们来看看命令执行后的效果：

此处输入图片的描述

$ w3m www.shiyanlou.com/faq
注意:如果你在安装一个软件之后,无法立即使用Tab键补全这个命令,你可以尝试先执行source ~/.zshrc,然后你就可以使用补全操作。

此处输入图片的描述

下一步

 2.2 apt 包管理工具介绍
 APT是Advance Packaging Tool（高级包装工具）的缩写,是Debian及其派生发行版的软件包管理器,APT可以自动下载,配置,安装二进制或者源代码格式的软件包,因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端,用来处理deb格式的软件包。现在经过APT-RPM组织修改,APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 apt- 开头的多个工具,如 apt-get apt-cache apt-cdrom 等,在Debian系列的发行版中使用。

当你在执行安装操作时,首先apt-get 工具会在本地的一个数据库中搜索关于 w3m 软件的相关信息,并根据这些信息在相关的服务器上下载软件安装,这里大家可能会一个疑问：既然是在线安装软件,为啥会在本地的数据库中搜索？要解释这个问题就得提到几个名词了：

软件源镜像服务器
软件源
我们需要定期从服务器上下载一个软件包列表,使用 sudo apt-get update 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作,比如更换了软件源）,而这个表里会有软件依赖信息的记录,对于软件依赖,我举个例子：我们安装 w3m 软件的时候,而这个软件需要 libgc1c2 这个软件包才能正常工作,这个时候 apt-get 在安装软件的时候会一并替我们安装了,以保证 w3m 能正常的工作。

下一步

 2.3 apt-get
 apt-get 是用于处理 apt包的公用程序集,我们可以用它来在线安装、卸载和升级软件包等,下面列出一些apt-get包含的常用的一些工具：

工具	说明
install	其后加上软件包名,用于安装一个软件包
update	从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表
upgrade	升级本地可更新的全部软件包,但存在依赖问题时将不会升级,通常会在更新之前执行一次update
dist-upgrade	解决依赖关系并升级(存在一定危险性)
remove	移除已安装的软件包,包括与被移除软件包有依赖关系的软件包,但不包含软件包的配置文件
autoremove	移除之前被其他软件包依赖,但现在不再被使用的软件包
purge	与remove相同,但会完全移除软件包,包含其配置文件
clean	移除下载到本地的已经安装的软件包,默认保存在/var/cache/apt/archives/
autoclean	移除已安装的软件的旧版本软件包
下面是一些apt-get常用的参数：

参数	说明
-y	自动回应是否安装软件包的选项,在一些自动化安装脚本中使用这个参数将十分有用
-s	模拟安装
-q	静默安装方式,指定多个q或者-q=#,#表示数字,用于设定静默级别,这在你不想要在安装软件包时屏幕输出过多时很有用
-f	修复损坏的依赖关系
-d	只下载不安装
--reinstall	重新安装已经安装但可能存在问题的软件包
--install-suggests	同时安装APT给出的建议安装的软件包
下一步

 2.4 安装软件包
 关于安装,如前面演示的一样你只需要执行apt-get install <软件包名>即可,除了这一点,你还应该掌握的是如何重新安装软件包。 很多时候我们需要重新安装一个软件包,比如你的系统被破坏,或者一些错误的配置导致软件无法正常工作。

你可以使用如下方式重新安装：

$ sudo apt-get --reinstall install w3m
另一个你需要掌握的是,如何在不知道软件包完整名的时候进行安装。通常我们是使用Tab键补全软件包名,后面会介绍更好的方法来搜索软件包。有时候你需要同时安装多个软件包,你还可以使用正则表达式匹配软件包名进行批量安装。

下一步

 2.5 软件升级
 # 更新软件源
$ sudo apt-get update
# 升级没有依赖问题的软件包
$ sudo apt-get upgrade
# 升级并解决依赖关系
$ sudo apt-get dist-upgrade
下一步
 2.6 卸载软件
 如果你现在觉得 w3m 这个软件不合自己的胃口,或者是找到了更好的,你需要卸载它,那么简单！同样是一个命令加回车 sudo apt-get remove w3m ,系统会有一个确认的操作,之后这个软件便“滚蛋了”。

此处输入图片的描述

或者,你可以执行

# 不保留配置文件的移除
$ sudo apt-get purge w3m
# 或者 sudo apt-get --purge remove
# 移除不再需要的被依赖的软件包
$ sudo apt-get autoremove
下一步

 2.7 软件搜索
 当自己刚知道了一个软件,想下载使用,需要确认软件仓库里面有没有,就需要用到搜索功能了,命令如下：

sudo apt-cache search softname1 softname2 softname3……
apt-cache 命令则是针对本地数据进行相关操作的工具,search 顾名思义在本地的数据库中寻找有关 softname1 softname2 …… 相关软件的信息。现在我们试试搜索一下之前我们安装的软件 w3m ,如图：

此处输入图片的描述

结果显示了4个 w3m 相关的软件,并且有相关软件的简介。

关于在线安装的的内容我们就介绍这么多,想了解更多关于APT的内容,你可以参考：

APT HowTo
下一步

三、使用 dpkg
本节讲解如何使用 dpkg 从本地磁盘安装 deb 软件包。

下一步
 3.1 dpkg 介绍
 dpkg 是 Debian 软件包管理器的基础,它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似,同样被用于安装、卸载和供给和 .deb 软件包相关的信息。

dpkg 本身是一个底层的工具。上层的工具,像是 APT,被用于从远程获取软件包以及处理复杂的软件包关系。"dpkg"是"Debian Package"的简写。

我们经常可以在网络上见到以deb形式打包的软件包,就需要使用dpkg命令来安装。

dpkg常用参数介绍：

参数	说明
-i	安装指定deb包
-R	后面加上目录名,用于安装该目录下的所有deb安装包
-r	remove,移除某个已安装的软件包
-I	显示deb包文件的信息
-s	显示已安装软件的信息
-S	搜索已安装的软件包
-L	显示已安装软件包的目录信息
下一步
 3.2 使用dpkg安装deb软件包
 我们先使用apt-get加上-d参数只下载不安装,下载emacs编辑器的deb包,下载完成后,我们可以查看/var/cache/apt/archives/目录下的内容,如下图：

此处输入图片的描述

然后我们将第一个deb拷贝到 /home/shiyanlou 目录下,并使用dpkg安装

$ cp /var/cache/apt/archives/emacs24_24.5+1-6ubuntu1.1_amd64.deb ~
# 安装之前参看deb包的信息
$ sudo dpkg -I emacs24_24.5+1-6ubuntu1.1_amd64.deb
如你所见,这个包还额外依赖了一些软件包,这意味着,如果主机目前没有这些被依赖的软件包,直接使用dpkg安装可能会存在一些问题,因为dpkg并不能为你解决依赖关系。

# 使用dpkg安装
$ sudo dpkg -i emacs24_24.5+1-6ubuntu1.1_amd64.deb
跟前面预料的一样,这里你可能出现了一些错误：

此处输入图片的描述

我们将如何解决这个错误呢？这就要用到apt-get了,使用它的-f参数了,修复依赖关系的安装

$ sudo apt-get update
$ sudo apt-get -f install
没有任何错误,这样我们就安装成功了,然后你可以运行emacs程序

此处输入图片的描述

下一步

 3.3 查看已安装软件包的安装目录
 如果你依然在纠结到底linux将软件安装到了什么地方,那么很幸运你将可以通过dpkg找到答案

使用dpkg -L查看deb包目录信息

$ sudo dpkg -L emacs24
此处输入图片的描述

dpkg还有一些其他的参数,这里将作为练习题由你自己来学习

下一步

四、从二进制包安装
二进制包的安装比较简单,我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录,然后将包含可执行的主程序文件的目录添加进PATH环境变量即可,如果你不知道该放到什么位置,请重新复习第四节关于 Linux 目录结构的内容。

下一步
作业
这一节是本课程的最后一节,所以这里我们给大家介绍一个很有趣的命令。

安装：

$ sudo apt-get update
$ sudo apt-get install bb
$ /usr/games/bb
下一步

Linux 进程概念
1.1 实验内容
Linux 中也难免遇到某个程序无响应的情况,可以通过一些命令来帮助我们让系统能够更流畅的运行。 而在此之前,我们需要对进程的基础知识有一定的了解,才能更好、更有效率的使用Linux 提供的工具。

1.2实验知识点
进程与程序
进程的衍生
工作管理
下一步

二、概念的理解
首先程序与进程是什么？程序与进程又有什么区别？

程序（procedure）：不太精确地说,程序就是执行一系列有逻辑、有顺序结构的指令,帮我们达成某个结果。就如我们去餐馆,给服务员说我要牛肉盖浇饭,她执行了做牛肉盖浇饭这么一个程序,最后我们得到了这么一盘牛肉盖浇饭。它需要去执行,不然它就像一本武功秘籍,放在那里等人翻看。

进程（process）：进程是程序在一个数据集合上的一次执行过程,在早期的UNIX、Linux 2.4及更早的版本中,它是系统进行资源分配和调度的独立基本单位。同上一个例子,就如我们去了餐馆,给服务员说我要牛肉盖浇饭,她执行了做牛肉盖浇饭这么一个程序,而里面做饭的是一个进程,做牛肉汤汁的是一个进程,把牛肉汤汁与饭混合在一起的是一个进程,把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程,然后一个篇章一个篇章地去练。

简单来说,程序是为了完成某种任务而设计的软件,比如 vim 是程序。什么是进程呢？进程就是运行中的程序。

程序只是一些列指令的集合,是一个静止的实体,而进程不同,进程有以下的特性：

动态性：进程的实质是一次程序执行的过程,有创建、撤销等状态的变化。而程序是一个静态的实体。
并发性：进程可以做到在一个时间段内,有多个程序在运行中。程序只是静态的实体,所以不存在并发性。
独立性：进程可以独立分配资源,独立接受调度,独立地运行。
异步性：进程以不可预知的速度向前推进。
结构性：进程拥有代码段、数据段、PCB（进程控制块,进程存在的唯一标志）。也正是因为有结构性,进程才可以做到独立地运行。
并发：在一个时间段内,宏观来看有多个程序都在活动,有条不紊的执行（每一瞬间只有一个在执行,只是在一段时间有多个程序都执行过）

并行：在每一个瞬间,都有多个程序都在同时执行,这个必须有多个 CPU 才行

引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司,只是一些证书,文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分,财务部,技术部,销售部等等,就像各个进程,各个部门之间可以独立运做,也可以有交互（独立性、并发性）。

而随着程序的发展越做越大,又会继续细分,从而引入了线程的概念,当代多数操作系统、Linux 2.6及更新的版本中,进程本身不是基本运行单位,而是线程的容器。就像上述所说的,每个部门又会细分为各个工作小组（线程）,而工作小组需要的资源需要向上级（进程）申请。

线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中,是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流,一个进程中可以并发多个线程,每条线程并行执行不同的任务。因为线程中几乎不包含系统资源,所以执行更快、更有效率。

简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程,使得多线程程序的并发性高。另外,进程在执行过程中拥有独立的内存单元,而多个线程共享内存,从而极大地提高了程序的运行效率。就如下图所示：

实验楼

下一步

三、进程的属性
了解基础概念后,下面我们将详细的讲解进程的属性。

下一步
 3.1 进程的分类
 大概明白进程是个什么样的存在后,我们需要进一步了解的就是进程分类。可以从两个角度来分：

以进程的功能与服务的对象来分；
以应用程序的服务类型来分；
第一个角度来看,我们可以分为用户进程与系统进程：

用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程,此类进程可以在用户的控制下运行或关闭。
系统进程：通过执行系统内核程序而产生的进程,比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预,即使是 root 用户也不能干预系统进程的运行。
第二角度来看,我们可以将进程分为交互进程、批处理进程、守护进程

交互进程：由一个 shell 终端启动的进程,在执行过程中,需要与用户进行交互操作,可以运行于前台,也可以运行在后台。
批处理进程：该进程是一个进程集合,负责按顺序启动其他的进程。
守护进程：守护进程是一直运行的一种进程,在 Linux 系统启动时启动,在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程,一直处于运行状态,等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程,这个进程为 crontab 的守护进程,可以周期性的执行用户设定的某些任务。
下一步

 3.2 进程的衍生
 进程有这么多的种类,那么进程之间定是有相关性的,而这些有关联性的进程又是如何产生的,如何衍生的？

就比如我们启动了终端,就是启动了一个 bash 进程,我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程,此时第二个 bash 进程就是由第一个 bash 进程创建出来的,他们之间又是个什么关系？

我们一般称呼第一个 bash 进程是第二 bash 进程的父进程,第二 bash 进程是第一个 bash 进程的子进程,这层关系是如何得来的呢？

关于父进程与子进程便会提及这两个系统调用 fork() 与 exec()

fork-exec是由 Dennis M. Ritchie 创造的

fork() 是一个系统调用（system call）,它的主要作用就是为当前的进程创建一个新的进程,这个新的进程就是它的子进程,这个子进程除了父进程的返回值和 PID 以外其他的都一模一样,如进程的执行代码段,内存信息,文件描述,寄存器状态等等

exec() 也是系统调用,作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段

子进程就是父进程通过系统调用 fork() 而产生的复制品,fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来,只是修改了 PID,所以一模一样,只有在执行 exec() 之后才会不同,而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少,感兴趣的同学可以查查为什么。

这就是子进程产生的由来。简单的实现逻辑就如下方所示【注释１】

pid_t p;

p = fork();
if (p == (pid_t) -1)
        /* ERROR */
else if (p == 0)
        /* CHILD */
else
        /* PARENT */
既然子进程是通过父进程而衍生出来的,那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时,或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n,这里的返回值 n 是一个信号,系统会把这个 SIGCHLD 信号传给其父进程,当然若是异常终止也往往是因为这个信号。

在将要结束时的子进程代码执行部分已经结束执行了,系统的资源也基本归还给系统了,但若是其进程的进程控制块（PCB）仍驻留在内存中,而它的 PCB 还在,代表这个进程还存在（因为 PCB 就是进程存在的唯一标志,里面有 PID 等消息）,并没有消亡,这样的进程称之为僵尸进程（Zombie）。

如图中第四列标题是 S,S 表示的是进程的状态,而在下属的第三行的 Z 表示的是 Zombie 的意思。（ ps 命令将在后续详解）

实验楼

正常情况下,父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后,父进程会使用 wait(&status) 系统调用以获取子进程的退出状态,然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话,子进程的 PCB 就会一直驻留在内存中,一直留在系统中成为僵尸进程（Zombie）。

虽然僵尸进程是已经放弃了几乎所有内存空间,没有任何可执行代码,也不能被调度,在进程列表中保留一个位置,记载该进程的退出状态等信息供其父进程收集,从而释放它。但是 Linux 系统中能使用的 PID 是有限的,如果系统中存在有大量的僵尸进程,系统将会因为没有可用的 PID 从而导致不能产生新的进程。

另外如果父进程结束（非正常的结束）,未能及时收回子进程,子进程仍在运行,这样的子进程称之为孤儿进程。在 Linux 系统中,孤儿进程一般会被 init 进程所“收养”,成为 init 的子进程。由 init 来做善后处理,所以它并不至于像僵尸进程那样无人问津,不管不顾,大量存在会有危害。

进程 0 是系统引导时创建的一个特殊进程,也称之为内核初始化,其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID=1 的进程 1,而进程 0 就转为交换进程（也被称为空闲进程）,进程 1 （init 进程）是第一个用户态的进程,再由它不断调用 fork() 来创建系统里其他的进程,所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序,直到计算机关机才会停止。

通过以下的命令我们可以很明显的看到这样的结构

pstree
实验楼

或者从此图我们可以更加形象的看清子父进程的关系

实验楼

通过以上的显示结果我们可以看的很清楚,init 为所有进程的父进程或者说是祖先进程

我们还可以使用这样一个命令来看,其中 pid 就是该进程的一个唯一编号,ppid 就是该进程的父进程的 pid,command 表示的是该进程通过执行什么样的命令或者脚本而产生的

ps －fxo user,ppid,pid,pgid,command
实验楼

可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的

使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程,而其他的进程基本是由 init 创建的子进程,或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解）

就像一个树状图,而 init 进程就是这棵树的根,其他进程由根不断的发散,开枝散叶

下一步

 3.3 进程组与 Sessions
 每一个进程都会是一个进程组的成员,而且这个进程组是唯一存在的,他们是依靠 PGID（process group ID）来区别的,而每当一个进程被创建的时候,它便会成为其父进程所在组中的一员。

一般情况,进程组的 PGID 等同于进程组的第一个成员的 PID,并且这样的进程称为该进程组的领导者,也就是领导进程,进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID,领导进程可以先终结,此时进程组依然存在,并持有相同的PGID,直到进程组中最后一个进程终结。

与进程组类似,每当一个进程被创建的时候,它便会成为其父进程所在 Session 中的一员,每一个进程组都会在一个 Session 中,并且这个 Session 是唯一存在的,

Session 主要是针对一个 tty 建立,Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时,都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端,并取其中的一个 job 作为前台,来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。

前台（foreground）就是在终端中运行,能与你有交互的

后台（background）就是在终端中运行,但是你并不能与其任何的交互,也不会显示其执行的过程

下一步

 3.4 工作管理
 bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。

并且每个终端或者说 bash 只能管理当前终端中的 job,不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2,bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job

我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它,但是若是在后台的话就不行了。

我们可以通过 & 这个符号,让我们的命令在后台中运行

ls &
实验楼

图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID,而最后一行的 Done 表示该命令已经在后台执行完毕。

我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去

实验楼

被停止并放置在后台的工作我们可以使用这个命令来查看

jobs
实验楼

其中第一列显示的为被放置后台 job 的编号,而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job,同时也表示预设的工作,也就是若是有什么针对后台 job 的操作,首先对预设的 job,- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作,倒数第三个（再之前的）以后都不会有这样的符号修饰,第三列表示它们的状态,而最后一列表示该进程执行的命令

我们可以通过这样的一个命令将后台的工作拿到前台来

#后面不加参数提取预设工作,加参数提取指定工作的编号
#ubuntu 在 zsh 中需要 %,在 bash 中不需要 %
fg [%jobnumber]
实验楼

实验楼

之前我们通过 ctrl + z 使得工作停止放置在后台,若是我们想让其在后台运作我们就使用这样一个命令

#与fg类似,加参则指定,不加参则取预设
bg [%jobnumber]
实验楼

既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台,当然也有方法删除一个工作,或者重启等等

#kill的使用格式如下
kill -signal %jobnumber

#signal从1-64个信号值可以选择,可以这样查看
kill －l
其中常用的有这些信号值

信号值	作用
-1	重新读取参数运行,类似与restart
-2	如同 ctrl+c 的操作退出
-9	强制终止该任务
-15	正常的方式终止该任务
实验楼

注意

若是在使用kill＋信号值然后直接加 pid,你将会对 pid 对应的进程进行操作

若是在使用kill+信号值然后 ％jobnumber,这时所操作的对象是 job,这个数字就是就当前 bash 中后台的运行的 job 的 ID

下一步

四、实验总结
通过本实验我们初步的了解进程在系统中存在的概念,以及进程如何在系统中衍生,发展,以及进程之间存在的相互关系,可以为我们在后续学习进程管理打下基础,同时了解了工作与进程,以及工作管理的一些使用性的操作。

下一步

Linux 进程管理
一、实验介绍
1.1 实验内容
通过本实验我们将掌握一些 Linux 所提供的工具来进行进程的查看与控制,掌握这些工具让我们能在某些进程出现异常的时候及时查看相关的指标,从而解决问题。

1.2 实验知识点
查看进程的运行状态
进程的结束控制
进程的执行顺序
下一步

二、 进程的查看
不管在测试的时候、在实际的生产环境中,还是自己的使用过程中,难免会遇到一些进程异常的情况,所以 Linux 为我们提供了一些工具来查看进程的状态信息。我们可以通过 top 实时的查看进程的状态,以及系统的一些信息（如 CPU、内存信息等）,我们还可以通过 ps 来静态查看当前的进程信息,同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。

下一步
 2.1 top 工具的使用
top 工具是我们常用的一个查看工具,能实时的查看我们系统的一些关键信息的变化:

top
实验楼

top 是一个在前台执行的程序,所以执行后便进入到这样的一个交互界面,正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。

我们看到 top 显示的第一排,

内容	解释
top	表示当前程序的名称
11:05:18	表示当前的系统的时间
up 8 days,17:12	表示该机器已经启动了多长时间
1 user	表示当前系统中只有一个用户
load average: 0.29,0.20,0.25	分别对应1、5、15分钟内cpu的平均负载
load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量,具体来说也就是指运行队列的平均长度,也就是等待 CPU 的平均进程数相关的一个计算值。

我们该如何看待这个load average 数据呢？

假设我们的系统是单 CPU、单内核的,把它比喻成是一条单向的桥,把CPU任务比作汽车。

load = 0 的时候意味着这个桥上并没有车,cpu 没有任何任务；
load < 1 的时候意味着桥上的车并不多,一切都还是很流畅的,cpu 的任务并不多,资源还很充足；
load = 1 的时候就意味着桥已经被车给占满了,没有一点空隙,cpu 的已经在全力工作了,所有的资源都被用完了,当然还好,这还在能力范围之内,只是有点慢而已；
load > 1 的时候就意味着不仅仅是桥上已经被车占满了,就连桥外都被占满了,cpu 已经在全力工作,系统资源的用完了,但是还是有大量的进程在请求,在等待。若是这个值大于２、大于３,表示进程请求超过 CPU 工作能力的 2 到 ３ 倍。而若是这个值 > 5 说明系统已经在超负荷运作了。
这是单个 CPU 单核的情况,而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过以下的命令来查看 CPU 的个数与核心数

#查看物理CPU的个数
#cat /proc/cpuinfo |grep "physical id"|sort |uniq|wc -l

#每个cpu的核心数
cat /proc/cpuinfo |grep "physical id"|grep "0"|wc -l

通过上面的指数我们可以得知 load 的临界值为 1 ,但是在实际生活中,比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值,不要混淆了

若是 load < 0.7 并不会去关注他；
若是 0.7< load < 1 的时候我们就需要稍微关注一下了,虽然还可以应付但是这个值已经离临界不远了；
若是 load = 1 的时候我们就需要警惕了,因为这个时候已经没有更多的资源的了,已经在全力以赴了；
若是 load > 5 的时候系统已经快不行了,这个时候你需要加班解决问题了
通常我们都会先看 15 分钟的值来看这个大体的趋势,然后再看 5 分钟的值对比来看是否有下降的趋势。

查看 busybox 的代码可以知道,数据是每 5 秒钟就检查一次活跃的进程数,然后计算出该值,然后 load 从 /proc/loadavg 中读取的。而这个 load 的值是如何计算的呢,这是 load 的计算的源码

#define FSHIFT      11          /* nr of bits of precision */
#define FIXED_1     (1<<FSHIFT) /* 1.0 as fixed-point(定点) */
#define LOAD_FREQ   (5*HZ)      /* 5 sec intervals,每隔5秒计算一次平均负载值 */
#define CALC_LOAD(load, exp, n)     \
         load *= exp;               \
         load += n*(FIXED_1 - exp); \
         load >>= FSHIFT;

unsigned long avenrun[3];

EXPORT_SYMBOL(avenrun);

/*
* calc_load - given tick count, update the avenrun load estimates.
* This is called while holding a write_lock on xtime_lock.
*/
static inline void calc_load(unsigned long ticks)
{
        unsigned long active_tasks; /* fixed-point */
        static int count = LOAD_FREQ;
        count -= ticks;
        if (count < 0) {
                count += LOAD_FREQ;
                active_tasks = count_active_tasks();
                CALC_LOAD(avenrun[0], EXP_1, active_tasks);
                CALC_LOAD(avenrun[1], EXP_5, active_tasks);
                CALC_LOAD(avenrun[2], EXP_15, active_tasks);
        }
}
有兴趣的朋友可以研究一下,是如何计算的。代码中的后面这部分相当于它的计算公式

我们回归正题,来看 top 的第二行数据,基本上第二行是进程的一个情况统计

内容	解释
Tasks: 26 total	进程总数
1 running	1个正在运行的进程数
25 sleeping	25个睡眠的进程数
0 stopped	没有停止的进程数
0 zombie	没有僵尸进程数
来看 top 的第三行数据,这一行基本上是 CPU 的一个使用情况的统计了

内容	解释
Cpu(s): 1.0%us	用户空间进程占用CPU百分比
1.0% sy	内核空间运行占用CPU百分比
0.0%ni	用户进程空间内改变过优先级的进程占用CPU百分比
97.9%id	空闲CPU百分比
0.0%wa	等待输入输出的CPU时间百分比
0.1%hi	硬中断(Hardware IRQ)占用CPU的百分比
0.0%si	软中断(Software IRQ)占用CPU的百分比
0.0%st	(Steal time) 是 hypervisor 等虚拟服务中,虚拟 CPU 等待实际 CPU 的时间的百分比
CPU 利用率是对一个时间段内 CPU 使用状况的统计,通过这个指标可以看出在某一个时间段内 CPU 被占用的情况,而 Load Average 是 CPU 的 Load,它所包含的信息不是 CPU 的使用率状况,而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息,这两个指标并不一样。

来看 top 的第四行数据,这一行基本上是内存的一个使用情况的统计了：

内容	解释
8176740 total	物理内存总量
8032104 used	使用的物理内存总量
144636 free	空闲内存总量
313088 buffers	用作内核缓存的内存量
注意

系统中可用的物理内存最大值并不是 free 这个单一的值,而是 free + buffers + swap 中的 cached 的和

来看 top 的第五行数据,这一行基本上是交换区的一个使用情况的统计了

内容	解释
total	交换区总量
used	使用的交换区总量
free	空闲交换区总量
cached	缓冲的交换区总量,内存中的内容被换出到交换区,而后又被换入到内存,但使用过的交换区尚未被覆盖
再下面就是进程的一个情况了

列名	解释
PID	进程id
USER	该进程的所属用户
PR	该进程执行的优先级 priority 值
NI	该进程的 nice 值
VIRT	该进程任务所使用的虚拟内存的总数
RES	该进程所使用的物理内存数,也称之为驻留内存数
SHR	该进程共享内存的大小
S	该进程进程的状态: S=sleep R=running Z=zombie
%CPU	该进程CPU的利用率
%MEM	该进程内存的利用率
TIME+	该进程活跃的总时间
COMMAND	该进程运行的名字
注意

NICE 值叫做静态优先级,是用户空间的一个优先级值,其取值范围是-20至19。这个值越小,表示进程”优先级”越高,而值越大“优先级”越低。nice值中的 -20 到 19,中 -20 优先级最高, 0 是默认的值,而 19 优先级最低

PR 值表示 Priority 值叫动态优先级,是进程在内核中实际的优先级值,进程优先级的取值范围是通过一个宏定义的,这个宏的名称是 MAX_PRIO,它的值为 140。Linux 实际上实现了 140 个优先级范围,取值范围是从 0-139,这个值越小,优先级越高。而这其中的 0 - 99 是实时进程的值,而 100 - 139 是给用户的。

其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19),这里的 -20 to +19 便是nice值,所以说两个虽然都是优先级,而且有千丝万缕的关系,但是他们的值,他们的作用范围并不相同

** VIRT **任务所使用的虚拟内存的总数,其中包含所有的代码,数据,共享库和被换出 swap空间的页面等所占据空间的总数

在上文我们曾经说过 top 是一个前台程序,所以是一个可以交互的

常用交互命令	解释
q	退出程序
I	切换显示平均负载和启动时间的信息
P	根据CPU使用百分比大小进行排序
M	根据驻留内存大小进行排序
i	忽略闲置和僵死的进程,这是一个开关式命令
k	终止一个进程,系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号,不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。
好好的利用 top 能够很有效的帮助我们观察到系统的瓶颈所在,或者是系统的问题所在。

下一步

 2.2 ps 工具的使用
 ps 也是我们最常用的查看进程的工具之一,我们通过这样的一个命令来了解一下,他能给我带来哪些信息

ps aux
实验楼

ps axjf
实验楼

我们来总体了解下会出现哪些信息给我们,这些信息又代表着什么（更多的 keywords 大家可以通过 man ps 了解）

内容	解释
F	进程的标志（process flags）,当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec,为 4 表示此程序使用超级管理员 root 权限
USER	进程的拥有用户
PID	进程的 ID
PPID	其父进程的 PID
SID	session 的 ID
TPGID	前台进程组的 ID
%CPU	进程占用的 CPU 百分比
%MEM	占用内存的百分比
NI	进程的 NICE 值
VSZ	进程使用虚拟内存大小
RSS	驻留内存中页的大小
TTY	终端 ID
S or STAT	进程状态
WCHAN	正在等待的进程资源
START	启动进程的时间
TIME	进程消耗CPU的时间
COMMAND	命令的名称和参数
TPGID栏写着-1的都是没有控制终端的进程,也就是守护进程

STAT表示进程的状态,而进程的状态有很多,如下表所示

状态	解释
R	Running.运行中
S	Interruptible Sleep.等待调用
D	Uninterruptible Sleep.不可中断睡眠
T	Stoped.暂停或者跟踪状态
X	Dead.即将被撤销
Z	Zombie.僵尸进程
W	Paging.内存交换
N	优先级低的进程
<	优先级高的进程
s	进程的领导者
L	锁定状态
l	多线程状态
+	前台进程
其中的 D 是不能被中断睡眠的状态,处在这种状态的进程不接受外来的任何 signal,所以无法使用 kill 命令杀掉处于D状态的进程,无论是 kill,kill -9 还是 kill -15,一般处于这种状态可能是进程 I/O 的时候出问题了。

ps 工具有许多的参数,下面给大家解释部分常用的参数

使用 -l 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来

ps -l
实验楼

相对来说我们更加常用下面这个命令,他将会罗列出所有的进程信息

ps aux
实验楼

若是查找其中的某个进程的话,我们还可以配合着 grep 和正则表达式一起使用

ps aux | grep zsh
实验楼

此外我们还可以查看时,将连同部分的进程呈树状显示出来

ps axjf
实验楼

当然如果你觉得使用这样的此时没有把你想要的信息放在一起,我们也可以是用这样的命令,来自定义我们所需要的参数显示

ps -afxo user,ppid,pid,pgid,command
实验楼

这是一个简单而又实用的工具,想要更灵活的使用,想要知道更多的参数我们可以使用 man 来获取更多相关的信息

下一步

 2.3 pstree 工具的使用
 通过 pstree 可以很直接的看到相同的进程数量,最主要的还是我们可以看到所有进程之间的相关性。

pstree
实验楼

pstree -up

#参数选择：
#-A  ：各程序树之间以 ASCII 字元來連接；
#-p  ：同时列出每个 process 的 PID；
#-u  ：同时列出每个 process 的所屬账户名称。
实验楼

下一步

三、进程的管理
本节将会为大家介绍如何去管理进程的。

下一步
 3.1 kill 命令的掌握
 上个实验中我们讲诉了进程之间是如何衍生,之间又有什么相关性,我们来回顾一下,当一个进程结束的时候或者要异常结束的时候,会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作,这个 SIGHUP 信号不仅可以由系统发送,我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。

上节课程我们使用 kill 命令来管理我们的一些 job,这节课我们将尝试用 kill 来操作下一些不属于 job 范畴的进程,直接对 pid 下手

#首先我们使用图形界面打开了 gedit、gvim,用 ps 可以查看到
ps aux

#使用9这个信号强制结束 gedit 进程
kill -9 1608

#我们再查找这个进程的时候就找不到了
ps aux | grep gedit 

实验楼

实验楼

下一步

 3.2 进程的执行顺序
 我们在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态,如果这些进程都被唤醒,那么该谁最先享受 CPU 的服务,后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？

当然就是靠该进程的优先级值来判定进程调度的优先级,而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了

而 nice 的值我们是可以通过 nice 命令来修改的,而需要注意的是 nice 值可以调整的范围是 -20 ~ 19,其中 root 有着至高无上的权力,既可以调整自己的进程也可以调整其他用户的程序,并且是所有的值都可以用,而普通用户只可以调制属于自己的进程,并且其使用的范围只能是 0 ~ 19,因为系统为了避免一般用户抢占系统资源而设置的一个限制

#这个实验在环境中无法做,因为权限不够,可以自己在本地尝试

#打开一个程序放在后台,或者用图形界面打开
nice -n -5 vim &

#用 ps 查看其优先级
ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim
我们还可以用 renice 来修改已经存在的进程的优先级,同样因为权限的原因在实验环境中无法尝试

renice -5 pid
下一步

四、实验总结
通过本实验我们学会了进程的查看命令 ps,pstree,top,以及使用这些命令时所得到的信息的含义,从而获取我们需要的信息,同时我们学会了进程的管理命令 kill,nice,renice

参考资料
注释1: 该例子参考于http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages

下一步

Linux 日志系统
一、实验介绍
1.1 实验内容
日志数据可以是有价值的信息宝库,也可以是毫无价值的数据泥潭。它可以记录下系统产生的所有行为,并按照某种规范表达出来。我们可以使用日志系统所记录的信息为系统进行排错,优化系统的性能,或者根据这些信息调整系统的行为。收集你想要的数据,分析出有价值的信息,可以提高系统、产品的安全性,还可以帮助开发完善代码,优化产品。日志会成为在事故发生后查明“发生了什么”的一个很好的“取证”信息来源。日志可以为审计进行审计跟踪。

1.2 实验知识点
常见的日志
配置的日志
轮替的日志
下一步

二、常见的日志
日志是一个系统管理员,一个运维人员,甚至是开发人员不可或缺的东西,系统用久了偶尔也会出现一些错误,我们需要日志来给系统排错,在一些网络应用服务不能正常工作的时候,我们需要用日志来做问题定位,日志还是过往时间的记录本,我们可以通过它知道我们是否被不明用户登录过等等。

在 Linux 中大部分的发行版都内置使用 syslog 系统日志,那么通过前期的课程我们了解到常见的日志一般存放在 /var/log 中,我们来看看其中有哪些日志

实验楼

根据图中所显示的日志,我们可以根据服务对象粗略的将日志分为两类

系统日志
应用日志
系统日志主要是存放系统内置程序或系统内核之类的日志信息如 alternatives.log 、btmp 等等,应用日志主要是我们装的第三方应用所产生的日志如 tomcat7 、apache2 等等。

接下来我们来看看常见的系统日志有哪些,他们都记录了怎样的信息

日志名称	记录信息
alternatives.log	系统的一些更新替代信息记录
apport.log	应用程序崩溃信息记录
apt/history.log	使用 apt-get 安装卸载软件的信息记录
apt/term.log	使用 apt-get 时的具体操作,如 package 的下载、打开等
auth.log	登录认证的信息记录
boot.log	系统启动时的程序服务的日志信息
btmp	错误的信息记录
Consolekit/history	控制台的信息记录
dist-upgrade	dist-upgrade 这种更新方式的信息记录
dmesg	启动时,显示屏幕上内核缓冲信息,与硬件有关的信息
dpkg.log	dpkg 命令管理包的日志。
faillog	用户登录失败详细信息记录
fontconfig.log	与字体配置有关的信息记录
kern.log	内核产生的信息记录,在自己修改内核时有很大帮助
lastlog	用户的最近信息记录
wtmp	登录信息的记录。wtmp可以找出谁正在进入系统,谁使用命令显示这个文件或信息等
syslog	系统信息记录
而在本实验环境中没有 apport.log 是因为 apport 这个应用程序需要读取一些内核的信息来收集判断其他应用程序的信息,从而记录应用程序的崩溃信息。而在本实验环境中我们没有这个权限,所以将 apport 从内置应用值剔除,自然而然就没有它的日志信息了。

只闻其名,不见其人,我们并不能明白这些日志记录的内容。首先我们来看 alternatives.log 中的信息,在本实验环境中没有任何日志输出是因为刚刚启动的系统中并没有任何的更新迭代。我可以看看从其他地方截取过来的内容

update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/x-www-browser x-www-browser /usr/bin/google-chrome-stable 200
update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/gnome-www-browser gnome-www-browser /usr/bin/google-chrome-stable 200
update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/google-chrome google-chrome /usr/bin/google-chrome-stable 200
我们可以从中得到的信息有程序作用,日期,命令,成功与否的返回码

我们用这样的命令来看看 auth.log 中的信息

less auth.log
实验楼

我们可以从中得到的信息有日期与 ip 地址的来源以及的用户与工具

在 apt 文件夹中的日志信息,其中有两个日志文件 history.log 与 term.log,两个日志文件的区别在于 history.log 主要记录了进行了哪个操作,相关的依赖有哪些,而 term.log 则是较为具体的一些操作,主要就是下载包,打开包,安装包等等的细节操作。

我们通过这样的例子就可以很明显的看出区别,在本实验环境中因为是刚启动的环境,所以两个日志中的信息都是空的

less /var/log/apt/history.log

less /var/log/apt/term.log
实验楼

实验楼

然后我们来安装 git 这个程序,因为本实验环境中本有预装 git 所以这里真正执行的操作是一个更新的操作,但这并不影响

sudo apt-get install git
实验楼

成功的执行之后我们再来查看两个日志的内容变化

实验楼

实验楼

其他的日志格式也都类似于之前我们所查看的日志,主要便是时间,操作。而这其中有两个比较特殊的日志,其查看的方式比较与众不同,因为这两个日志并不是 ASCII 文件而是被编码成了二进制文件,所以我们并不能直接使用 less、cat、more 这样的工具来查看,这两个日志文件是 wtmp,lastlog

实验楼

我们查看的方法是使用 last 与 lastlog 工具来提取其中的信息

实验楼

关于这两个工具的更深入使用我们可以使用前面的学习过的 man 来查看

下一步

三、配置的日志
这些日志是如何产生的？通过上面的例子我们可以看出大部分的日志信息似乎格式都很类似,并且都出现在这个文件夹中。

这样的实现可以通过两种方式：

一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；
一种方式就是 Linux 提供的日志服务程序,而我们这里系统日志是通过 syslog 来实现,提供日志管理服务。
syslog 是一个系统日志记录程序,在早期的大部分 Linux 发行版都是内置 syslog,让其作为系统的默认日志收集工具,虽然随着时代的进步与发展,syslog 已经年老体衰跟不上时代的需求,所以他被 rsyslog 所代替了,较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具

rsyslog的全称是 rocket-fast system for log,它提供了高性能,高安全功能和模块化设计。rsyslog 能够接受各种各样的来源,将其输入,输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。

这样能实时收集日志信息的程序是有其守护进程的,如 rsyslog 的守护进程便是 rsyslogd

因为一些原因本实验环境中默认并没有打开这个服务,我们可以手动开启这项服务,然后来查看

sudo apt-get update
sudo apt-get install -y rsyslog
sudo service rsyslog start
ps aux | grep syslog
实验楼

既然它是一个服务,那么它便是可以配置,为我们提供一些我们自定义的服务

首先我们来看 rsyslog 的配置文件是什么样子的,而 rsyslog 的配置文件有两个,

一个是 /etc/rsyslog.conf
一个是 /etc/rsyslog.d/50-default.conf。
第一个主要是配置的环境,也就是 rsyslog 加载什么模块,文件的所属者等；而第二个主要是配置的 Filter Conditions

vim /etc/rsyslog.conf 

vim /etc/rsyslog.d/50-default.conf
实验楼

实验楼

也不知道他在写什么,我们还是来看看 rsyslog 的结构框架,数据流的走向吧。

实验楼

通过这个简单的流程图我们可以知道 rsyslog 主要是由 Input、Output、Parser 这样三个模块构成的,并且了解到数据的简单走向,首先通过 Input module 来收集消息,然后将得到的消息传给 Parser module,通过分析模块的层层处理,将真正需要的消息传给 Output module,然后便输出至日志文件中。

上文提到过 rsyslog 号称可以提供超过每秒一百万条消息给目标文件,怎么只是这样简单的结构。我们可以通过下图来做更深入的了解

实验楼

（图片来源于http://www.rsyslog.com/doc/queues_analogy.html）

Rsyslog 架构如图中所示,从图中我们可以很清楚的看见,rsyslog 还有一个核心的功能模块便是 Queue,也正是因为它才能做到如此高的并发。

第一个模块便是 Input,该模块的主要功能就是从各种各样的来源收集 messages,通过这些接口实现：

接口名	作用
im3195	RFC3195 Input Module
imfile	Text File Input Module
imgssapi	GSSAPI Syslog Input Module
imjournal	Systemd Journal Input Module
imklog	Kernel Log Input Module
imkmsg	/dev/kmsg Log Input Module
impstats	Generate Periodic Statistics of Internal Counters
imptcp	Plain TCP Syslog
imrelp	RELP Input Module
imsolaris	Solaris Input Module
imtcp	TCP Syslog Input Module
imudp	UDP Syslog Input Module
imuxsock	Unix Socket Input
而 Output 中也有许多可用的接口,可以通过 man 或者官方的文档查看

而这些模块接口的使用需要通过 $ModLoad 指令来加载,那么返回上文的图中,配置生效的头两行可以看懂了,默认加载了 imklog、imuxsock 这两个模块

在配置中 rsyslog 支持三种配置语法格式：

sysklogd
legacy rsyslog
RainerScript
sysklogd 是老的简单格式,一些新的语法特性不支持。而 legacy rsyslog 是以 dollar 符($)开头的语法,在 v6 及以上的版本还在支持,就如上文所说的 $ModLoad 还有一些插件和特性只在此语法下支持。而以 $ 开头的指令是全局指令,全局指令是 rsyslogd 守护进程的配置指令,每行只能有一个指令。 RainnerScript 是最新的语法。在官网上 rsyslog 大多推荐这个语法格式来配置

老的语法格式（sysklogd & legacy rsyslog）是以行为单位。新的语法格式（RainnerScript）可以分割多行。

注释有两种语法:

井号 #
C-style /* .. */
执行顺序: 指令在 rsyslog.conf 文件中是从上到下的顺序执行的。

模板是 rsyslog 一个重要的属性,它可以控制日志的格式,支持类似 template() 语句的基于 string 或 plugin 的模板,通过它我们可以自定义日志格式。

legacy 格式使用 $template 的语法,不过这个在以后要移除,所以最好使用新格式 template():,以免未来突然不工作了也不知道为什么

模板定义的形式有四种,适用于不同的输出模块,一般简单的格式,可以使用 string 的形式,复杂的格式,建议使用 list 的形式,使用 list 的形式,可以使用一些额外的属性字段（property statement）

如果不指定输出模板,rsyslog 会默认使用 RSYSLOG_DEFAULT。若想更深入的学习可以查看官方文档

了解了 rsyslog 环境的配置文件之后,我们看向 /etc/rsyslog.d/50-default.conf 这个配置文件,这个文件中主要是配置的 Filter Conditions,也就是我们在流程图中所看见的 Parser & Filter Engine,它的名字叫 Selectors 是过滤 syslog 的传统方法,他主要由两部分组成,facility 与 priority,其配置格式如下

facility.priority　　　　　log_location
其中一个 priority 可以指定多个 facility,多个 facility 之间使用逗号 , 分割开

rsyslog 通过 Facility 的概念来定义日志消息的来源,以便对日志进行分类,Facility 的种类有：

类别	解释
kern	内核消息
user	用户信息
mail	邮件系统消息
daemon	系统服务消息
auth	认证系统
authpriv	权限系统
syslog	日志系统自身消息
cron	计划安排
news	新闻信息
local0~7	由自定义程序使用
而另外一部分 priority 也称之为 serverity level,除了日志的来源以外,对统一源产生日志消息还需要进行优先级的划分,而优先级的类别有以下几种：

类别	解释
emergency	系统已经无法使用了
alert	必须立即处理的问题
critical	很严重了
error	错误
warning	警告信息
notice	系统正常,但是比较重要
informational	正常
debug	debug的调试信息
panic	很严重但是已淘汰不常用
none	没有优先级,不记录任何日志消息
我们来看看系统中的配置

实验楼

auth,authpriv.*       /var/log/auth.log
这里的意思是 auth 与 authpriv 的所有优先级的信息全都输出于 /var/log/auth.log 日志中

而其中有类似于这样的配置信息意思有细微的差别

kern.*      -/var/log/kern.log
- 代表异步写入,也就是日志写入时不需要等待系统缓存的同步,也就是日志还在内存中缓存也可以继续写入无需等待完全写入硬盘后再写入。通常用于写入数据比较大时使用。

到此我们对 rsyslog 的配置就有了一定的了解,若想更深入学习模板,队列的高级应用,大家可去查看官网的文档,需要注意的是 rsyslog 每个版本之间差异化比较大,学习之前先查看自己所使用的版本,再去查看相关的文档

与日志相关的还有一个还有常用的命令 logger,logger 是一个 shell 命令接口,可以通过该接口使用 Syslog 的系统日志模块,还可以从命令行直接向系统日志文件写入信息。

#首先将syslog启动起来
sudo service rsyslog start

#向 syslog 写入数据
ping 127.0.0.1 | logger -it logger_test -p local3.notice &

#查看是否有数据写入
sudo tail -f /var/log/syslog

实验楼

从图中我们可以看到我们成功的将 ping 的信息写入了 syslog 中,格式也就是使用的 rsyslog 的默认模板

我们可以通过 man 来查看 logger 的其他用法,

参数	内容
-i	在每行都记录进程 ID
-t	添加 tag 标签
-p	设置日志的 facility 与 priority
下一步

四、转储的日志
在本地的机器中每天都有成百上千条日志被写入文件中,更别说是我们的服务器,每天都会有数十兆甚至更多的日志信息被写入文件中,如果是这样的话,每天看着我们的日志文件不断的膨胀,那岂不是要占用许多的空间,所以有个叫 logrotate 的东西诞生了。

logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除,并创建新的日志文件。我们可以根据日志文件的大小,也可以根据其天数来切割日志、管理日志,这个过程又叫做“转储”。

大多数 Linux 发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件,减少存储空间,还可以将日志发送到指定 E-mail,方便管理员及时查看日志。

显而易见,logrotate 是基于 CRON 来运行的,其脚本是 /etc/cron.daily/logrotate；同时我们可以在 /etc/logrotate 中找到其配置文件

cat /etc/logrotate.conf
实验楼

这其中的具体意思是什么呢？

# see "man logrotate" for details  //可以查看帮助文档
# rotate log files weekly
weekly                             //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期,月 )
# keep 4 weeks worth of backlogs
rotate 4                           //最多转储4次
# create new (empty) log files after rotating old ones
create                             //当转储后文件不存在时创建它
# uncomment this if you want your log files compressed
compress                          //通过gzip压缩方式转储（nocompress可以不压缩）
# RPM packages drop log rotation information into this directory
include /etc/logrotate.d           //其他日志文件的转储方式配置文件,包含在该目录下
# no packages own wtmp -- we'll rotate them here
/var/log/wtmp {                    //设置/var/log/wtmp日志文件的转储参数
    monthly                        //每月转储
    create 0664 root utmp          //转储后文件不存在时创建它,文件所有者为root,所属组为utmp,对应的权限为0664
    rotate 1                       //最多转储一次
}
当然在 /etc/logrotate.d/ 中有各项应用的 logrotate 配置,还有更多的配置参数,大家可以使用 man 查看,如按文件大小转储,按当前时间格式命名等等参数配置。

下一步

五、实验总结
通过本实验我们了解系统日志结构,以及我们可以从中获取什么样的信息,给我们带来什么样的价值。还有日志工具的配置,以及省心省力的 logrotate。

下一步


Python研发工程师
Python技术路径中包含入门知识、Python基础、Web框架、基础项目、网络编程、数据与计算及综合项目七个模块。模块中的课程将带着你逐步深入,学会如何使用 Python 实现一个博客,桌面词典,微信机器人或网络安全软件等。完成本路径的实验课,将具备独立开发 Python 软件和 Web 应用的能力。

linux(利纳斯)和 unix(林纳斯)区别
unix是操作系统,linux是内核
自由软件免费,商业软件
圆的周长 = 2πr
圆的面积 = πr²
矩形周长=(长+宽)×2=长×2+宽×2
矩形面积= 长*宽
bash(拜思) 介绍与入门 #后期需要学习
bash上Linux平台内核 shell(读"受") 是用户解释器
1.简介
Bash(GNU Bourne-Again Shell)是一个为GNU计划编写的Unix shell,它是许多Linux平台默认使用的shell

#创建一个名为 文件 的文件(加后缀就是文本),touch是一个命令
$ touch 文件 #创建文件
$ mkdir 目录名 创建一个目录或文件夹

#创建一个名为 文件 到文本并编辑
$ vi 文件.txt 

#进入一个目录,cd是一个命令
$ cd /etc/

#查看当前所在目录
$ pwd # 显示当前路径

$ tail 文件.txt #文件文本最后10行内容显示到终端上。

$ echo -e 'hello\npython' # 显示字符串
$ sudo apt-get update # root权限 获取最新

****************************************************************************************************************************************************************************************************
ubuntu18.04下常用命令积累...
注意:步骤4输入路径问题,比如共享了F盘,则路径为:smb://ip/f

1、查看某个进程的PID

ps aux | grep Pro_name
1
该命令不只可以列出PID,还会列出进程的详细运行路径。

2、杀死进程

sudo kill PID
1
3、查看开机启动项(这个不太了解)

service --status-all
1
4、设置开机自启动方法之一
(1)在/etc/systmed/system目录下创建一个xxx.service文件,里面加入一些命令,命令主要由下面3个部分构成:

[Unit]
......
[Service]
......
[Install]
......

(2)设置好后,还要enable一下,命令如下:

systemctl enable /etc/systemd/system/xxx.service
1
重启电脑后生效。

5、自动安装依赖库:
当出现如下依赖库问题时,有时候需要安装的依赖库很多一个一个敲又很麻烦时,可尝试如下命令自动安装:

dpkg: 依赖关系问题使得 teamviewer 的配置工作不能继续:
 teamviewer 依赖于 libqt5gui5 (>= 5.5) | qt56-teamviewer；然而:
  未安装软件包 libqt5gui5:amd64。
  未安装软件包 qt56-teamviewer。

dpkg: 处理软件包 teamviewer (--install)时出错:
 依赖关系问题 - 仍未被配置
正在处理用于 gnome-menus (3.13.3-11ubuntu1.1) 的触发器 ...
正在处理用于 desktop-file-utils (0.23-1ubuntu3.18.04.2) 的触发器 ...
正在处理用于 mime-support (3.60ubuntu1) 的触发器 ...
正在处理用于 hicolor-icon-theme (0.17-2) 的触发器 ...
在处理时有错误发生:
 teamviewer
 
命令:
sudo apt-get install python3-pip # 安装python到pip下载第三方库
pip3 -V查看pip3的版本
sudo pip3 install --upgrade pip # 更新pip3
apt install	apt-get install	安装软件包
apt remove	apt-get remove	移除软件包
apt purge	apt-get purge	移除软件包及配置文件
apt update	apt-get update	刷新存储库索引
apt upgrade	apt-get upgrade	升级所有可升级的软件包
apt autoremove	apt-get autoremove	自动删除不需要的包
apt full-upgrade	apt-get dist-upgrade	在升级软件包时自动处理依赖关系
apt search	apt-cache search	搜索应用程序
apt show	apt-cache show	显示装细节

 sudo apt-get install -f
1
6、切换默认python版本:

sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150
(数量越大表示优先级越高,切换的实质是改变优先级)
1
2
3
7、修改root用户密码:

sudo passwd
1
输入上述命令后,会提示输入新密码,照着提示修改即可

其他命令

$ clear  # 清除(清屏)
$ sudo ifconfig ens33 down # 超级权限:ens33网络关闭(禁用)
$ sudo ifconfig ens33 up # 超级权限:ens33网络启动(开启)

name # 姓名

Ubuntu 基本命令行操作
一、文件/文件夹管理 

ls 列出当前目录文件(不包括隐含文件) 
ls -a 列出当前目录文件(包括隐含文件) 
ls -l 列出当前目录下文件的详细信息 

cd .. 回当前目录的上一级目录 
cd - 回上一次所在的目录 
cd ~ 或 cd 回当前用户的宿主目录 
mkdir 目录名 创建一个目录 
rmdir 空目录名 删除一个空目录 
rm 文件名 文件名 删除一个文件或多个文件 
rm -rf 非空目录名 删除一个非空目录下的一切 
mv 剪切

二、系统管理 

fdisk fdisk -l 查看系统分区信息 
fdisk fdisk /dev/sdb 为一块新的SCSI硬盘进行分区 
chown chown root /home 把/home的属主改成root用户 
chgrp chgrp root /home 把/home的属组改成root组 

Useradd 创建一个新的用户 
Groupadd 组名 创建一个新的组 
Passwd 用户名 为用户创建密码 
Passwd -d用户名 删除用户密码也能登陆 
Passwd -S用户名 查询账号密码 
Usermod -l 新用户名 老用户名 为用户改名 
Userdel–r 用户名 删除用户一切 

service [servicename] start/stop/restart 系统服务控制操作 
/etc/init.d/[servicename] start/stop/restart 系统服务控制操作 

uname -a 查看内核版本 
cat /etc/issue 查看ubuntu版本 
lsusb 查看usb设备 
sudo ethtool eth0 查看网卡状态 
cat /proc/cpuinfo 查看cpu信息 
lshw 查看当前硬件信息 
sudo fdisk -l 查看磁盘信息 
df -h 查看硬盘剩余空间 
free -m 查看当前的内存使用情况 
ps -A 查看当前有哪些进程 
kill 进程号(就是ps -A中的第一列的数字)或者 killall 进程名( 杀死一个进程) 
kill -9 进程号 强制杀死一个进程 

reboot Init 6 重启LINUX系统 
Halt Init 0 Shutdown –h now 关闭LINUX系统 

三、解压缩命令 

.gz 
解压1:gunzip FileName.gz
解压2:gzip -d FileName.gz 
压缩:gzip FileName 
.tar.gz 
解压:tar -zxvf FileName.tar.gz 
压缩:tar -zcvf FileName.tar.gz DirName 
----------------------------------------------------- 
.zip 
解压:unzip FileName.zip 
压缩:zip FileName.zip DirName 
--------------------------------------------
.rar 
解压:rar a FileName.rar 
压缩:rar e FileName.rar
----------------------------------
.bz2 
解压1:bzip2 -d FileName.bz2 
解压2:bunzip2 FileName.bz2 
压缩: bzip2 -z FileName 
.tar.bz2 
解压:tar -jxvf FileName.tar.bz2 
压缩:tar -jcvf FileName.tar.bz2 DirName 
------------------------------------------------------ 
.bz 
解压1:bzip2 -d FileName.bz 
解压2:bunzip2 FileName.bz 
压缩:未知 
.tar.bz 
解压:tar -jxvf FileName.tar.bz 
压缩:未知 
--------------------------------------------- 
.Z 
解压:uncompress FileName.Z 
压缩:compress FileName 
.tar.Z 
解压:tar -Zxvf FileName.tar.Z 
压缩:tar -Zcvf FileName.tar.Z DirName 
--------------------------------------------------
.gz 
解压:tar -zxvf FileName.gz 
压缩:未知 
.tar.gz 
解压:tar -zxvf FileName.tar.gz 
压缩:tar -zcvf FileName.tar.gz FileName 

四、make编译 

make 编译 
make install 安装编译好的源码包 

五、apt命令 

apt-cache search package 搜索包 
apt-cache show package 获取包的相关信息,如说明、大小、版本等 
sudo apt-get install package 安装包 
sudo apt-get install package - - reinstall 重新安装包 
sudo apt-get remove package 删除包 
sudo apt-get remove package - - purge 删除包,包括删除配置文件等 
sudo apt-get update 更新源 
sudo apt-get upgrade 更新已安装的包 
sudo apt-get dist-upgrade 升级系统 
apt-cache rdepends package 是查看该包被哪些包依赖 
sudo apt-get build-dep package 安装相关的编译环境 
apt-get source package 下载该包的源代码 
sudo apt-get clean && sudo apt-get autoclean 清理无用的包 
sudo apt-get clean 清理所有软件缓存(即缓存在/var/cache/apt/archives目录里的deb包)
 
六、日期时间

设置日期 
#date -s mm/dd/yy 

设置时间 
#date -s HH:MM 

将时间写入CMOS 
#hwclock –systohc 

读取CMOS时间 
#hwclock –hctosys 

从服务器上同步时间 
#sudo ntpdate time.nist.gov 
#sudo ntpdate time.windows.com 

七、控制台 

不同控制台间切换 
Ctrl + ALT + ← Ctrl + ALT + → 

指定控制台切换 
Ctrl + ALT + Fn(n:1~7) 

控制台下滚屏 
SHIFT + pageUp/pageDown 

控制台抓图 
#setterm -dump n(n:1~7) 

数据库 
mysql的数据库存放在地方 
#/var/lib/mysql 

从mysql中导出和导入数据 
#mysqldump 数据库名 > 文件名 #导出数据库 
#mysqladmin create 数据库名 #建立数据库 
#mysql 数据库名 < 文件名 #导入数据库 

忘了mysql的root口令怎么办 
#sudo /etc/init.d/mysql stop 
#sudo mysqld_safe –skip-grant-tables 
#sudo mysqladmin -u user password ‘newpassword" 
#sudo mysqladmin flush-privileges 

修改mysql的root口令 
#sudo mysqladmin -uroot -p password ‘你的新密码’ 

Ubuntu命令行下修改网络配置 

以eth0为例 
1. 以DHCP方式配置网卡 
编辑文件/etc/network/interfaces: 
#sudo vi /etc/network/interfaces 
并用下面的行来替换有关eth0的行: 
# The primary network interface - use DHCP to find our address 
auto eth0 
iface eth0 inet dhcp 
用下面的命令使网络设置生效: 
#sudo /etc/init.d/networking restart 
当然,也可以在命令行下直接输入下面的命令来获取地址 
#sudo dhclient eth0 

2. 为网卡配置静态IP地址 
编辑文件/etc/network/interfaces: 
#sudo vi /etc/network/interfaces 
并用下面的行来替换有关eth0的行: 
# The primary network interface 
auto eth0 
iface eth0 inet static 
address 192.168.3.90 
gateway 192.168.3.1 
netmask 255.255.255.0 
network 192.168.3.0 
broadcast 192.168.3.255 
将上面的ip地址等信息换成你自己就可以了. 

用下面的命令使网络设置生效: 
#sudo /etc/init.d/networking restart 

3. 设定第二个IP地址(虚拟IP地址) 
编辑文件/etc/network/interfaces: 
#sudo vi /etc/network/interfaces 
在该文件中添加如下的行: 
auto eth0:1 
iface eth0:1 inet static 
address 192.168.1.60 
netmask 255.255.255.0 
network x.x.x.x 
broadcast x.x.x.x 
gateway x.x.x.x 
根据你的情况填上所有诸如address,netmask,network,broadcast和gateways等信息. 
用下面的命令使网络设置生效: 
#sudo /etc/init.d/networking restart 

4. 设置主机名称(hostname) 
查看当前主机的主机名称: 
#sudo /bin/hostname 
设置当前主机的主机名称: 
#sudo /bin/hostname newname 
系统启动时,它会从/etc/hostname来读取主机的名称. 

5. 配置DNS 
首先,你可以在/etc/hosts中加入一些主机名称和这些主机名称对应的IP地址,这是简单使用本机的静态查询. 
要访问DNS 服务器来进行查询,需要设置/etc/resolv.conf文件. 
假设DNS服务器的IP地址是192.168.3.2, 那么/etc/resolv.conf文件的内容应为: 
search test.com 
nameserver 192.168.3.2 

安装AMP服务 
如果采用Ubuntu Server CD开始安装时,可以选择安装,这系统会自动装上apache2,php5和mysql5。下面主要说明一下如果不是安装的Ubuntu server时的安装方法。 
用命令在Ubuntu下架设Lamp其实很简单,用一条命令就完成。在终端输入以下命令: 
#sudo apt-get install apache2 mysql-server php5 php5-mysql php5-gd #phpmyadmin 
装好后,mysql管理员是root,无密码,通过http://localhost/phpmyadmin就可以访问mysql了 

修改 MySql 密码 
终端下输入: 
#mysql -u root 
#mysql> GRANT ALL PRIVILEGES ON *.* TO root@localhost IDENTIFIED BY “123456″; 
’123456‘是root的密码,可以自由设置,但最好是设个安全点的。 
#mysql> quit; 退出mysql 

桌面汉化: 
System>Language Support>Chinese选项勾打上。 

安装解码器、flashplayer、java虚拟机、微软字体 
这是ubuntu推出的一个新软件包,将一次性将上面几个东东自动装好 
在终端输入 
#sudo apt-get install ubuntu-restricted-extras 

FireFox 中安装 FlashPlayer 插件 
先下载插件: install_flash_player_9_linux.tar.gz 
#tar -zxf install_flash_player_9_linux.tar.gz 
#./flashplayer-installer 

回答(y/n/q)? n/q 
#sudo cp libflashplayer.so /usr/lib/firefox/plugins 
启动 firefox 即可！ 

安装媒体播放器 
安装的是mplayer 
终端输入:#sudo apt-get install mplayer mozilla-mplayer totem-xine libxine-extracodecs 

另外需要一个w32codecs文件,是用来支持那些私有媒体格式的解码器,源里已经没有w32codecs了,我们可以从这里下载那个后缀为.deb的安装 
http://www.debian-multimedia.org/pool/main/w/w32codecs/ 

安装下载工具(多线程下载、BT下载、电驴) 
还是终端输入:#sudo apt-get install d4x amule azureus 
即可。 
或者把 beryl-manager添加到启动项内 

apt下载的deb包清理 
在使用完apt后,系统下载的deb包会留存在硬盘里,我们可以把它们删除,释放硬盘空间。 
终端输入:#sudo apt-get clean 

安装rar压缩、解压工具 
终端输入:#sudo apt-get install rar unrar 

启用root(最高权限)帐户 
终端输入:#sudo passwd root 
输入你希望的root用户的密码 

安装QQ 
终端输入:#sudo apt-get install eva 
便可安装eva了,如果你是使用scim(选择中文语言支持的自动安装的就是scim),为了可以在eva里面输入文字,要在终端输入:sudo apt-get install scim-qtimm 
系统会安装支持QT的scim插件,这样你就可以使用eva聊qq了。 

显卡驱动安装 
进入“系统"－>“系统管理"－>“受限驱动管理器" 
找到你的显卡,把那个框点成对号,会提示你安装显卡驱动,然后按照提示一步一步安装完毕,重启即可。 

如何设定/改变/启用 root 使用者的密码? 
#sudo passwd root 

sudo -s            #进入root用户模式,仍在原来目录下（不要用su - root,否则进入root目录了）
如何在终端机模式下切换到 root 身份? 
#sudo -s -H 
Password: <在这注明您的密码> 
 
来源出处:http://www.jb51.net/os/Ubuntu/56362.html

****************************************************************************************************************************************************************************************************

终端
按键	作用
Ctrl+d	键盘输入结束或退出终端
Ctrl+s	暂停当前程序,暂停后按下任意键恢复运行
Ctrl+z	将当前程序放到后台运行,恢复到前台为命令fg
Ctrl+a	将光标移至输入行头,相当于Home键
Ctrl+e	将光标移至输入行末,相当于End键
Ctrl+k	删除从光标所在位置到行末
Alt+Backspace	向前删除一个单词
Shift+PgUp	将终端显示向上滚动
Shift+PgDn

# 创建love_{1到10}_shiyanlou个文件代码形式
$ touch love_{1..10}_shiyanlou.txt

$ man * # 命令帮助文档(详细介绍)
$ * --help # 命令详细参数介绍(简介介绍)

info * > man * > * --help (详细文档大到小排列)

$ info ls # 查看ls 文档信息(最详细到信息)
$ man ls # 查看ls帮助信息
$ ls --help  # 查看ls帮助信息并显示屏幕上
#号代表的是root用户,$号代表的普通用户

#下载自动下载 sysvbanner
sudo apt-get install sysvbanner

2.1 查看用户命令

$ who 查看用户命令
$ who --help 查看用户命令

$ sudo adduser python2019 创建一个新的用户(python2019)
$ su python2019 # 切换用户到python2019
$ su - python2019 # 将 shell 设为登录 shell
$ groups shiyanlou #使用 groups 命令查看用户组
$ groupmod 注:修改用户组信息 
$ groupmod 注:修改用户组信息 
$ cat /etc/group | sort
cat  # 查看文件的内容并打印到终端输出
sort # 读取的文本进行一个字典排序再输出
$ su shiyanlou # 此处需要输入shiyanlou用户密码,点击右侧工具栏“SSH直连”,可以看到密码。
$ groups lilei #查看李磊用户组
$ sudo usermod -G sudo lilei # 新的附加组列表 GROUPS
$ groups lilei #查看李磊用户组

删除用户是很简单的事:
$ sudo deluser lilei --remove-home

$ ls -l # 查看文件权限,使用较长格式列出文件

Linux 里面一切皆文件,正因为这一点才有了设备文件( /dev 目录下有各种设备文件,大都跟具体的硬件设备相关)这一说。 

socket:网络套接字 # 关于网络连接这块

ls -lh 查看 查看文件的大小

$ ls -AsSh #    查看目录下到文件信息(相当于win系统cmd终端到dir命令)

$ sudo chown shiyanlou iphone6 # iphone6权限修改shiyanlou能访问
$ chown # 只有root用户修改权限
$ echo "echo \"hello shiyanlou\"" > iphone6
iphone6 只能是shiyanlou用户访问


$ ll 文件 查看权限
$ chmod go-rw iphone6 # 同上
# 文件权限更改为 ***
$ chmod +x 文件 # 文件添加执行权限
# * 表示0-7
$ sudo chmod *** 文件名 # 添加权限 
文件‘r’ 表示读权限
文件‘w’ 表示写权限
文件‘x’ 表示执行权限
r2w1x0 ==pow(2,2)+pow(2,1)+pow(2,0)

adduser 和 useradd 的区别是什么？
$ useradd 只创建用户,创建完了用 passwd lilei 去设置新用户的密码。
 useradd、userdel 这类操作更像是一种命令,执行完了就返回。
adduser 更像是一种程序,需要你输入、确定等一系列操作。

每个文件的三组权限(拥有者,所属用户组,其他用户,记住这个顺序是一定的)

$ ll #一般用来看权限
$ cd ~ #进入当前登陆到用户目录下
$ cd - #表示上一次所在目录

# test文件拷贝到grandson目录下
$ cp test father/son/grandson
# 拷贝目录 grandson复制到grandson1目录里
$ cp -r grandson1 grandson
$ mv 源目录文件 目的目录 #移动
$ mv 旧的文件名 新的文件名 #重命名

绝对路径 
关于绝对路径,简单地说就是以根" / "目录为起点的完整路径,以你所要到的目录为终点,表现形式如: /usr/local/bin

$ cat 为正序显示 -n 文件显示行号
$ tac 为倒序显示

passwd # 输入当前密码后更改密码

执行一个shell 命令 自动打开三个标准文件 
输入文件(stdin)
输出文件(stdout)
错误输出文件(stderr)
$ cat 文件 # 查看文件
-b : 指定添加行号的方式,主要有两种:
    -b a:表示无论是否为空行,同样列出行号("cat -n"就是这种方式)
    -b t:只列出非空行的编号并列出(默认为这种方式)
-n : 设置行号的样式,主要有三种:
    -n ln:在行号字段最左端显示
    -n rn:在行号字段最右边显示,且不加 0
    -n rz:在行号字段最右边显示,且加 0
-w : 行号字段占用的位数(默认为 6 位)

 more 和 less 就是天生用来"阅读"一个文件的内容的(查看文件)
 less 工具也是对文件或其它输出进行分页显示的工具,应该说是linux正统查看文件内容的工具,功能极其强大。less 的用法比起 more 更加的有弹性。 在 more 的时候,我们并没有办法向前面翻, 只能往后面看,但若使用了 less 时,就可以使用 [pageup] [pagedown] 等按 键的功能来往前往后翻看文件,更容易用来查看一个文件的内容！除此之外,在 less 里头可以拥有更多的搜索功能,不止可以向下搜,也可以向上搜。
 
 more功能类似 cat ,cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读,而最基本的指令就是按空白键(space)就往下一页显示,按 b 键就会往回(back)一页显示,而且还有搜寻字串的功能 。more命令从前向后读取文件,因此在启动时就加载整个文件。
 
$ tail -f 绝对路径 # 实现动态查看日志
 
$ nohup xeyes # 一双眼睛出现

$ declare tmp #使用 declare 命令创建一个变量名为 tmp 的变量
$ tmp=shiyanlou # 赋值
$ echo $tmp # 打印变量值(用于字符串的输出)

set	显示当前 Shell (用户)所有变量,包括其内建环境变量(与 Shell 外观等相关),用户自定义变量及导出的环境变量。
env 显示与当前用户相关的环境变量,还可以让命令在指定环境中运行。
export	显示从 Shell 中导出成环境变量的变量,也能通过它将自定义变量导出为环境变量。

比较set,env,export区别
$ temp=shiyanlou
$ export temp_env=shiyanlou
$ env|sort>env.txt
$ export|sort>export.txt
$ set|sort>set.txt
$ vimdiff env.txt export.txt set.txt
# 使用 vimdiff 工具比较导出的几个文件的内容

$ echo $PATH # 查看环境变量(win环境变量一样)

创建一个 Shell 脚本文件:

$ cd /home/shiyanlou # 切换目录
$ touch hello_shell.sh # 新建文件
$ gedit hello_shell.sh # 打开文件

hello_shell文件内容(第一行并不是注释):
#!/bin/bash

for ((i=0; i<10; i++));do
    echo "hello shell"
done

exit 0

$ ll hello_shell.sh # 查看权限
$ chmod 755 hello_shell.sh # 添加可执行权限(r读w写x运行)
$ cd /home/shiyanlou # 切换目录
$ ./hello_shell.sh # 运行Shell脚本


创建一个 C 语言“ hello world ”程序:

$ cd /home/shiyanlou # 切换目录
$ gedit hello_world.c # 新建并打开

hello_world.c内容如下(#不是注释):
#include <stdio.h>

int main(void)
{
    printf("hello world!\n");
    return 0;
}

c语言转换可执行文件
# 保存后使用 gcc 生成可执行文件
$ gcc -o hello_world hello_world.c # C语言源代码生成可执行文件
$ ll hello_shell.sh # 查看权限
$ chmod 755 hello_shell.sh # 添加可执行权限(r读w写x运行)

$ cd /home/shiyanlou # 切换目录
$ mkdir mybin # 新建目录
$ mv hello_shell.sh hello_world mybin/ # 剪切到mybin目录下
$ cd mybin # 进入目录
$ ./hello_shell.sh # 执行shell脚本
$ ./hello_world # 执行c语言可执行程序
$ echo "PATH=$PATH:/home/shiyanlou/mybin" >> .zshrc # 修改用户目录下的配置文件(全局变量) 
详细说明
在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本,以初始化环境,包括添加一些用户自定义环境变量等等。zsh 的配置文件是 .zshrc,相应 Bash 的配置文件为 .bashrc 。它们在 etc 下还都有一个或多个全局的配置文件,不过我们一般只修改用户目录下的配置文件。

环境变量(变量修改)
变量设置方式	说明
${变量名#匹配字串}	从头向后开始匹配,删除符合匹配字串的最短数据
${变量名##匹配字串}	从头向后开始匹配,删除符合匹配字串的最长数据
${变量名%匹配字串}	从尾向前开始匹配,删除符合匹配字串的最短数据
${变量名%%匹配字串}	从尾向前开始匹配,删除符合匹配字串的最长数据
${变量名/旧的字串/新的字串}	将符合旧字串的第一个字串替换为新的字串
${变量名//旧的字串/新的字串}	将符合旧字串的全部字串替换为新的字串
$ path=$PATH # 先赋值一份
$ echo $path # 查看复制环境变量
$ path=${path%/home/shiyanlou/mybin}
# 或使用通配符,*表示任意多个任意字符
$ path=${path%*/mybin}

$ unset 环境变量 # 删除环境变量
$ cd /home/shiyanlou 
$ source .zshrc # (全局变量)立即生效
$ . ./.zshrc # (全局变量)立即生效

环境变量查找搜索文件
与搜索相关的命令常用的有 whereis,which,find 和 locate 。
whereis 简单快速
$ whereis who # 查找who
$ whereis find # 查找find

$ sudo apt-get update # 安装更新系统
$ sudo apt-get install locate # 安装locate 插件
$ locate /etc/sh # 查找etc目录下sh开头到文件
$ locate *.* # 查找任意文件
$ locate */.* # 查找任意目录
$ locate /usr/share/\*.jpg # 特定目录下查找
locate 文件 -c # 显示文件到数量
-i # 忽略大小写进行查找
-b # 只匹配路径名的基本名称
  
  locate选项
  -b, --basename         match only the base name of path names
  -c, --count            只输出找到的数量
  -d, --database DBPATH  使用DBPATH指定的数据库,而不是默认数据库 /var/lib/mlocate/mlocate.db
  -e, --existing         only print entries for currently existing files
  -L, --follow           follow trailing symbolic links when checking file existence (default)
  -h, --help             显示帮助
  -i, --ignore-case      忽略大小写
  -l, --limit, -n LIMIT  limit output (or counting) to LIMIT entries
  -m, --mmap             ignored, for backward compatibility
  -P, --nofollow, -H     don't follow trailing symbolic links when checking file existence
  -0, --null             separate entries with NUL on output
  -S, --statistics       don't search for entries, print statistics about eachused database
  -q, --quiet            安静模式,不会显示任何错误讯息
  -r, --regexp REGEXP    使用基本正则表达式
      --regex            使用扩展正则表达式
  -s, --stdio            ignored, for backward compatibility
  -V, --version          显示版本信息
  -w, --wholename        match whole path name (default)

which 小而精
$ which man
which 本身是 Shell 内建的一个命令,我们通常使用 which 来确定是否安装了某个指定的软件,因为它只从 PATH 环境变量指定的路径中去搜索命令

find 精而细
find 应该是这几个命令中最强大的了,它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性(如文件的时间戳,文件的权限等)进行搜索。find 命令强大到,要把它讲明白至少需要单独好几节课程才行,我们这里只介绍一些常用的内容。

这条命令表示去 /etc/ 目录下面 ,搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式,千万记住 find 的第一个参数是要搜索的地方:

$ sudo find /etc/ -name interfaces # 注意 find 命令的路径是作为第一个参数的, 基本命令格式为 find [path] [option] [action] 。
参数	说明
-atime	最后访问时间
-ctime	最后修改文件内容的时间
-mtime	最后修改文件属性的时间

下面以 -mtime 参数举例:
-mtime n:n 为数字,表示为在 n 天之前的“一天之内”修改过的文件
-mtime +n:列出在 n 天之前(不包含 n 天本身)被修改过的文件
-mtime -n:列出在 n 天之内(包含 n 天本身)被修改过的文件
-newer file:file 为一个已存在的文件,列出比 file 还要新的文件名

$ find ~ -mtime 0 # home 目录中,当天(24 小时之内)有改动的文件

$ find ~ -newer /home/shiyanlou/Code # 列出用户家(shiyanlou)目录下比 Code 文件夹新的文件:
 
$ sudo apt-get update; sudo apt-get install cmatrix; cmatrix # 获得软件更新；获得安装cmatrix插件
$ cmatrix -C green # 《黑客帝国》数字雨颜色修改(默认是绿色) 小程序

使用 zip 打包文件夹:
$ cd /home/shiyanlou 
$ zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop #-r 参数表示递归打包包含子目录的全部内容,-q 参数表示为安静模式,即不向屏幕输出信息,-o,表示输出文件,需在其后紧跟打包输出文件名。 
$ du -h shiyanlou.zip # 查看打包后文件的大小
$ file shiyanlou.zip # 文件信息

$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip # -9 表示体积最小但耗时最久,-x 是为了排除我们上一次创建的 zip 文件
$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip #　-1 表示最快压缩但体积大l,-x 是为了排除我们上一次创建的 zip 文件,否则又会被打包进这一次的压缩文件中,注意:这里只能使用绝对路径,否则不起作用。

创建加密 zip 包
使用 -e 参数可以创建加密压缩包:
$ zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop


注意: 关于 zip 命令,因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题,比如换行符(为不可见字符),在 Windows 为 CR+LF(Carriage-Return+Line-Feed:回车加换行),而在 Linux/Unix 上为 LF(换行),所以如果在不加处理的情况下,在 Linux 上编辑的文本,在 Windows 系统上打开可能看起来是没有换行的。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题,那么你还需要对命令做一些修改:

$ zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop
需要加上 -l 参数将 LF 转换为 CR+LF 来达到以上目的。

$ unzip shiyanlou.zip # 将 shiyanlou.zip 解压到当前目录

$ unzip -q shiyanlou.zip -d ziptest # 使用安静模式,将文件解压到指定ziptest目录下:

$ unzip -l shiyanlou.zip # 查看压缩包的内容你可以使用 -l 参数(查看压缩文件)

unzip -O GBK 中文压缩文件.zip
注意: 使用 unzip 解压文件时我们同样应该注意兼容问题,不过这里我们关心的不再是上面的问题,而是中文编码的问题,通常 Windows 系统上面创建的压缩文件,如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码,而 Linux 上面默认使用的是 UTF-8 编码,如果不加任何处理,直接解压的话可能会出现中文乱码的问题(有时候它会自动帮你处理),为了解决这个问题,我们可以在解压时指定编码类型。
使用 -O(英文字母,大写 o)参数指定编码类型:

创建一个 tar 包:
$ cd /home/shiyanlou
$ tar -cf shiyanlou.tar /home/shiyanlou/Desktop # 创建shiyanlou.tar包;-c创建-f创建到名称 

解包一个文件(-x 参数)到指定路径的已存在目录(-C 参数):
$ mkdir tardir
$ tar -xf shiyanlou.tar -C tardir
只查看不解包文件 -t 参数:
$ tar -tf shiyanlou.tar
保留文件属性和跟随链接(符号链接或软链接),有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性(-p 参数)和备份链接指向的源文件而不是链接本身(-h 参数):
$ tar -cphf etc.tar /etc
对于创建不同的压缩格式的文件,对于 tar 来说是相当简单的,需要的只是换一个参数,这里我们就以使用 gzip 工具创建 *.tar.gz 文件为例来说明。

我们只需要在创建 tar 文件的基础上添加 -z 参数,使用 gzip 来压缩文件:
$ tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop
解压 *.tar.gz 文件:
$ tar -xzf shiyanlou.tar.gz
此处输入图片的描述

现在我们要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可:

压缩文件格式	参数
*.tar.gz	-z
*.tar.xz	-J
*tar.bz2	-j
tar 命令的参数很多,不过常用的就是上述这些,需要了解更多你可以查看 man 手册获取帮助。

压缩文件(zip):
打包 :zip something.zip something(源文件、目录,路径) (目录请加 -r 参数)
解包:unzip something.zip
指定路径:-d 参数

压缩文件(tar):
打包:tar -cf something.tar something
解包:tar -xf something.tar
指定路径:-C 参数

$ sudo apt-get install libaa-bin 
# 提示 command not found ,请自行解决
$ aafire  # 火苗小程序

$ df -h # 查看磁盘的容量
# 默认同样以 块 的大小展示
$ du 
# 加上`-h`参数,以更易读的方式展示
$ du -h

-d参数指定查看目录的深度
# 只查看1级目录的信息
$ du -h -d 0 ~
# 查看2级
$ du -h -d 1 ~

常用参数
du -h #同--human-readable 以K,M,G为单位,提高信息的可读性。
du -a #同--all 显示目录中所有文件的大小。
du -s #同--summarize 仅显示总计,只列出最后加总的值。

来自: http://man.linuxde.net/du

估计文件空间使用情况
du(estimate file space usage)
报告文件系统磁盘空间使用情况
df(report file system disk space usage)

 Linux 支持哪些文件系统：
ls -l /lib/modules/$(uname -r)/kernel/fs 

mount命令的一般格式如下：
mount [options] [source] [directory]
一些常用操作：
mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]
注意：由于实验楼的环境限制,mount 命令挂载及 umount 卸载都无法进行操作,可以简单了解这些步骤。

sudo fdisk -l # # 查看硬盘分区表信息

轻松一下(显示动物图像小程序)
cowsay命令,可以让你在终端里以一种动物说话的形式打印出一段话。

# 更新软件包
$ sudo apt update

# 安装
$ sudo apt install -y cowsay

# 默认是一只牛
$ cowsay hello shiyanlou

# 加上'-l'参数打印所有支持的动物(其实不只是动物)种类
$ cowsay -l

# 使用'-f'参数选择动物种类
$ cowsay -f elephant hello shiyanlou

# 安装 fortune-zh
$ sudo apt-get install fortune-zh

# 此外它还可以结合我们之前的作业讲过的 fortune 命令一起使用
$ /usr/games/fortune | cowsay -f daemon

找出当前目录下面占用最大的前十个文件:
$ sudo du -amh | sort -nr | head -n 10

$ history # 查看历史命令
命令用于显示历史记录和执行过的指令命令。
本地文件位置是：~/.zsh_history
ubuntu位置是~/.bash_history

exit 退出命令

$ type * # 查看命令是什么内部还是外部命令

$ type exit # 得到这样的结果说明是内建命令,正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中
xxx is a shell builtin

$ type vi #得到这样的结果说明是外部命令,正如上文所说,外部命令在/usr/bin or /usr/sbin等等中
xxx is /usr/bin/xxx

$ type ls #若是得到alias的结果,说明该指令为命令别名所设定的名称；
xxx is an alias for xx --xxx

ubuntu2018@linux:/$ type exit
exit 是 shell 内建
ubuntu2018@linux:/$ type vi
vi 是 /usr/bin/vi
ubuntu2018@linux:/$ type ls
ls 是 `ls --color=auto' 的别名(alias)

crontab语法 (定时命令)
# m h  dom mon dow   command # 格式
每个目录的作用：
/etc/cron.daily,目录下的脚本会每天执行一次,在每天的6点25分时运行；
/etc/cron.hourly,目录下的脚本会每个小时执行一次,在每小时的17分钟时运行；
/etc/cron.monthly,目录下的脚本会每月执行一次,在每月1号的6点52分时运行；
/etc/cron.weekly,目录下的脚本会每周执行一次,在每周第七天的6点47分时运行；

目标
1.为 shiyanlou 用户添加计划任务
2.每天凌晨 3 点的时候定时备份 alternatives.log 到 /home/shiyanlou/tmp/ 目录
3.命名格式为 年-月-日,比如今天是2017年4月1日,那么文件名为 2017-04-01

参考答案：
sudo cron -f &
crontab -e 添加
0 3 * * * sudo rm /home/shiyanlou/tmp/*
0 3 * * * sudo cp /var/log/alternatives.log /home/shiyanlou/tmp/$(date +\%Y-\%m-\%d)

$ sudo apt-get update;sudo apt-get install cmatrix;cmatrix
# 3行语句一次性执行完(更新安装包安装程序运行程序数字雨)
$ sudo apt-get remove 要删除的软件包名 # 卸载安装包

Ubuntu查找已安装软件
两种方法
apt list --installed
dpkg -l    

查找某款软件
dpkg -l | grep xxx

Linux 中三种标准输入输出,分别是STDIN,STDOUT,STDERR,对应的数字是0,1,2。
STDIN,STDOUT,STDERR。
0	 ,	1	 , 2	 。

linux -- 命令行中大于号、小于号的用法
语法:
"命令 < 文件" 这是将文件作为命令输入.
"命令 < 文件1 >文件2" 将文件1输入到命令中,然后将结果输出到文件2中

linux >(大于号)和&&(逻辑于)和$?(命令值)和命令放回值解释
# 虚拟ubuntu系统已经安装里cowsay程序
ubuntu2018@linux:~$ which cowsay>/dev/null && cowsay -f head-in ohch~ # null文件里查找cowsay命令逻辑于命令执行
cowsay: Could not find head-in cowfile! # 结果
ubuntu2018@linux:~$ which cowsay # 查看命令位置
/usr/games/cowsay #命令位置
ubuntu2018@linux:~$ echo $?　# 命令值(上一个命令能查到返回0,查询不到返回1)
0 # 查得到返回0
ubuntu2018@linux:~$ which cuowu # 查找cuowu命令(这里是没有这个命令到)
ubuntu2018@linux:~$ echo $? # 命令值
1 # 查询不到返回1

&& 严格 两边有一边是零结果就是零
|| 宽恕 两边有一边不是零结果就是不是零

管道是什么？管道是一种通信机制,通常用于进程间的通信(也可通过 socket 进行网络通信),它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。

管道又分为匿名管道和具名管道(这里将不会讨论在源程序中使用系统调用创建并使用管道的情况,它与命令行的管道在内核中实际都是采用相同的机制)。我们在使用一些过滤程序时经常会用到的就是匿名管道,在命令行中由|分隔符表示,|在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道,通常只会在源程序中用到具名管道。下面我们就将通过一些常用的可以使用管道的"过滤程序"来帮助你熟练管道的使用。
简而言之：管道默认是连接前一个命令的输出到下一个命令的输入
重定向通常是需要一个文件来建立两个命令的连接

$ ls -alh /etc | less # 查看etc目录下(隐藏,较长格式,kmg为单位) 使用less程序查看


cut 截取数据(剪切数据)

-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界,除非也指定了 -n 标志。
-c ：以字符为单位进行分割。
-d ：自定义分隔符,默认为制表符。
-f ：与-d一起使用,指定显示哪个区域。
-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的
范围之内,该字符将被写出；否则,该字符将被排除

$ cut /etc/passwd -d ':' -f 1,6 # 分隔符的第1个字段和第6个字段分别表示用户名和其家目录

打印/etc/passwd文件中每一行的前N(5)个字符：
# 前五个(包含第五个)
$ cut /etc/passwd -c -5
# 前五个之后的(包含第五个)
$ cut /etc/passwd -c 5-
# 第五个
$ cut /etc/passwd -c 5
# 2到5之间的(包含第五个)
$ cut /etc/passwd -c 2-5

grep命令是很强大的,也是相当常用的一个命令
grep [命令选项]... 用于匹配的表达式 [文件]...
$ grep -rnI "shiyanlou" ~ # 搜索/home/shiyanlou目录下所有包含"shiyanlou"的文本文件,并显示出现在文本中的行号
$ export | grep ".*yanlou$" # 正则表达式查看环境变量中以"yanlou"结尾的字符串

wc 命令用于统计并输出一个文件中行、单词和字节的数目
$ wc /etc/passwd # passwd目录下行、单词和字节的数目
ubuntu结果：  46   75 2688 /etc/passwd

# 行数
$ wc -l /etc/passwd
# 单词数
$ wc -w /etc/passwd
# 字节数
$ wc -c /etc/passwd
# 字符数
$ wc -m /etc/passwd
# 最长行字节数
$ wc -L /etc/passwd

$ ls -dl /etc/*/ | wc -l # 结合管道来操作一下,下面统计 /etc 下面所有目录数

$ cat /etc/passwd | sort # 查看passwd文件 默认a-z排序
$ cat /etc/passwd | sort -r # 查看passwd文件 反序z-a

linux中sort命令
参　　数：
  -b   忽略每行前面开始出的空格字符。
  -c   检查文件是否已经按照顺序排序。
  -d   排序时,处理英文字母、数字及空格字符外,忽略其他的字符。
  -f   排序时,将小写字母视为大写字母。
  -i   排序时,除了040至176之间的ASCII字符外,忽略其他的字符。
  -m   将几个排序好的文件进行合并。
  -M   将前面3个字母依照月份的缩写进行排序。
  -n   依照数值的大小排序。
  -o<输出文件>   将排序后的结果存入指定的文件。
  -r   以相反的顺序来排序。
  -t<分隔字符>   指定排序时所用的栏位分隔字符。
  +<起始栏位>-<结束栏位>   以指定的栏位来排序,范围由起始栏位到结束栏位的前一栏位。
  --help   显示帮助。
  --version   显示版本信息
  
$ cat /etc/passwd | sort -t':' -k 3 -n # 查看passwd文件 自定义以：分割排序 第二个冒号-n(数字排序)
passwd问句 :对应的标示
注册名：口令：用户标识号：组标识号：用户名：用户主目录：命令解释程序 

uniq命令可以用于过滤或者输出重复行。
$ history | cut -c 8- | cut -d ' ' -f 1 | uniq # 查找历史命令去重
-c或--count 在每列旁边显示该行重复出现的次数。
-d或--repeated 仅显示重复出现的行列。
-f<栏位>或--skip-fields=<栏位> 忽略比较指定的栏位。
-s<字符位置>或--skip-chars=<字符位置> 忽略比较指定的字符。
-u或--unique 仅显示出一次的行列。
-w<字符位置>或--check-chars=<字符位置> 指定要比较的字符。
--help 显示帮助。
--version 显示版本信息。
[输入文件] 指定已排序好的文本文件。如果不指定此项,则从标准读取数据；
[输出文件] 指定输出的文件。如果不指定此选项,则将内容显示到标准输出设备(显示终端)。
# 或者
$ history | cut -c 8- | cut -d ' ' -f 1 | sort -u # 查找历史命令去重
-c或--coun

输出重复行
# 输出重复过的行(重复的只输出一个)及重复次数
$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -dc

# 输出所有重复的行
$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -D

$ sudo apt-get install aview
$ sudo apt-get install imagemagick
$ wget http://****.com # 下载
$ sudo find /目录 -name 文件或目录名 # 查找文件和目录位置
$ asciiview 图片名 # 打开字符串图片

cut 截取字段
sort 排序(默认排序是：a-z)
uniq 去重 (重复字母删除)

简单的文本处理
tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。
tr [option(选项)]...SET1 [SET2]
tr 'a-z' 'A-Z' # 小写字母都替换成大写字母

SET 是一组字符串,一般都可按照字面含义理解。解析序列如下：

# 删除 "hello shiyanlou" 中所有的'o','l','h'
$ echo 'hello shiyanlou' | tr -d 'olh'
# 将"hello" 中的ll,去重为一个l
$ echo 'hello' | tr -s 'l'
# 将输入文本,全部转换为大写或小写输出
$ echo 'input some text here' | tr '[:lower:]' '[:upper:]'
# 上面的'[:lower:]' '[:upper:]'你也可以简单的写作'[a-z]' '[A-Z]',当然反过来将大写变小写也是可以的

  \NNN	八进制值为NNN 的字符(1 至3 个数位)
  \\		反斜杠
  \a		终端鸣响
  \b		退格
  \f		换页
  \n		换行
  \r		回车
  \t		水平制表符
  \v		垂直制表符
  字符1-字符2	从字符1 到字符2 的升序递增过程中经历的所有字符
  [字符*]	在SET2 中适用,指定字符会被连续复制直到吻合设置1 的长度
  [字符*次数]	对字符执行指定次数的复制,若次数以 0 开头则被视为八进制数
  [:alnum:]	所有的字母和数字
  [:alpha:]	所有的字母(包括大小写)
  [:blank:]	所有呈水平排列的空白字符
  [:cntrl:]	所有的控制字符
  [:digit:]	所有的数字
  [:graph:]	所有的可打印字符,不包括空格
  [:lower:]	所有的小写字母
  [:print:]	所有的可打印字符,包括空格
  [:punct:]	所有的标点字符
  [:space:]	所有呈水平或垂直排列的空白字符
  [:upper:]	所有的大写字母
  [:xdigit:]	所有的十六进制数
  [=字符=]	所有和指定字符相等的字符


col 命令可以将Tab换成对等数量的空格键,或反转这个操作。
# 查看 /etc/protocols 中的不可见字符,可以看到很多 ^I ,这其实就是 Tab 转义成可见字符的符号
$ cat -A /etc/protocols
# 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格,然后再使用 cat 查看,你发现 ^I 不见了
$ cat /etc/protocols | col -x | cat -A
常用的选项有：
选项	说明
-x	将Tab转换为空格
-h	将空格转换为Tab(默认选项)

join
这个命令就是用于将两个文件中包含相同内容的那一行合并在一起。

使用方式：
join [option]... file1 file2
$ echo '1 hello' > file1
$ echo '1 shiyanlou' > file2
$ join file1 file2
结果为：1 hello shiyanlou
# 将/etc/passwd与/etc/shadow两个文件合并,指定以':'作为分隔符
$ sudo join -t':' /etc/passwd /etc/shadow
# 将/etc/passwd与/etc/group两个文件合并,指定以':'作为分隔符, 分别比对第4和第3个字段
$ sudo join -t':' -1 4 /etc/passwd -2 3 /etc/group

详细解析Linux /etc/passwd文件
每个用户都有一个对应的记录行,它记录了这个用户的一些基本属性。系统管理员经常会接触到这个文件的修改以完成对用户的管理工作。
linux的root密码存在/etc/shadow

paste这个命令与join 命令类似,它是在不对比数据的情况下,简单地将多个文件合并一起,以Tab隔开。
$ echo hello > file1 # 字符串直接写入 file1文件
$ echo shiyanlou > file2 # 字符串直接写入 file2文件
$ echo www.shiyanlou.com > file3 # 字符串直接写入 file3文件
$ paste -d ':' file1 file2 file3 # 以：分割合并
结果为：hello:shiyanlou:www.shiyanlou.com
$ paste -s file1 file2 file3
结果为：hello
shiyanlou
www.shiyanlou.com

如断行符 Windows 为 CR+LF(\r\n),Linux/UNIX 为 LF(\n)。使用cat -A 文本 可以看到文本中包含的不可见特殊字符。Linux 的\n表现出来就是一个$,而 Windows/dos的表现为^M$,可以直接使用dos2unix和unix2dos工具在两种格式之间进行转换,使用file命令可以查看文件的具体类型。

$ sudo apt-get install ninvaders # 空间侵略者(小蜜蜂)小游戏 
$ /usr/games/ninvaders # 运行小游戏
sudo apt-get install pacman4console # 吃豆子(吃豆子)小游戏 

重定向的方向以及其他符号到含义
>  # 表示先执行右边再执行左边
>>  # 表示先执行右边再追加执行右边
<  # 表示 先执行右边再执行左边
<<  # 表示先右后左
$  # 表示变量替换(Variable Substitution)的代表符号。
;  # 表示前语句结束符
.  # 当前目录
..  # 返回上一层目录
LINUX符号大全
# ; ;; . , / \ 'string'| ! $ ${} $? $$ $* "string"* ** ? : ^ $# $@ `command`{} [] [[]] () (()) || && {xx,yy,zz,...}~ ~+ ~- & \<...\> + - %= == !=
 
 
#：常出现在命令之前,或者命令之后,后面是注释文字,不会被执行
当一个命令不想被执行的时候,前面加一个#就行了
如果被用在指令中,或者被双引号括住的话,或者在双斜线后面,不具备以上功能
~ 账户中的home目录
代表使用者的home目录
; 分号 (Command separator)
在 shell 中,担任"连续指令"功能的符号就是"分号"。譬如以下的例子：cd ~/backup ; mkdir startup ;cp ~/.* startup/.
 
 
;; 连续分号 (Terminator)
专用在 case 的选项,担任 Terminator 的角色。
case "$fop" inhelp) echo "Usage: Command -help -version filename";;version) echo "version 0.1" ;;esac
 
 
. 逗号 (dot,就是“点”)
在 shell 中,使用者应该都清楚,一个 dot 代表当前目录,两个 dot 代表上层目录。
CDPATH=.:~:/home:/home/web:/var:/usr/local
在上行 CDPATH 的设定中,等号后的 dot 代表的就是当前目录的意思。
如果档案名称以 dot 开头,该档案就属特殊档案,用 ls 指令必须加上 -a 选项才会显示。除此之外,在 regularexpression 中,一个 dot 代表匹配一个字元。
 
 
'string' 单引号 (single quote)
被单引号用括住的内容,将被视为单一字串。在引号内的代表变数的$符号,没有作用,也就是说,他被视为一般符号处理,防止任何变量替换。
heyyou=homeecho '$heyyou' # We get $heyyou
 
 
"string" 双引号 (double quote)
被双引号用括住的内容,将被视为单一字串。它防止通配符扩展,但允许变量扩展。这点与单引数的处理方式不同。
heyyou=homeecho "$heyyou" # We get home
 
`command` 倒引号 (backticks)
在前面的单双引号,括住的是字串,但如果该字串是一列命令列,会怎样？答案是不会执行。要处理这种情况,我们得用倒单引号来做。
fdv=`date +%F`echo "Today $fdv"
在倒引号内的 date +%F 会被视为指令,执行的结果会带入 fdv 变数中。
 
 
, 逗点 (comma,标点中的逗号)
这个符号常运用在运算当中当做"区隔"用途。如下例
#!/bin/bashlet "t1 = ((a = 5 + 3, b = 7 - 1, c = 15 / 3))"echo "t1= $t1, a = $a, b = $b"
 
 
/ 斜线 (forward slash)
在路径表示时,代表目录。
cd /etc/rc.dcd ../..cd /
通常单一的 / 代表 root 根目录的意思；在四则运算中,代表除法的符号。
let "num1 = ((a = 10 / 2, b = 25 / 5))"
 
 
\ 倒斜线
在交互模式下的escape 字元,有几个作用；放在指令前,有取消 aliases的作用；放在特殊符号前,则该特殊符号的作用消失；放在指令的最末端,表示指令连接下一行。
# type rmrm is aliased to `rm -i'# \rm ./*.log
上例,我在 rm 指令前加上 escape 字元,作用是暂时取消别名的功能,将 rm 指令还原。
# bkdir=/home# echo "Backup dir, \$bkdir = $bkdir"Backup dir,$bkdir = /home
上例 echo 内的 \$bkdir,escape 将 $ 变数的功能取消了,因此,会输出 $bkdir,而第二个 $bkdir则会输出变数的内容 /home。
 
 
| 管道 (pipeline)
pipeline 是 UNIX 系统,基础且重要的观念。连结上个指令的标准输出,做为下个指令的标准输入。
who | wc -l
善用这个观念,对精简 script 有相当的帮助。
 
 
! 惊叹号(negate or reverse)
通常它代表反逻辑的作用,譬如条件侦测中,用 != 来代表"不等于"
if [ "$?" != 0 ]thenecho "Executes error"exit 1fi
在规则表达式中她担任 "反逻辑" 的角色
ls a[!0-9]
上例,代表显示除了a0, a1 .... a9 这几个文件的其他文件。
 
 
: 冒号
在 bash 中,这是一个内建指令："什么事都不干",但返回状态值 0。
:
echo $? # 回应为 0
: > f.
上面这一行,相当于cat/dev/null>f.
 
。不仅写法简短了,而且执行效率也好上许多。
有时,也会出现以下这类的用法
: ${HOSTNAME?} ${USER?} ${MAIL?}
这行的作用是,检查这些环境变数是否已设置,没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if这类的做法,基本上也可以处理,但都比不上上例的简洁与效率。
除了上述之外,还有一个地方必须使用冒号
PATH=$PATH:$HOME/fbin:$HOME/fperl:/usr/local/mozilla
在使用者自己的HOME 目录下的 .bash_profile或任何功能相似的档案中,设定关于"路径"的场合中,我们都使用冒号,来做区隔。
 
 
? 问号 (wild card)
在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元,但不包含 null 字元。
# ls a?a1
善用她的特点,可以做比较精确的档名匹配。
 
 
* 星号 (wild card)
相当常用的符号。在文件名扩展(Filename expansion)上,她用来代表任何字元,包含 null 字元。
# ls a*a a1 access_log
在运算时,它则代表 "乘法"。
let "fmult=2*3"
除了内建指令 let,还有一个关于运算的指令expr,星号在这里也担任"乘法"的角色。不过在使用上得小心,他的前面必须加上escape 字元。
 
 
** 次方运算
两个星号在运算时代表 "次方" 的意思。
let "sus=2**3"echo "sus = $sus" # sus = 8
 
 
$ 钱号(dollar sign)
变量替换(Variable Substitution)的代表符号。
vrs=123echo "vrs = $vrs" # vrs = 123
另外,在 Regular Expressions 里被定义为 "行" 的最末端 (end-of-line)。这个常用在grep、sed、awk 以及 vim(vi) 当中。
 
 
${} 变量的正规表达式
bash 对 ${} 定义了不少用法。以下是取自线上说明的表列
${parameter:-word} ${parameter:=word} ${parameter:?word} ${parameter:+word} ${parameter:offset} ${parameter:offset:length} ${!prefix*} ${#parameter} ${parameter#word} ${parameter##word} ${parameter%word} ${parameter%%word} ${parameter/pattern/string} ${parameter//pattern/string}
 
 
$*
$* 引用script的执行引用变量,引用参数的算法与一般指令相同,指令本身为0,其后为1,然后依此类推。引用变量的代表方式如下：
$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}.....
个位数的,可直接使用数字,但两位数以上,则必须使用 {} 符号来括住。
$* 则是代表所有引用变量的符号。使用时,得视情况加上双引号。
echo "$*"
还有一个与 $* 具有相同作用的符号,但效用与处理方式略为不同的符号。
 
 
$@
$@ 与 $* 具有相同作用的符号,不过她们两者有一个不同点。
符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。
 
$#
这也是与引用变量相关的符号,她的作用是告诉你,引用变量的总数量是多少。
echo "$#"
 
 
$? 状态值 (status variable)
一般来说,UNIX(linux) 系统的进程以执行系统调用exit()来结束的。这个回传值就是status值。回传给父进程,用来检查子进程的执行状态。
一般指令程序倘若执行成功,其回传值为 0；失败为 1。
tar cvfz dfbackup.tar.gz /home/user > /dev/nullecho"$?"
由于进程的ID是唯一的,所以在同一个时间,不可能有重复性的PID。有时,script会需要产生临时文件,用来存放必要的资料。而此script亦有可能在同一时间被使用者们使用。在这种情况下,固定文件名在写法上就显的不可靠。唯有产生动态文件名,才能符合需要。符号
 
或许可以符合这种需求。它代表当前shell 的 PID。
echo "$HOSTNAME, $USER, $MAIL" > ftmp.$$
使用它来作为文件名的一部份,可以避免在同一时间,产生相同文件名的覆盖现象。
ps: 基本上,系统会回收执行完毕的 PID,然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法,如果script 执行完毕后仍不加以清除,会产生其他问题。
 
( ) 指令群组 (command group)
用括号将一串连续指令括起来,这种用法对 shell 来说,称为指令群组。如下面的例子：(cd ~ ; vcgh=`pwd` ;echo $vcgh),指令群组有一个特性,shell会以产生 subshell来执行这组指令。因此,在其中所定义的变数,仅作用于指令群组本身。我们来看个例子
# cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e "\n $a \n")echo $a#./ftmp-01incgfsh
除了上述的指令群组,括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape字元才能使用的场合,如运算式。
 
 
(( ))
这组符号的作用与 let 指令相似,用在算数运算上,是 bash 的内建功能。所以,在执行效率上会比使用 let指令要好许多。
#!/bin/bash(( a = 10 ))echo -e "inital value, a = $a\n"(( a++))echo "after a++, a = $a"
 
{ } 大括号 (Block of code)
有时候 script 当中会出现,大括号中会夹着一段或几段以"分号"做结尾的指令或变数设定。
# cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e "\n $a \n"}echo $a#./ftmp-02inbcinbc
这种用法与上面介绍的指令群组非常相似,但有个不同点,它在当前的 shell 执行,不会产生 subshell。
大括号也被运用在 "函数" 的功能上。广义地说,单纯只使用大括号时,作用就像是个没有指定名称的函数一般。因此,这样写 script也是相当好的一件事。尤其对输出输入的重导向上,这个做法可精简 script 的复杂度。
 
此外,大括号还有另一种用法,如下
{xx,yy,zz,...}
这种大括号的组合,常用在字串的组合上,来看个例子
mkdir {userA,userB,userC}-{home,bin,data}
我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data,这几个目录。这组符号在适用性上相当广泛。能加以善用的话,回报是精简与效率。像下面的例子
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
如果不是因为支援这种用法,我们得写几行重复几次呀！
 
 
[ ] 中括号
常出现在流程控制中,扮演括住判断式的作用。if [ "$?" != 0 ]thenecho "Executes error"exit1fi
这个符号在正则表达式中担任类似 "范围" 或 "集合" 的角色
rm -r 200[1234]
上例,代表删除 2001, 2002, 2003, 2004 等目录的意思。
 
 
[[ ]]
这组符号与先前的 [] 符号,基本上作用相同,但她允许在其中直接使用 || 与&& 逻辑等符号。
#!/bin/bashread akif [[ $ak > 5 || $ak< 9 ]]thenecho $akfi
 
 
|| 逻辑符号
这个会时常看到,代表 or 逻辑的符号。
 
 
&& 逻辑符号
这个也会常看到,代表 and 逻辑的符号。
 
 
& 后台工作
单一个& 符号,且放在完整指令列的最后端,即表示将该指令列放入后台中工作。
tar cvfz data.tar.gz data > /dev/null&
 
\<...\> 单字边界
这组符号在规则表达式中,被定义为"边界"的意思。譬如,当我们想找寻 the 这个单字时,如果我们用
grep the FileA
你将会发现,像 there 这类的单字,也会被当成是匹配的单字。因为 the 正巧是 there的一部份。如果我们要必免这种情况,就得加上 "边界" 的符号
grep '\' FileA
 
 
+ 加号 (plus)
在运算式中,她用来表示 "加法"。
expr 1 + 2 + 3
此外在规则表达式中,用来表示"很多个"的前面字元的意思。
# grep '10\+9' fileB109100910000910000931010009#这个符号在使用时,前面必须加上escape 字元。
 
 
- 减号 (dash)
在运算式中,她用来表示 "减法"。
expr 10 - 2
此外也是系统指令的选项符号。
ls -expr 10 - 2
在 GNU 指令中,如果单独使用 - 符号,不加任何该加的文件名称时,代表"标准输入"的意思。这是 GNU指令的共通选项。譬如下例
tar xpvf -
这里的 - 符号,既代表从标准输入读取资料。
不过,在 cd 指令中则比较特别
cd -
这代表变更工作目录到"上一次"工作目录。
 
 
% 除法 (Modulo)
在运算式中,用来表示 "除法"。
expr 10 % 2
此外,也被运用在关于变量的规则表达式当中的下列
${parameter%word}${parameter%%word}
一个 % 表示最短的 word 匹配,两个表示最长的 word 匹配。
 
 
= 等号 (Equals)
常在设定变数时看到的符号。
vara=123echo " vara = $vara"
或者像是 PATH 的设定,甚至应用在运算或判断式等此类用途上。
 
 
== 等号 (Equals)
常在条件判断式中看到,代表 "等于" 的意思。
if [ $vara == $varb ]
...下略
 
!= 不等于
常在条件判断式中看到,代表 "不等于" 的意思。
if [ $vara != $varb ]
...下略
 
 
^
这个符号在规则表达式中,代表行的 "开头" 位置,在[]中也与"!"(叹号)一样表示“非”
 
 
输出/输入重导向
> >> < << :> &> 2&> 2<>>& >&2
 
文件描述符(File Descriptor),用一个数字(通常为0-9)来表示一个文件。
常用的文件描述符如下：
文件描述符 名称 常用缩写 默认值
0 标准输入 stdin 键盘
1 标准输出 stdout 屏幕
2 标准错误输出 stderr 屏幕
我们在简单地用<或>时,相当于使用 0< 或 1>(下面会详细介绍)。
* cmd > file
把cmd命令的输出重定向到文件file中。如果file已经存在,则清空原有文件,使用bash的noclobber选项可以防止复盖原有文件。
* cmd >> file
把cmd命令的输出重定向到文件file中,如果file已经存在,则把信息加在原有文件後面。
* cmd < file
使cmd命令从file读入
* cmd << text
从命令行读取输入,直到一个与text相同的行结束。除非使用引号把输入括起来,此模式将对输入内容进行shell变量替换。如果使用<<- ,则会忽略接下来输入行首的tab,结束行也可以是一堆tab再加上一个与text相同的内容,可以参考後面的例子。
* cmd <<< word
把word(而不是文件word)和後面的换行作为输入提供给cmd。
* cmd <> file
以读写模式把文件file重定向到输入,文件file不会被破坏。仅当应用程序利用了这一特性时,它才是有意义的。
* cmd >| file
功能同>,但即便在设置了noclobber时也会复盖file文件,注意用的是|而非一些书中说的!,目前仅在csh中仍沿用>!实现这一功能。
: > filename 把文件"filename"截断为0长度.# 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同).
cmd >&n 把输出送到文件描述符n
cmd m>&n 把输出到文件符m的信息重定向到文件描述符n
cmd >&- 关闭标准输出
cmd <&n 输入来自文件描述符n
cmd m<&n m来自文件描述各个n
cmd <&- 关闭标准输入
cmd <&n- 移动输入文件描述符n而非复制它。
cmd >&n- 移动输出文件描述符 n而非复制它。
注意： >&实际上复制了文件描述符,这使得cmd > file 2>&1与cmd 2>&1 >file的效果不一样。
&&表并且 &\u 表首字母大写 &\l表首字母小写 &表示连接
网站地址：https://www.cnblogs.com/a12a/p/6693143.html


$ mkdir Documents # 新建目录
$ cat > Documents/test.c <<EOF # 手动编辑文件最后输入 EOF 结束符


echo 'hi'  # 屏幕上输入字符串
echo 'hi' | cat # 连结上个指令的标准输出,做为下个指令的标准输入。
结果屏幕输出一样为：hi
但是后台运作是不一样滴

对于&1 更准确的说应该是文件描述符 1,而1标识标准输出,stdout。
对于2 ,表示标准错误,stderr。
2>&1 的意思就是将标准错误重定向到标准输出。
0 标准输入 stdin 键盘
1 标准输出 stdout 屏幕
2 标准错误输出 stderr 屏幕


你可能还有这样的需求,除了需要将输出重定向到文件,也需要将信息打印在终端。那么你可以使用tee命令来实现：

 (耳扣)
$ echo 'hello shiyanlou' | tee hello # tee命令屏幕和文件都保存

$ zsh
主要功能 在缓冲区中编辑多行命令

开启文件描述符(请百度)

关闭文件描述符
$ exec 3>&- 或者(ubuntu)$ exec 255>&-
$ cd /dev/fd;ls -Al;cd -

$ cat Documents/test.c nefile 1>/dev/null 2>&1 # 屏蔽命令的输出

彩色图像
$ sudo apt-get install caca-utils
$ cacaview <pic_file>
$ cacademo
$ cacafire

bash学习
$ vim test.sh
#!/bin/bash

echo "The # here does not begin a comment."
echo 'The # here does not begin a comment.'
echo The \# here does not begin a comment.
echo The # 这里开始一个注释
echo $(( 2#101011 ))     # 数制转换(使用二进制表示),不是一个注释,双括号表示对于数字的处理
$ bash test.sh

分号;
$ vim test2.sh # 新建文件并编辑内容如下：
#!/bin/bash
echo hello; echo there
filename=ttt.sh
if [ -e "$filename" ]; then    # 注意: "if"和"then"需要分隔,-e用于判断文件是否存在
 echo "File $filename exists."; cp $filename $filename.bak
else
 echo "File $filename not found."; touch $filename
fi; echo "File test complete."

$ bash test2.sh # 执行代码
结果为：
hello
there
File $filename not found.
File test complete.

$ vim test3.sh # # 新建文件并编辑内容如下：
#!/bin/bash

varname=b # 变量

case "$varname" in # 判断变量范围
    [a-z]) echo "abc";; # 注意不要少反括号')'
    [0-9]) echo "123";; # 选择对应到范围后打印	
esac


$ bash test3.sh # 执行
结果为：abc


source命令也称为“点命令”,也就是一个点符号(.),是bash的内部命令。
功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句
source命令通常用于重新执行刚修改的初始化文件,使之立即生效,而不必注销并重新登录
用法：
$ echo 'echo Hello World' > test.sh # 字符串放进文件中
$ source test.sh # 执行
Hello World 
$ . test.sh # 同上执行
Hello World

# '' 和 ""区别
ubuntu2018@linux:~$ echo $HOME
/home/ubuntu2018
ubuntu2018@linux:~$ echo '$HOME'
$HOME
ubuntu2018@linux:~$ echo "$HOME"
/home/ubuntu2018
同样是$HOME,单引号会直接认为是字符,而双引号认为是一个变量

符号 说明
\n 表示新的一行
\r 表示回车
\t 表示水平制表符
\v 表示垂直制表符
\b 表示后退符
\a 表示"alert"(蜂鸣或者闪烁)
\0xx 转换为八进制的ASCII码, 等价于0xx
" 表示引号字面的意思

`反引号
Shell中可以将数字或字符直接赋予变量,也可以将Linux命令的执行结果赋予变量,如下：
(1) $ count=9           #将数字赋予变量count
(2) $ name="ming"  #将字符赋予变量name
(3) $ listc=`ls -la`     #将Linux命令赋予listc,listc的值就是该命令的执行结果
(4)$ echo "$listc" 
# 执行

反引号中的命令会优先执行,如：
$ cp `mkdir back` test.sh back
$ ls

# bash判断方式
-eq # 检测两个数是否相等,相等返回 true
-ne # 检测两个数是否相等,不相等返回 true
-gt # 大于号, true
-lt # 小于号 ,true
-ge # 大于等于,true 
-le # 小于等于,true 


condition=5
if [ $condition -gt 0 ] #gt表示greater than,-gt(大于),同样有-lt(小于),-eq(等于) 注意if、[、后加空格还有]前加空格不然会报错
then :   # 什么都不做,退出分支(注意：前需要加空格不然会报错)
else
    echo "$condition"
fi

# 清空文件内容
$ : > test.sh   # 文件“test.sh”现在被清空了
$ echo '' > test.sh # 同上清空文件
# 与 cat /dev/null > test.sh 的作用相同
# 然而,这并不会产生一个新的进程, 因为“:”是一个内建命令
$ : This is a comment that generates an error,( if [ $x -eq 3] )


$ vim test20.sh
输入代码：
#!/bin/bash

a=123
( a=321; )

echo "$a" #a的值为123而不是321,因为括号将判断为局部变量
运行代码：
$ bash test20.sh
a = 123
在圆括号中 a 变量,更像是一个局部变量。



在一个双括号结构中,? 就是C语言的三元操作符,如：
$ vim test.sh
#!/bin/bash # 解释文件
a=10 # 变量
(( t=a<50?8:9 )) # 对返8错返9
echo $t
运行测试
$ bash test.sh
8

2.初始化数组
创建数组

$ vim test21.sh
输入代码：

#!/bin/bash

arr=(1 4 5 7 9 21)
echo ${arr[3]} # get a value of arr
运行代码：

$ bash test21.sh
7


变量替换
前面已经用到了

$ vim test.sh
#!/bin/bash

var1=5
var2=23skidoo

echo $var1     # 5
echo $var2     # 23skidoo
运行测试

$ bash test.sh
5
23skidoo


文件名扩展
复制 t.txt 的内容到 t.back 中
$ vim test22.sh
输入代码：
#!/bin/bash
if [ ! -w 't.txt' ];
then
    touch t.txt
fi
echo 'test text' >> t.txt
cp t.{txt,back}
运行代码：
$ bash test22.sh
查看运行结果：
$ ls
结果为：新建t.txt 和t.back并添加字符串
$ cat t.txt # 查看文件
$ cat t.back # 查看文件

注意： 在大括号中,不允许有空白,除非这个空白被引用或转义。

2.代码块
代码块,又被称为内部组,这个结构事实上创建了一个匿名函数(一个没有名字的函数)。然而,与“标准”函数不同的是,在其中声明的变量,对于脚本其他部分的代码来说还是可见的。
$ vim test23.sh
输入代码：
#!/bin/bash
a=123
{ a=321; }
echo "a = $a"
运行代码：
$ bash test23.sh
a = 321
变量 a 的值被更改了。



1.条件测试中括号[]
条件测试表达式放在[ ]中。下列练习中的-lt (less than)表示小于号。
$ vim test24.sh
输入代码：
#!/bin/bash
a=5
if [ $a -lt 10 ]
then
    echo "a: $a"
else
    echo 'a>10'
fi
运行代码：
$ bash test24.sh
a: 5
双中括号([[ ]])也用作条件测试(判断),后面的实验会详细讲解。

2.数组元素
在一个array结构的上下文中,中括号用来引用数组中每个元素的编号。
$ vim test25.sh
输入代码：
#!/bin/bash
arr=(12 22 32)
arr[0]=10
echo ${arr[0]}
运行代码：
$ bash test25.sh
10

重定向
test.sh > filename：重定向test.sh的输出到文件 filename 中。如果 filename 存在的话,那么将会被覆盖。

test.sh &> filename：重定向 test.sh 的 stdout(标准输出)和 stderr(标准错误)到 filename 中。

test.sh >&2：重定向 test.sh 的 stdout 到 stderr 中。

test.sh >> filename：把 test.sh 的输出追加到文件 filename 中。如果filename 不存在的话,将会被创建。


管道
分析前边命令的输出,并将输出作为后边命令的输入。这是一种产生命令链的好方法。
$ vim test26.sh
输入代码：
#!/bin/bash
tr 'a-z' 'A-Z' # 小写替换成大写
exit 0
现在让我们输送ls -l的输出到一个脚本中：
$ chmod 755 test26.sh # r4w2x1 r4x1 r4x1
$ ls -l | ./test26.sh # 输入所有文件
输出的内容均变为了大写字母。

1.选项,前缀
在所有的命令内如果想使用选项参数的话,前边都要加上“-”。

$ vim test27.sh
输入代码：

#!/bin/bash

a=5
b=5
if [ "$a" -eq "$b" ]
then
    echo "a is equal to b."
else
	echo "a not equal to b."
fi
运行代码：

$ bash test27.sh
a is equal to b.
2.用于重定向stdin或stdout
下面脚本用于备份最后24小时当前目录下所有修改的文件.

$ vim test28.sh
输入代码：

#!/bin/bash

BACKUPFILE=backup-$(date +%m-%d-%Y)
# 在备份文件中嵌入时间.
archive=${1:-$BACKUPFILE}
#  如果在命令行中没有指定备份文件的文件名,
#  那么将默认使用"backup-MM-DD-YYYY.tar.gz".

tar cvf - `find . -mtime -1 -type f -print` > $archive.tar
gzip $archive.tar
echo "Directory $PWD backed up in archive file \"$archive.tar.gz\"."

exit 0
运行代码：

$ bash test28.sh
$ ls



变量和参数
1.概念
变量的名字就是变量保存值的地方。引用变量的值就叫做变量替换。

如果 variable 是一个变量的名字,那么 $variable 就是引用这个变量的值,即这变量所包含的数据。

$variable 事实上只是 ${variable} 的简写形式。在某些上下文中 $variable 可能会引起错误,这时候你就需要用 ${variable} 了。

2.定义变量
定义变量时,变量名不加美元符号($,PHP语言中变量需要),如： myname="shiyanlou"

注意

变量名和等号之间不能有空格。同时,变量名的命名须遵循如下规则：

首个字符必须为字母(a-z,A-Z)。
中间不能有空格,可以使用下划线(_)。
不能使用标点符号。
不能使用bash里的关键字(可用help命令查看保留关键字)。
除了直接赋值,还可以用语句给变量赋值,如：for file in `ls /etc`


使用 readonly 命令可以将变量定义为只读变量,只读变量的值不能被改变。 下面的例子尝试更改只读变量,结果报错：

#!/bin/bash
myUrl="http://www.shiyanlou.com"
readonly myUrl
myUrl="http://www.shiyanlou.com"
运行脚本,结果如下：

/bin/sh: NAME: This variable is read only.


运算符	说明
-z		字符串长度为0,返回true
-N		字符串长度不为0,返回true
str		字符串不为空,返回true

linux shell 之if-------用if做判断
2013年08月22日 14:54:14 crazyhacking 阅读数：89831
综合网络,略有修改,

一 简介 

1 字符串判断

str1 = str2　　　　　　当两个串有相同内容、长度时为真 
str1 != str2　　　　　 当串str1和str2不等时为真 
-n str1　　　　　　　 当串的长度大于0时为真(串非空) 
-z str1　　　　　　　 当串的长度为0时为真(空串) 
str1　　　　　　　　   当串str1为非空时为真

\ >  \ <                               比较大小的时候 可以使用大于号,小于号,但是需转义。例如 [ "2006.01.23" \> "2005.03.01" ] && echo dayu || echo budayu

2 数字的判断

int1 -eq int2　　　　两数相等为真 
int1 -ne int2　　　　两数不等为真 
int1 -gt int2　　　　int1大于int2为真 
int1 -ge int2　　　　int1大于等于int2为真 
int1 -lt int2　　　　int1小于int2为真 
int1 -le int2　　　　int1小于等于int2为真

3 文件的判断

-e file 如果 filename存在,则为真
-r file 用户可读为真 
-w file 用户可写为真 
-x file 用户可执行为真 
-f file 文件为正规文件为真 
-d file 文件为目录为真 
-c file 文件为字符特殊文件为真 
-b file 文件为块特殊文件为真 
-s file 文件大小非0时为真 
-t file 当文件描述符(默认为1)指定的设备为终端时为真

-e filename 如果 filename存在,则为真
-d filename 如果 filename为目录,则为真
-f filename 如果 filename为常规文件,则为真
-L filename 如果 filename为符号链接,则为真
-r filename 如果 filename可读,则为真
-w filename 如果 filename可写,则为真
-x filename 如果 filename可执行,则为真
-s filename 如果文件长度不为0,则为真
-h filename 如果文件是软链接,则为真
filename1 -nt filename2 如果 filename1比 filename2新,则为真。
filename1 -ot filename2 如果 filename1比 filename2旧,则为真。
-eq 等于
-ne 不等于
-gt 大于
-ge 大于等于
-lt 小于

3 复杂逻辑判断

-a 　 　　　　　 与 
-o　　　　　　　 或 
!　　　　　　　　非


上面的三种写在括号内,对应的 && || 写在中括号之间。例如,if  [   "$a"  eq   1  -o  "$b" eq 2 ]  &&  [   "$c"  eq  3 ]
4字符串匹配
if [  `echo $str | grep -e regexp`  ];then .

转自：http://hi.baidu.com/ryouaki/item/0689dcb8a467b5a7eaba9319

二 具体使用
比较两个字符串是否相等的办法是：

    if [ "$test"x = "test"x ]; then

    这里的关键有几点：

    1 使用单个等号

    2 注意到等号两边各有一个空格：这是unix shell的要求

    3 注意到"$test"x最后的x,这是特意安排的,因为当$test为空的时候,上面的表达式就变成了x = testx,显然是不相等的。而如果没有这个x,表达式就会报错：[: =: unary operator expected

    

    二元比较操作符,比较变量或者比较数字.注意数字与字符串的区别.

    整数比较 需要注意的是 要么使用[]和gt组合 要么使用大于号和双括号组合

    -eq 等于,如:if [ "$a" -eq "$b" ]

    -ne 不等于,如:if [ "$a" -ne "$b" ]

    -gt 大于,如:if [ "$a" -gt "$b" ]

    -ge 大于等于,如:if [ "$a" -ge "$b" ]

    -lt 小于,如:if [ "$a" -lt "$b" ]

    -le 小于等于,如:if [ "$a" -le "$b" ]

     大于(需要双括号),如:(("$a" > "$b"))

    >= 大于等于(需要双括号),如:(("$a" >= "$b"))

    小数据比较可使用AWK

    字符串比较

    = 等于,如:if [ "$a" = "$b" ]

    == 等于,如:if [ "$a" == "$b" ],与=等价

     注意:==的功能在[[]]和[]中的行为是不同的,如下:

     1 [[ $a == z* ]] # 如果$a以"z"开头(模式匹配)那么将为true

     2 [[ $a == "z*" ]] # 如果$a等于z*(字符匹配),那么结果为true

     3

     4 [ $a == z* ] # File globbing 和word splitting将会发生

     5 [ "$a" == "z*" ] # 如果$a等于z*(字符匹配),那么结果为true

     一点解释,关于File globbing是一种关于文件的速记法,比如"*.c"就是,再如~也是.

     但是file globbing并不是严格的正则表达式,虽然绝大多数情况下结构比较像.

    != 不等于,如:if [ "$a" != "$b" ]

     这个操作符将在[[]]结构中使用模式匹配.

     大于,在ASCII字母顺序下.如:

     if [[ "$a" > "$b" ]]

     if [ "$a" \> "$b" ]

     注意:在[]结构中">"需要被转义.

     具体参考Example 26-11来查看这个操作符应用的例子.

    -z 字符串为"null".就是长度为0.

    -n 字符串不为"null"

     注意:

     使用-n在[]结构中测试必须要用""把变量引起来.使用一个未被""的字符串来使用! -z

     或者就是未用""引用的字符串本身,放到[]结构中。虽然一般情况下可

     以工作,但这是不安全的.习惯于使用""来测试字符串是一种好习惯.

if判断式
if [ 条件判断一 ] && (||) [ 条件判断二 ]; then
elif [ 条件判断三 ] && (||) [ 条件判断四 ]; then
else
   执行第三段內容程式
fi

例如：

 

root@Bizbox:~# a=0
root@Bizbox:~# b=0
root@Bizbox:~# c=5         
root@Bizbox:~# if [ $a = 0 -a $b = 0 ]&&[ $c != 0 ]; then
> echo success
> fi
success
if 使用的表达
http://www.cnblogs.com/276815076/archive/2011/10/30/2229286.html



算数运算符方法
$vim test.sh
#!/bin/bash

a=10
b=20

val=`expr $a + $b`
echo "a + b : $val"

val=`expr $a - $b`
echo "a - b : $val"

val=`expr $a \* $b`
echo "a * b : $val"

val=`expr $b / $a`
echo "b / a : $val"

val=`expr $b % $a`
echo "b % a : $val"

if [ $a == $b ]
then
   echo "a == b"
fi
if [ $a != $b ]
then
   echo "a != b"
fi
运行

$bash test.sh
a + b : 30
a - b : -10
a * b : 200
b / a : 2
b % a : 0
a != b
原生bash不支持简单的数学运算,但是可以通过其他命令来实现,例如 awk 和 expr,expr 最常用。
expr 是一款表达式计算工具,使用它能完成表达式的求值操作。
注意使用的反引号(esc键下边)
表达式和运算符之间要有空格$a + $b写成$a+$b不行
条件表达式要放在方括号之间,并且要有空格[ $a == $b ]写成[$a==$b]不行
乘号(*)前边必须加反斜杠(\)才能实现乘法运算

和Java、PHP等语言不一样,sh的流程控制不可为空

在sh/bash里可不能这么写,如果else分支没有语句执行,就不要写这个else。

1.if
if 语句语法格式：

if condition
then
    command1 
    command2
    ...
    commandN 
fi
2.if else
if else 语法格式：

if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi
if-elif-else 语法格式：

if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
以下实例判断两个变量是否相等：

a=10
b=20
if [ $a == $b ]
then
   echo "a == b"
elif [ $a -gt $b ]
then
   echo "a > b"
elif [ $a -lt $b ]
then
   echo "a < b"
else
   echo "Ineligible"
fi
输出结果：

a < b
if else语句经常与test命令结合使用

num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
    echo 'Two numbers are equal!'
else
    echo 'The two numbers are not equal!'
fi
输出结果：

Two numbers are equal!


for循环一般格式为：

for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
例如,顺序输出当前列表中的数字：

for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done
输出结果：

The value is: 1
The value is: 2
The value is: 3
The value is: 4
The value is: 5
顺序输出字符串中的字符：

for str in This is a string
do
    echo $str
done
输出结果：

This
is
a
string



while循环用于不断执行一系列命令,也用于从输入文件中读取数据；命令通常为测试条件。其格式为：

while condition
do
    command
done
#!/bin/bash
int=1
while(( $int<=5 )) # 必须要两个小括号代表判断条件
do
    echo $int
    let "int++"
done
运行脚本,输出：

1
2
3
4
5
如果int小于等于5,那么条件返回真。int从1开始,每次循环处理时,int加1。运行上述脚本,返回数字1到5,然后终止。
使用了 Bash let 命令,它用于执行一个或多个表达式,变量计算中不需要加上 $ 来表示变量
while循环可用于读取键盘信息。下面的例子中,输入信息被设置为变量MAN,按结束循环。
echo 'press <CTRL-D> exit'
echo -n 'Who do you think is the most handsome: '
while read MAN # read读取键盘 MAN是变量
do
    echo "Yes！$MAN is really handsome"
done


无限循环语法格式：

while :
do
    command
done
或者
while true
do
    command
done
或者

for (( ; ; ))

until循环执行一系列命令直至条件为真时停止。 until循环与while循环在处理方式上刚好相反。 一般while循环优于until循环,但在某些时候—也只是极少数情况下,until循环更加有用。 until 语法格式:

until condition
do
    command
done
条件可为任意测试条件,测试发生在循环末尾,因此循环至少执行一次—请注意这一点。

下一步
Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式,如果匹配成功,执行相匹配的命令。case语句格式如下：

case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2)
    command1
    command2
    ...
    commandN
    ;;
esac
取值后面必须为单词in,每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后,其间所有命令开始执行直至 ;;。
取值将检测匹配的每一个模式。一旦模式匹配,则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式,使用星号 * 捕获该值,再执行后面的命令。
下面的脚本提示输入1到4,与每一种模式进行匹配：

echo 'Enter a number between 1 and 4:'
echo 'The number you entered is:'
read aNum
case $aNum in
    1)  echo 'You have chosen 1'
    ;;
    2)  echo 'You have chosen 2'
    ;;
    3)  echo 'You have chosen 3'
    ;;
    4)  echo 'You have chosen 4'
    ;;
	# *)表示其他选项
    *)  echo 'You did not enter a number between 1 and 4'
    ;;
esac
输入不同的内容,会有不同的结果,例如：

Enter a number between 1 and 4:
The number you entered is:
3
You have chosen 3
下一步
在循环过程中,有时候需要在未达到循环结束条件时强制跳出循环,Shell使用两个命令来实现该功能：break和continue。

break命令

break命令允许跳出所有循环(终止执行后面的所有循环)。 下面的例子中,脚本进入死循环直至用户输入数字大于5。要跳出这个循环,返回到shell提示符下,需要使用break命令。

#!/bin/bash
while :
do
    echo -n "Enter a number between 1 and 5:"
    read aNum
    case $aNum in
        1|2|3|4|5) echo "The number you entered is $aNum!"
        ;;
        *) echo "The number you entered is not between 1 and 5! game over!"
            break
        ;;
    esac
done
执行以上代码,输出结果为：

Enter a number between 1 and 5:3
The number you entered is 3!
Enter a number between 1 and 5:7
The number you entered is not between 1 and 5! game over!
下一步
continue命令与break命令类似,只有一点差别,它不会跳出所有循环,仅仅跳出当前循环。 对上面的例子进行修改：

#!/bin/bash
while :
do
    echo -n "Enter a number between 1 and 5: "
    read aNum
    case $aNum in
        1|2|3|4|5) echo "The number you entered is $aNum!"
        ;;
        *) echo "The number you entered is not between 1 and 5!"
            continue
            echo "game over"
        ;;
    esac
done
运行代码发现,当输入大于5的数字时,该例中的循环不会结束,语句 echo "Game is over!" 永远不会被执行。

下一步
case的语法和C family语言差别很大,它需要一个esac(就是case反过来)作为结束标记,每个case分支用右圆括号,用两个分号表示break。

下一步
一、写一个脚本

(1) 提示用户输入一个字符串；

(2) 判断：

如果输入的是quit,则退出脚本；

否则,则显示其输入的字符串内容；

二、有一个８升的瓶子装满水,还有一个５升的空瓶子和一个３升的空瓶子。要求将水分成两个４升。

运行脚本之后要生产类似这样的解决方案：

Your containers: 8     5     3

Solution1 step0: 8-->0-->0
Solution1 step1: 3-->5-->0
Solution1 step2: 3-->2-->3
Solution1 step3: 6-->2-->0
Solution1 step4: 6-->0-->2
Solution1 step5: 1-->5-->2
Solution1 step6: 1-->4-->3
Solution1 step7: 4-->4-->0
三、三角输出

编写bash脚本输出如图的三角 6-10-1

下一步

echo -n 'Who do you think is the most handsome: '
while read MAN
do
    echo "Yes！$MAN is really handsome"
done



$ echo -n 字符串  不输出尾随的换行符
$ echo -e 字符串  启用反斜杠转义的解释
$ echo -E 字符串  禁用反斜杠转义的解释(默认)

until循环执行一系列命令直至条件为真时停止。 until循环与while循环在处理方式上刚好相反。 一般while循环优于until循环,但在某些时候—也只是极少数情况下,until循环更加有用。 until 语法格式:

until condition
do
    command
done
条件可为任意测试条件,测试发生在循环末尾,因此循环至少执行一次—请注意这一点。


一、写一个脚本

(1) 提示用户输入一个字符串；

(2) 判断：

如果输入的是quit,则退出脚本；

否则,则显示其输入的字符串内容；
#!/bin/bash

echo '请输入字符串'
while read n 
do
	if [ $n == "quit" ]
	then
                echo "退出"
                break
	else
	        echo "$n"
	fi
done

bash 脚本中单行注释和多行注释方法：
# 这是注释 # 单行注释注释

#!/bin/bash
echo "Say Something"
<<COMMENT # 多行注释开始
    your comment 1
    comment 2
    blah
COMMENT # 多行注释结束
echo "Do something else"

shell中函数的定义格式如下：

[ function ] funname [()]

{

    action;

    [return int;]

}
说明：

可以带function fun() 定义,也可以直接fun() 定义,不带任何参数。
参数返回,可以显示加：return 返回,如果不加,将以最后一条命令运行结果,作为返回值。 return后跟数值n(0-255)
下面的例子定义了一个函数并进行调用：

#!/bin/bash

demoFun(){
    echo "This is my first shell function!"
}
echo "-----Execution-----"
demoFun
echo "-----Finished-----"


Output the result：
-----Execution-----
This is my first shell function!
-----Finished-----
下面定义一个带有return语句的函数：

#!/bin/bash
funWithReturn(){
    echo "This function will add the two numbers of the input..."
    echo "Enter the first number: "
    read aNum
    echo "Enter the second number: "
    read anotherNum
    echo "The two numbers are $aNum and $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "The sum of the two numbers entered is $? !"
输出类似下面：

This function will add the two numbers of the input...
Enter the first number: 
1
Enter the second number: 
2
The two numbers are 1 and  2 !
The sum of the two numbers entered is 3 !
函数返回值在调用该函数后通过 $? 来获得
所有函数在使用前必须定义。

函数
一、函数定义
shell中函数的定义格式如下：

[ function ] funname [()]

{

    action;

    [return int;]

}
说明：

可以带function fun() 定义,也可以直接fun() 定义,不带任何参数。
参数返回,可以显示加：return 返回,如果不加,将以最后一条命令运行结果,作为返回值。 return后跟数值n(0-255)
下面的例子定义了一个函数并进行调用：

#!/bin/bash

demoFun(){
    echo "This is my first shell function!"
}
echo "-----Execution-----"
demoFun
echo "-----Finished-----"


Output the result：
-----Execution-----
This is my first shell function!
-----Finished-----
下面定义一个带有return语句的函数：

#!/bin/bash
funWithReturn(){
    echo "This function will add the two numbers of the input..."
    echo "Enter the first number: "
    read aNum
    echo "Enter the second number: "
    read anotherNum
    echo "The two numbers are $aNum and $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "The sum of the two numbers entered is $? !"
输出类似下面：

This function will add the two numbers of the input...
Enter the first number: 
1
Enter the second number: 
2
The two numbers are 1 and  2 !
The sum of the two numbers entered is 3 !
函数返回值在调用该函数后通过 $? 来获得
所有函数在使用前必须定义。
下一步
二、函数参数
在Shell中,调用函数时可以向其传递参数。在函数体内部,通过 $n 的形式来获取参数的值,例如,$1表示第一个参数,$2表示第二个参数... 带参数的函数示例：

#!/bin/bash
funWithParam(){
    echo "The first parameter is $1 !"
    echo "The second parameter is $2 !"
    echo "The tenth parameter is $10 !"
    echo "The tenth parameter is ${10} !"
    echo "The eleventh parameter is ${11} !"
    echo "The total number of parameters is $# !"
    echo "Outputs all parameters as a string $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
输出结果：

The first parameter is 1 !
The second parameter is 2 !
The tenth parameter is 10 !
The tenth parameter is 34 !
The eleventh parameter is 73 !
The total number of parameters is 11 !
Outputs all parameters as a string 1 2 3 4 5 6 7 8 9 34 73 !
注意

$10 不能获取第十个参数,获取第十个参数需要${10}。当n>=10时,需要使用${n}来获取参数。

下一步
三、思考
猜数字游戏：

首先让系统随机生成一个数字,给这个数字一个范围,让用户猜数字,对输入作出判断,并且给出提示。

请用while语句实现。

下一步

比赛规则 
1. 仔细阅读题目描述,在实验环境中完成任务

2. 完成任务后点击桌面右方的提交结果按钮

3. 系统自动评测并给出是否通过的信息

挑战：历史命令
介绍
在 Linux 中,对于文本的处理和分析是极为重要的,现在有一个文件叫做 data1,可以使用下面的命令下载：

$ cd /home/shiyanlou
$ wget http://labfile.oss.aliyuncs.com/courses/1/data1
data1 文件里记录是一些命令的操作记录,现在需要你从里面找出出现频率次数前3的命令并保存在 /home/shiyanlou/result。

目标
处理文本文件 /home/shiyanlou/data1
将结果写入 /home/shiyanlou/result
结果包含三行内容,每行内容都是出现的次数和命令名称,如“100 ls”
提示
cut -c 3- # 自定义截取从第3个字符开始往后截取
cut -c 1-6 # 自定义截取从第1个字符开始到第6个字符结束截取
cut 截取 (使用 man cut 可以查看含义)
uniq -dc 去重
sort 的参数选择 -k1 -n -r
操作过程使用管道,例如：
$ cd /home/shiyanlou
$ cat data1 |....|....|....   >  /home/shiyanlou/result
来源
2016 年百度校招面试题

参考答案
注意：请务必自己独立思考解决问题之后再对照参考答案,一开始直接看参考答案收获不大。

cat data1 |cut -c 8-|sort|uniq -dc|sort -rn -k1 |head -3 > /home/shiyanlou/result
# cut -c 8- 自定义截取第8字符开始
# sort 默认a-z排序
# uniq -dc 先显示重复次数后显示重复行
# sort -rn 反转比较的结果,根据字符串数量比较
# -k1 通过键排序;KEYDEF给出位置和类型
# head -3 截取前3行数据
# > /home/shiyanlou/result # 前面内容保存在result文件中
# 2016年百度校招面试题

正则表达式优先级 | zzbds优先级
优先级
优先级为从上到下从左到右,依次降低：
运算符	说明
\	转义符
(), (?:), (?=), []	括号和中括号
*、+、?、{n}、{n,}、{n,m}	限定符
^、$、\任何元字符	定位点和序列
｜	选择

grep模式匹配命令
grep支持三种正则表达式引擎,分别用三个参数指定：
参数	说明
-E	POSIX扩展正则表达式,ERE
-G	POSIX基本正则表达式,BRE
-P	Perl正则表达式,PCRE
常用参数：	说明
-b	将二进制文件作为文本来进行匹配
-c	统计以模式匹配的数目
-i	忽略大小写
-n	显示匹配文本所在行的行号
-v	反选,输出不匹配行的内容
-r	递归匹配查找
-A n	n为正整数,表示after的意思,除了列出匹配行之外,还列出后面的n行
-B n	n为正整数,表示before的意思,除了列出匹配行之外,还列出前面的n行
--color=auto	将输出中的匹配项设置为自动颜色显示
示例：
$ cat test
shiyanlou
www.shiyanlou.com
C
linux
dat_struct
python
Mysql
shell
bash
unix
ubuntu2018@linux:~$ grep -c shiyanlou test
2
ubuntu2018@linux:~$ grep -i -n c test
2:www.shiyanlou.com
3:C
5:dat_struct
ubuntu2018@linux:~$ cat -n test 
     1	shiyanlou
     2	www.shiyanlou.com
     3	C
     4	linux
     5	dat_struct
     6	python
     7	Mysql
     8	shell
     9	bash
    10	unix
ubuntu2018@linux:~$ grep -v shell test
shiyanlou
www.shiyanlou.com
C
linux
dat_struct
python
Mysql
bash
unix
ubuntu2018@linux:~$ grep -v -n shell test
1:shiyanlou
2:www.shiyanlou.com
3:C
4:linux
5:dat_struct
6:python
7:Mysql
9:bash
10:unix
ubuntu2018@linux:~$ grep shel test 
shell

zzbdsff # 正则表达式用法
正则表达式的常用操作符
操作符 	说明								实例
.	   	表示任何单个字符
[]	   	字符集,对单个字符给出取值范围		[abc]表示a、b、c,[a-z]表示a到z单个字符
[^]		非字符集,对单个字符给出排除范围	[^abe]表示非a或b或c的单个字符
*		前一个字符0次或无限次扩展			abe*表示ab、abe、abec、abecc等
+		前一个字符1次或无限次扩展			abc+表示abc、abcc、abccc等
?		前一个字符0次或1次扩展				abc?表示ab、abc
|		左右表达式任意一个					abc|def 表示abc、def
{m}		扩展前一个字符m次					ab{2}c表示abbe
{m,n}	扩展前一个字符m至n次(含n)			ab{1,2}c表示abc、abbc
{M:n}	扩展前一个字符m至n次(含n)			ab{e:2}c表示ac、abc、abbc
^		匹配字符串开头						^abc表示abc且在一个字符串的开头
$		匹配字符串结尾						abc$表示abc且在一个字符串的结尾
()		分组标记,内部只能使用|操作符		(abe)表示abc,(abcldef)表示abe、def
\d		数字,等价于[e-9]
\w		单词字符,等价于[A-Za-ze-9_]
最小匹配操作符
操作符|说明
*?前一个字符e次或无限次扩展,最小匹配
+?前一个字符1次或无限次扩展,最小匹配
??前一个字符e次或1次扩展,最小匹配
{m,n}?扩展前一个字符m至n次(含n),最小匹配
group() # 打印匹配第几个()

[[].*[]]?[ ]  # 表示'[中间任意符号] ' 结尾是空格

zzbdszwff (正则表达式匹配中文方法)
经典正则表达式实例
^[A-Za-z]+$				由26个字母组成的字符串
^[A-Za-ze-9]+$			由26个字母和数字组成的字符串
^-?\d+$					整数形式的字符串
^[O-9]*[1-9][e-9]*$		正整数形式的字符串
[1-9]\d(5}				中国境内邮政编码,6位
[\u4eee-\u9fa5]			匹配中文字符
\d{3}-\d{8}|\d{4}-\d{7}	国内电话号码,e1e-68913536

匹配IP地址的正则表达式
IP地址字符串形式的正则表达式
(IP地址分4段,每段e-255)
精确写法
e-99：[1-9]?\d			1ee-199：1\d{2}
2ee-249：2[e-4]\d		25e-255：25[e-5]
(([1-9]?\d|1\d{2}|2[e-4]\d|25[e-5]).){3}([1-9]?\d|2[e-4]\d|25[e-5])
#相当如：*.*.*.* 

# grep默认是区分大小写的,这里将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[a-z]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[0-9]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[[:digit:]]'
# 将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[[:lower:]]'
# 将匹配所有的大写字母
$ echo '1234\nabcd' | grep '[[:upper:]]'
# 将匹配所有的字母和数字,包括0-9,a-z,A-Z
$ echo '1234\nabcd' | grep '[[:alnum:]]'
# 将匹配所有的字母
$ echo '1234\nabcd' | grep '[[:alpha:]]


三、grep模式匹配命令
grep命令用于打印输出文本中匹配的模式串,它使用正则表达式作为模式匹配的条件。grep支持三种正则表达式引擎,分别用三个参数指定：

参数	说明
-E	POSIX扩展正则表达式,ERE
-G	POSIX基本正则表达式,BRE
-P	Perl正则表达式,PCRE
不过在你没学过perl语言的大多数情况下你将只会使用到ERE和BRE,所以我们接下来的内容都不会讨论到PCRE中特有的一些正则表达式语法(它们之间大部分内容是存在交集的,所以你不用担心会遗漏多少重要内容)

在通过grep命令使用正则表达式之前,先介绍一下它的常用参数：

参数	说明
-b	将二进制文件作为文本来进行匹配
-c	统计以模式匹配的数目
-i	忽略大小写
-n	显示匹配文本所在行的行号
-v	反选,输出不匹配行的内容
-r	递归匹配查找
-A n	n为正整数,表示after的意思,除了列出匹配行之外,还列出后面的n行
-B n	n为正整数,表示before的意思,除了列出匹配行之外,还列出前面的n行
--color=auto	将输出中的匹配项设置为自动颜色显示
注：在大多数发行版中是默认设置了grep的颜色的,你可以通过参数指定或修改GREP_COLOR环境变量。

此处输入图片的描述

下一步
使用基本正则表达式,BRE
位置
查找/etc/group文件中以"shiyanlou"为开头的行

$ grep 'shiyanlou' /etc/group
$ grep '^shiyanlou' /etc/group
此处输入图片的描述

数量
# 将匹配以'z'开头以'o'结尾的所有字符串
$ echo 'zero\nzo\nzoo' | grep 'z.*o'
# 将匹配以'z'开头以'o'结尾,中间包含一个任意字符的字符串
$ echo 'zero\nzo\nzoo' | grep 'z.o'
# 将匹配以'z'开头,以任意多个'o'结尾的字符串
$ echo 'zero\nzo\nzoo' | grep 'zo*'
注意：其中\n为换行符

此处输入图片的描述

选择
# grep默认是区分大小写的,这里将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[a-z]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[0-9]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[[:digit:]]'
# 将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[[:lower:]]'
# 将匹配所有的大写字母
$ echo '1234\nabcd' | grep '[[:upper:]]'
# 将匹配所有的字母和数字,包括0-9,a-z,A-Z
$ echo '1234\nabcd' | grep '[[:alnum:]]'
# 将匹配所有的字母
$ echo '1234\nabcd' | grep '[[:alpha:]]'
此处输入图片的描述

下面包含完整的特殊符号及说明：

特殊符号	说明
[:alnum:]	代表英文大小写字母及数字,亦即 0-9, A-Z, a-z
[:alpha:]	代表任何英文大小写字母,亦即 A-Z, a-z
[:blank:]	代表空白键与 [Tab] 按键两者
[:cntrl:]	代表键盘上面的控制按键,亦即包括 CR, LF, Tab, Del.. 等等
[:digit:]	代表数字而已,亦即 0-9
[:graph:]	除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键
[:lower:]	代表小写字母,亦即 a-z
[:print:]	代表任何可以被列印出来的字符
[:punct:]	代表标点符号 (punctuation symbol),亦即：" ' ? ! ; : # $...
[:upper:]	代表大写字母,亦即 A-Z
[:space:]	任何会产生空白的字符,包括空白键, [Tab], CR 等等
[:xdigit:]	代表 16 进位的数字类型,因此包括： 0-9, A-F, a-f 的数字与字节
注意：之所以要使用特殊符号,是因为上面的[a-z]不是在所有情况下都管用,这还与主机当前的语系有关,即设置在LANG环境变量的值,zh_CN.UTF-8的话[a-z],即为所有小写字母,其它语系可能是大小写交替的如,"a A b B...z Z",[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响,使用[:lower:]则不会有这个问题。

# 排除字符
$ $ echo 'geek\ngood' | grep '[^o]'
注意:当^放到中括号内为排除字符,否则表示行首。

此处输入图片的描述

使用扩展正则表达式,ERE
要通过grep使用扩展正则表达式需要加上-E参数,或使用egrep。

数量
# 只匹配"zo"
$ echo 'zero\nzo\nzoo' | grep -E 'zo{1}'
# 匹配以"zo"开头的所有单词
$ echo 'zero\nzo\nzoo' | grep -E 'zo{1,}'
注意：推荐掌握{n,m}即可,+,?,*,这几个不太直观,且容易弄混淆。

选择
# 匹配"www.shiyanlou.com"和"www.google.com"
$ echo 'www.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -E 'www\.(shiyanlou|google)\.com'
# 或者匹配不包含"baidu"的内容
$ echo 'www.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -Ev 'www\.baidu\.com'
注意：因为.号有特殊含义,所以需要转义。

此处输入图片的描述

关于正则表达式和grep命令的内容就介绍这么多,下面会介绍两个更强大的工具sed和awk,但同样也正是因为这两个工具的强大,我们的内容无法包含它们的全部,这里将只对基本内容作介绍。



sed 流编辑器
sed 全称为：“ "sed - stream editor for filtering and transforming text ”
vi/vim(编辑器之神)","emacs(神的编辑器)","gedit"这些个编辑器。

sed 命令基本格式：
sed [参数]... [执行命令] [输入文件]...
# 形如：
$ sed -i 's/sad/happy/' test # 表示将test文件中的"sad"替换为"happy"
参数	说明
-n	安静模式,只打印受影响的行,默认打印输入数据的全部内容
-e	用于在脚本中添加多个执行命令一次执行,在命令行中执行多个命令通常不需要加该参数
-f filename	指定执行filename文件中的命令
-r	使用扩展正则表达式,默认为标准正则表达式
-i	将直接修改输入文件内容,而不是打印到标准输出设备

sed执行命令格式：

[n1][,n2]command
[n1][~step]command
# 其中一些命令可以在后面加上作用范围,形如：
$ sed -i 's/sad/happy/g' test # g表示全局范围
$ sed -i 's/sad/happy/4' test # 4表示指定行中的第四个匹配字符串
其中n1,n2表示输入内容的行号,它们之间为,逗号则表示从n1到n2行,如果为～波浪号则表示从n1开始以step为步进的所有行；command为执行动作,下面为一些常用动作指令：

命令	说明
s	行内替换
c	整行替换
a	插入到指定行的后面
i	插入到指定行的前面
p	打印指定行,通常与-n参数配合使用
d	删除指定行

sudo find /路径 -name 文件名 # 查找文件方法
nl 文件名 输出列加上编号

4.3 sed操作举例
练习的文本文件
$ cp /etc/passwd ~ #文件拷贝家目录下
打印指定行
# 打印2-5行
$ nl passwd | sed -n '2,5p'
# 打印奇数行(1,3,5行打印)
$ nl passwd | sed -n '1~2p'

行内替换
# 将输入文本中"shiyanlou" 全局替换为"hehe",并只打印替换的那一行,注意这里不能省略最后的"p"命令
$ sed -n 's/shiyanlou/hehe/gp' passwd # 打印passwd文件第30行shiyanlou替换成hehe

行间替换
$ nl passwd | grep "shiyanlou"
# 删除第21行
$ sed -n '21c\www.shiyanlou.com' passwd
(这里我们只把要删的行打印出来了,并没有真正的删除,如果要删除的话,请使用-i参数)
此处输入图片的描述

关于sed命令就介绍这么多,你如果希望了解更多sed的高级用法,你可以参看如下链接：

sed简明教程
sed单行脚本快速参考
sed完全手册

AWK是一种优良的文本处理工具
ubuntu2018@linux:~$ whereis awk
awk: /usr/bin/awk /usr/share/man/man1/awk.1.gz
ubuntu2018@linux:~$ ll /usr/bin/awk
lrwxrwxrwx 1 root root 21 12月 14 20:03 /usr/bin/awk -> /etc/alternatives/awk*
ubuntu2018@linux:~$ ll /usr/bin/mawk
-rwxr-xr-x 1 root root 125416 4月   3  2018 /usr/bin/mawk*

awk命令基础格式
awk [-F fs] [-v var=value] [-f prog-file | 'program text'] [file...]
其中-F参数用于预先指定前面提到的字段分隔符(还有其他指定字段的方式) ,-v用于预先为awk程序指定变量,-f参数用于指定awk命令要执行的程序文件,或者在不加-f参数的情况下直接将程序语句放在这里,最后为awk需要处理的文本输入,且可以同时输入多个文本文件。现在我们还是直接来具体体验一下吧。

ubuntu2018@linux:~$ echo -e "I like linux\nwww.shiyanlou.com" > test
ubuntu2018@linux:~$ cat test
I like linux
www.shiyanlou.com


ubuntu2018@linux:~$ awk '{quote
> print}' test
I like linux
www.shiyanlou.com
ubuntu2018@linux:~$ awk '{print}' test
I like linux
www.shiyanlou.com

变量名	说明
FILENAME	当前输入文件名,若有多个文件,则只表示第一个。如果输入是来自标准输入,则为空字符串
$0	当前记录的内容
$N	N表示字段号,最大值为NF变量的值
FS	字段分隔符,由正则表达式表示,默认为" "空格
RS	输入记录分隔符,默认为"\n",即一行为一个记录
NF	当前记录字段数
NR	已经读入的记录数
FNR	当前输入文件的记录数,请注意它与NR的区别
OFS	输出字段分隔符,默认为" "空格
ORS	输出记录分隔符,默认为"\n"
关于awk的内容本课程将只会包含这些内容,如果你想了解更多,请期待后续课程,或者参看一下链接内容：

awk程序设计语言
https://awk.readthedocs.io/en/latest/chapter-one.html
awk简明教程
https://coolshell.cn/articles/9070.html
awk用户指南
http://www.gnu.org/software/gawk/manual/gawk.html



挑战：数据提取
介绍
小明在做数据分析的时候需要提取文件中关于数字的部分,同时还要提取用户的邮箱部分,但是有的行不是数组也不是邮箱,现在需要你在 data2 这个文件中帮助他用正则表达式匹配出数字部分和邮箱部分。

数据文件可以使用以下命令下载：

$ cd /home/shiyanlou
$ wget http://labfile.oss.aliyuncs.com/courses/1/data2
下载后的数据文件路径为 /home/shiyanlou/data2。

目标
在文件 /home/shiyanlou/data2 中匹配数字开头的行,将所有以数字开头的行都写入 /home/shiyanlou/num 文件。
在文件 /home/shiyanlou/data2 中匹配出正确格式的邮箱,将所有的邮箱写入 /home/shiyanlou/mail 文件,注意该文件中每行为一个邮箱。
提示
邮箱的格式匹配
注意符号 . 的处理
来源
2016 年 TapFun 校招面试题

参考答案
注意：请务必自己独立思考解决问题之后再对照参考答案,一开始直接看参考答案收获不大。

$ grep '^[0-9]' /home/shiyanlou/data2 > /home/shiyanlou/num


$ grep -E '^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$' /home/shiyanlou/data2 > /home/shiyanlou/mail
有BUG,单简便$ grep '^[0-9].*@.*' data2 > mail

Linux下软件安装
w3m是一个命令行的简易网页浏览器
$ sudo apt-get install w3m
$ w3m www.shiyanlou.com/faq

$ source ~/.zshrc # 执行命令补全
注意:如果你在安装一个软件之后,无法立即使用Tab键补全这个命令,你可以尝试先执行source ~/.zshrc,然后你就可以使用补全操作。

APT是Advance Packaging Tool(高级包装工具)
apt-get 应用程序管理器
apt-get,是一条linux命令,适用于deb包管理式的操作系统,主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。
apt-cache是linux下的一个apt软件包管理工具,它可查询apt的二进制软件包缓存文件。APT包管理的大多数信息查询功能都可以由apt-cache命令实现,通过apt-cache命令配合不同的子命令和参数的使用,可以实现查找,显示软件包信息及包依赖关系等功能.
apt-cdrom命令用于扫描Debian安装光盘信息,也将安装光盘做为安装源添加到sources.list里.

apt-get 是用于处理 apt包的公用程序集,我们可以用它来在线安装、卸载和升级软件包等,下面列出一些apt-get包含的常用的一些工具：

工具	说明
install	其后加上软件包名,用于安装一个软件包
update	从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表
upgrade	升级本地可更新的全部软件包,但存在依赖问题时将不会升级,通常会在更新之前执行一次update(更新本地所有安装包)
dist-upgrade	解决依赖关系并升级(存在一定危险性)
remove	移除已安装的软件包,包括与被移除软件包有依赖关系的软件包,但不包含软件包的配置文件
autoremove	移除之前被其他软件包依赖,但现在不再被使用的软件包(卸载安装包)
purge	与remove相同,但会完全移除软件包,包含其配置文件(卸载安装包包括配置文件)
clean	移除下载到本地的已经安装的软件包,默认保存在/var/cache/apt/archives/
autoclean	移除已安装的软件的旧版本软件包(卸载旧版本安装包)
下面是一些apt-get常用的参数：

参数	说明
-y	自动回应是否安装软件包的选项,在一些自动化安装脚本中使用这个参数将十分有用
-s	模拟安装
-q	静默安装方式,指定多个q或者-q=#,#表示数字,用于设定静默级别,这在你不想要在安装软件包时屏幕输出过多时很有用
-f	修复损坏的依赖关系(修复安装相关程序)
-d	只下载不安装
--reinstall	重新安装已经安装但可能存在问题的软件包(重新安装安装包)
--install-suggests	同时安装APT给出的建议安装的软件包
下一步

$ sudo apt-get --reinstall install 安装包名称  # 重新安装已经安装但可能存在问题的软件包(重新安装安装包)

# 更新软件源
$ sudo apt-get update
# 升级没有依赖问题的软件包
$ sudo apt-get upgrade
# 升级并解决依赖关系
$ sudo apt-get dist-upgrade

卸载安装包
sudo apt-get remove w3m 
# 不保留配置文件的移除
$ sudo apt-get purge w3m
# 或者 sudo apt-get --purge remove
# 移除不再需要的被依赖的软件包
$ sudo apt-get autoremove

ubuntu卸载python2和升级python3.5
卸载python只需一条语句就可以实现
sudu apt-get remove python
ubuntu下安装python3
sudo apt-get install python3
但这样只安装了python3.4
要想使用python3.5,则必须升级python3.4
sudo add-apt-repository ppa:fkrull/deadsnakes
sudo apt-get update
sudo apt-get install python3.5
使用以上三行命令便可升级python3.4到python3.5

sudo pip3 install --upgrade pip # 更新pip3

启动时要输入python3.5
输入python时启动的是python2.7
输入python3时启动的是python3.4
输入python3.5时启动的才是python3.5


安装包搜索
sudo apt-cache search softname1 softname2 softname3……
示例 sudo apt-cache search 安装包名称

使用 $ sudo dpkg -I 安装包名称 # 从本地磁盘安装(本地安装安装包) deb 软件包
我们经常可以在网络上见到以deb形式打包的软件包,就需要使用dpkg命令来安装。

dpkg常用参数介绍：
$ sudo dpkg -I 安装包名称 # 安装之前参看deb包的信息
参数	说明
-i	安装指定deb包
-R	后面加上目录名,用于安装该目录下的所有deb安装包
-r	remove,移除某个已安装的软件包
-I	显示deb包文件的信息
-s	显示已安装软件的信息
-S	搜索已安装的软件包
-L	显示已安装软件包的目录信息
下一步


ls /var/cache/apt/archives/ # 查看安装包信息
$ apt-get --help # 帮助
示例 $ apt-get download 安装包名(只下载不安装)
参数如下：
  update - 取回更新的软件包列表信息
  upgrade - 进行一次升级
  install - 安装新的软件包(注：软件包名称是 libc6 而非 libc6.deb)
  remove - 卸载软件包
  purge - 卸载并清除软件包的配置
  autoremove - 卸载所有自动安装且不再使用的软件包
  dist-upgrade - 发行版升级,见 apt-get(8)
  dselect-upgrade - 根据 dselect 的选择来进行升级
  build-dep - 为源码包配置所需的编译依赖关系
  clean - 删除所有已下载的包文件
  autoclean - 删除已下载的旧包文件
  check - 核对以确认系统的依赖关系的完整性
  source - 下载源码包文件
  download - 下载指定的二进制包到当前目录
  changelog - 下载指定软件包,并显示其变更日志(changelog)


使用dpkg -L查看deb包目录信息
$ sudo dpkg -L 安装包名 # 查看安装包项目目录

# aa for x小程序
$ sudo apt-get update
$ sudo apt-get install bb
$ /usr/games/bb

$ uptime # 查看系统运行多久时间(运行时间)
当前时间、系统运行时间、当前登录用户的数量、过去 1 分钟/5 分钟/15 分钟系统负载的均值。

08:34:29、 up 21 days, 5:46、 1 user、 load average: 0.06/ 0.04/0.00


$ pstree # 查看进程
$ ps －fxo user,ppid,pid,pgid,command # 其中 pid 就是该进程的一个唯一编号,ppid 就是该进程的父进程的 pid,command 表示的是该进程通过执行什么样的命令或者脚本而产生的

$ tail -f 绝对路径 # 实现动态查看日志
$ tail -f /var/log/dpkg.log # 查看日志
ctrl+z 停止
$ jobs # 查看停止日志信息


top 工具是我们常用的一个查看工具,能实时的查看我们系统的一些关键信息的变化:
$ top
内容	解释
top	表示当前程序的名称
11:05:18	表示当前的系统的时间
up 8 days,17:12	表示该机器已经启动了多长时间
1 user	表示当前系统中只有一个用户
load average: 0.29,0.20,0.25	分别对应1、5、15分钟内cpu的平均负载

#查看物理CPU的个数
#cat /proc/cpuinfo |grep "physical id"|sort |uniq|wc -l

#每个cpu的核心数
cat /proc/cpuinfo |grep "physical id"|grep "0"|wc -l
load average: 0.13(1分钟), 0.20(5分钟), 0.16(15分钟)
# 计算load average(平均负载)=  cpu个数*核心数/(0.5或0.7)

CPU核数和load average的关系网站：
https://blog.csdn.net/duzilonglove/article/details/80111753


$ top 
在上文我们曾经说过 top 是一个前台程序,所以是一个可以交互的

常用交互命令	解释
q	退出程序
I	切换显示平均负载和启动时间的信息
P	根据CPU使用百分比大小进行排序
M	根据驻留内存大小进行排序
i	忽略闲置和僵死的进程,这是一个开关式命令
k	终止一个进程,系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号,不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。
好好的利用 top 能够很有效的帮助我们观察到系统的瓶颈所在,或者是系统的问题所在。

$ ps aux # 将会罗列出所有的进程信息
$ ps aux | grep zsh # 查找其中的某个进程
$ ps axjf # 进程呈树状显示出来
$ ps -afxo user,ppid,pid,pgid,command # 自定义显示参数

这是一个简单而又实用的工具,想要更灵活的使用,想要知道更多的参数我们可以使用 man 来获取更多相关的信息


$ patree # 查看所有进程之间的相关性
$ pstree -up
#参数选择：
#-A  ：各程序树之间以 ASCII 字元來連接；
#-p  ：同时列出每个 process 的 PID；
#-u  ：同时列出每个 process 的所屬账户名称。

linux 日志系统
常见的日志一般存放在 /var/log 中
我们可以根据服务对象粗略的将日志分为两类

系统日志
应用日志

常见的系统日志有哪些,他们都记录了怎样的信息(常见日志)
日志名称	记录信息
alternatives.log	系统的一些更新替代信息记录
apport.log	应用程序崩溃信息记录
apt/history.log	使用 apt-get 安装卸载软件的信息记录
apt/term.log	使用 apt-get 时的具体操作,如 package 的下载、打开等
auth.log	登录认证的信息记录
boot.log	系统启动时的程序服务的日志信息
btmp	错误的信息记录
Consolekit/history	控制台的信息记录
dist-upgrade	dist-upgrade 这种更新方式的信息记录
dmesg	启动时,显示屏幕上内核缓冲信息,与硬件有关的信息
dpkg.log	dpkg 命令管理包的日志。
faillog	用户登录失败详细信息记录
fontconfig.log	与字体配置有关的信息记录
kern.log	内核产生的信息记录,在自己修改内核时有很大帮助
lastlog	用户的最近信息记录
wtmp	登录信息的记录。wtmp可以找出谁正在进入系统,谁使用命令显示这个文件或信息等
syslog	系统信息记录

$ ll //var/log  # 看看日志文件权限

在linux系统中在命令行中Bash中特有的字符串替换方式。
其中%是linux中shell中一般代表变量,其中linux系统中有系统变量和自定义变量。
其中有些事系统自带的变量如使用env命令显示所有的环境变量,还有一些是自己编写的变量,具体含义需要提前赋值。
其中系统变量如系统提供的参数称为位置参数。参数的值可以用$N得到,N是一个数字,如果为1,即$1。如果是%表示则为%1.
我举一个列子帮助理解：
假设一个变量：
x=abcdabcd
那么：
echo ${x/a/b} # 只替换第一个a为b,结果：
bbcdabcd
%echo ${x//a/b} # 将所有a替换为b,结果：
bbcdbbcd
其中不可以使用正则表达式, 只能用 * ? 等通配符。


$ sudo dhcilent  # 使用动态主机配置协议动态的配置网络接口的网络参数(自动获取ip地址)

cmd和linux的命令区别
功能					cmd		linux
复制文件				copy	cp
移动文件				move	mv
列举文件				dir		ls
清除屏幕				cls		clear
退出					exit	exit
显示修改日期			date	date
删除文件				del		rm
回响信息到屏幕			echo	echo
用编辑器编辑文件		edit	vi
比较文件内容			fc		diff
在文件中查找字符串		find	grep
显示命令帮助			命令/?	man 命令 whatis 
创建目录				mkdir	mkdir
新建文件	echo [文件内容]>*.*	touch
删除目录				rd		rmdir
目录更名				move	mv
拷贝目录				xcopy	copy
查看文件				more	less
重命名文件				ren		mv
切换目录				cd		cd
显示时间				time	date
显示已被使用的内存		mem		free
在屏幕打印文件内容		type	cat


ubuntu vim教程
90523291 root密码 
hjkl (强例推荐使用其移动光标,但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。
					 hjkl

Ctrl + s 停止向终端输出
Ctrl + q 即可恢复正常

Vim简明教程【CoolShell】
网址地址：https://blog.csdn.net/niushuai666/article/details/7275406

按了Ctrl + s后,vim停止向终端输出。
退出这种状态,按下Ctrl + q 



Click the Ubuntu Software icon in the Dock, or search for Software in the Activities search bar.
When Ubuntu Software lau



vim的学习曲线相当的大(参看各种文本编辑器的学习曲线),所以,如果你一开始看到的是一大堆VIM的命令分类,你一定会对这个编辑器失去兴趣的。下面的文章翻译自《Learn Vim Progressively》,我觉得这是给新手最好的VIM的升级教程了,没有列举所有的命令,只是列举了那些最有用的命令。非常不错。

——————————正文开始——————————

你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来,然后一点一点地学习各种戏法。

Vim the Six Billion Dollar editor

Better, Stronger, Faster.

学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了,非常地难学,但是却不可思议地好用。

我建议下面这四个步骤：

存活
感觉良好
觉得更好,更强,更快
使用VIM的超能力
当你走完这篇文章,你会成为一个vim的 superstar。

在开始学习以前,我需要给你一些警告：

学习vim在开始时是痛苦的。
需要时间
需要不断地练习,就像你学习一个乐器一样。
不要期望你能在3天内把vim练得比别的编辑器更有效率。
事实上,你需要2周时间的苦练,而不是3天。
第一级 – 存活
安装 vim
启动 vim
什么也别干！请先阅读
当你安装好一个编辑器后,你一定会想在其中输入点什么东西,然后看看这个编辑器是什么样子。但vim不是这样的,请按照下面的命令操作：

启 动Vim后,vim在 Normal 模式下。
让我们进入 Insert 模式,请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样,表示,你可以以插入的方式输入了)
此时,你可以输入文本了,就像你用“记事本”一样。
如果你想返回 Normal 模式,请按 ESC 键。
现在,你知道如何在 Insert 和 Normal 模式下切换了。下面是一些命令,可以让你在 Normal 模式下幸存下来：

i → Insert 模式,按 ESC 回到 Normal 模式.
x → 删当前光标所在的一个字符。
:wq → 存盘 + 退出 (:w 存盘, :q 退出)   (:w 文件名 # 另存为)
:wq! → 强制保存并退出
dd → 删除当前行,并把删除的行存到剪贴板里
p → 粘贴剪贴板
推荐:
普通模式下输入Shift+zz即可保存退出vim
普通模式命令	说明
x	删除游标所在的字符
X	删除游标所在前一个字符
Delete	同x
dd	删除整行
dw	删除一个单词（不适用中文）
dnw(n替换为相应数字) 表示删除n个单词
d$或D	删除至行尾
d^	删除至行首
dG	删除到文档结尾处
d1G	删至文档首部


hjkl (强例推荐使用其移动光标,但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。
:help <command> → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。(陈皓注：退出帮助需要输入:q)
你能在vim幸存下来只需要上述的那5个命令,你就可以编辑文本了,你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。

当是,在你进入第二级时,需要再说一下 Normal 模式。在一般的编辑器下,当你需要copy一段文字的时候,你需要使用 Ctrl 键,比如：Ctrl-C。也就是说,Ctrl键就好像功能键一样,当你按下了功能键Ctrl后,C就不在是C了,而且就是一个命令或是一个快键键了,在VIM的Normal模式下,所有的键就是功能键了。这个你需要知道。

标记:

下面的文字中,如果是 Ctrl-λ我会写成 <C-λ>.
以 : 开始的命令你需要输入 <enter>回车,例如 — 如果我写成 :q 也就是说你要输入 :q<enter>.
第二级 – 感觉良好
上面的那些命令只能让你存活下来,现在是时候学习一些更多的命令了,下面是我的建议：(陈皓注：所有的命令都需要在Normal模式下使用,如果你不知道现在在什么样的模式,你就狂按几次ESC键)

各种插入模式
a → 在光标后插入
o → 在当前行后插入一个新行
O → 在当前行前插入一个新行
cw → 替换从光标所在位置后到一个单词结尾的字符
简单的移动光标
0 → 数字零,到行头
^ → 到本行第一个不是blank字符的位置(所谓blank字符就是空格,tab,换行,回车等)
$ → 到本行行尾
g_ → 到本行最后一个不是blank字符的位置。
/pattern → 搜索 pattern 的字符串(陈皓注：如果搜索出多个匹配,可按n键到下一个)
拷贝/粘贴 (陈皓注：p/P都可以,p是表示在当前位置之后,P表示在当前位置之前)
P → 粘贴
yy → 拷贝当前行当行于 ddP
Undo/Redo
u → undo
<C-r> → redo
打开/保存/退出/改变文件(Buffer)
:e <path/to/file> → 打开一个文件
:w → 存盘
:saveas <path/to/file> → 另存为 <path/to/file>
:x, ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存,ZZ不需要输入冒号并回车)
:q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件,就算别的文件有更改。
:bn 和 :bp → 你可以同时打开很多文件,使用这两个命令来切换下一个或上一个文件。(陈皓注：我喜欢使用:n到下一个文件)
花点时间熟悉一下上面的命令,一旦你掌握他们了,你就几乎可以干其它编辑器都能干的事了。但是到现在为止,你还是觉得使用vim还是有点笨拙,不过没关系,你可以进阶到第三级了。

第三级 – 更好,更强,更快
先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级,我们只谈那些和vi可以兼容的命令。

更好
下面,让我们看一下vim是怎么重复自己的：

. → (小数点) 可以重复上一次的命令
N<command> → 重复某个命令N次
下面是一个示例,找开一个文件你可以试试下面的命令：

2dd → 删除2行
3p → 粘贴文本3次
100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “
. → 重复上一个命令—— 100 “desu “.
3. → 重复 3 次 “desu” (注意：不是 300,你看,VIM多聪明啊).
更强
你要让你的光标移动更有效率,你一定要了解下面的这些命令,千万别跳过。

NG → 到第 N 行 (陈皓注：注意命令中的G是大写的,另我一般使用 : N 到第N行,如 :137 到第137行)
gg → 到第一行。(陈皓注：相当于1G,或 :1)
G → 到最后一行。
按单词移动：
w → 到下一个单词的开头。
e → 到下一个单词的结尾。
b → 返回上一个单词开头。
~ → 大小写转换
> 如果你认为单词是由默认方式,那么就用小写的e和w。默认上来说,一个单词由字母,数字和下划线组成(陈皓注：程序变量)

> 如果你认为单词是由blank字符分隔符,那么你需要使用大写的E和W。(陈皓注：程序语句)

Word moves example

下面,让我来说说最强的光标移动：

% : 匹配括号移动,包括 (, {, [. (陈皓注：你需要把光标先移到括号上)
* 和 #:  匹配光标当前所在的单词,移动光标到下一个(或上一个)匹配单词(*是下一个,#是上一个)
相信我,上面这三个命令对程序员来说是相当强大的。

更快
你一定要记住光标的移动,因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：

<start position><command><end position>

例如 0y$ 命令意味着：

0 → 先到行头
y → 从这里开始拷贝
$ → 拷贝到本行最后一个字符
你可可以输入 ye,从当前位置拷贝到本单词的最后一个字符。

你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。

还有很多时间并不一定你就一定要按y才会拷贝,下面的命令也会被拷贝：

d (删除 )
v (可视化的选择)
gU (变大写)
gu (变小写)
等等
(陈皓注：可视化选择是一个很有意思的命令,你可以先按v,然后移动光标,你就会看到文本被选择,然后,你可能d,也可y,也可以变大写等)
第四级 – Vim 超能力
你只需要掌握前面的命令,你就可以很舒服的使用VIM了。但是,现在,我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。

在当前行上移动光标: 0 ^ $ f F t T , ;
0 → 到行头
^ → 到本行的第一个非blank字符
$ → 到行尾
g_ → 到本行最后一个不是blank字符的位置。
fa → 到下一个为a的字符处,你也可以fs到下一个为s的字符。
t, → 到逗号前的第一个字符。逗号可以变成其它字符。
3fa → 在当前行查找第三个出现的a。
F 和 T → 和 f 和 t 一样,只不过是相反方向。
Line moves
还有一个很有用的命令是 dt" → 删除所有的内容,直到遇到双引号—— "。

区域选择 <action>a<object> 或 <action>i<object>
在visual 模式下,这些命令很强大,其命令格式为

<action>a<object> 和 <action>i<object>

action可以是任何的命令,如 d (删除), y (拷贝), v (可以视模式选择)。
object 可能是： w 一个单词, W 一个以空格为分隔的单词, s 一个句字, p 一个段落。也可以是一个特别的字符："、 '、 )、 }、 ]。
假设你有一个字符串 (map (+) ("foo")).而光标键在第一个 o 的位置。

vi" → 会选择 foo.
va" → 会选择 "foo".
vi) → 会选择 "foo".
va) → 会选择("foo").
v2i) → 会选择 map (+) ("foo")
v2a) → 会选择 (map (+) ("foo"))
Text objects selection

块操作: <C-v>
块操作,典型的操作： 0 <C-v> <C-d> I-- [ESC]

^ → 到行头
<C-v> → 开始块操作
<C-d> → 向下移动 (你也可以使用hjkl来移动光标,或是使用%,或是别的)
I-- [ESC] → I是插入,插入“--”,按ESC键来为每一行生效。
Rectangular blocks

在Windows下的vim,你需要使用 <C-q> 而不是 <C-v> ,<C-v> 是拷贝剪贴板。

自动提示： <C-n> 和 <C-p>
在 Insert 模式下,你可以输入一个词的开头,然后按 <C-p>或是<C-n>,自动补齐功能就出现了……

Completion

宏录制： qa 操作序列 q, @a, @@
qa 把你的操作记录在寄存器 a。
于是 @a 会replay被录制的宏。
@@ 是一个快捷键用来replay最新录制的宏。
示例

在一个只有一行且这一行只有“1”的文本中,键入如下命令：

qaYp<C-a>q→
qa 开始录制
Yp 复制行.
<C-a> 增加1.
q 停止录制.
@a → 在1下面写下 2
@@ → 在2 正面写下3
现在做 100@@ 会创建新的100行,并把数据增加到 103.
Macros

可视化选择： v,V,<C-v>
前面,我们看到了 <C-v>的示例 (在Windows下应该是<C-q>),我们可以使用 v 和 V。一但被选好了,你可以做下面的事：

J → 把所有的行连接起来(变成一行)
< 或 > → 左右缩进
= → 自动给缩进 (陈皓注：这个功能相当强大,我太喜欢了)
Autoindent

在所有被选择的行后加上点东西：

<C-v>
选中相关的行 (可使用 j 或 <C-d> 或是 /pattern 或是 % 等……)
$ 到行最后
A, 输入字符串,按 ESC。
Append to many lines

分屏: :split 和 vsplit.
下面是主要的命令,你可以使用VIM的帮助 :help split. 你可以参考本站以前的一篇文章VIM分屏。

:split → 创建分屏 (:vsplit创建垂直分屏)
<C-w><dir> : dir就是方向,可以是 hjkl 或是 ←↓↑→ 中的一个,其用来切换分屏。
<C-w>_ (或 <C-w>|) : 最大化尺寸 (<C-w>| 垂直分屏)
<C-w>+ (或 <C-w>-) : 增加尺寸
Split

结束语
上面是作者最常用的90%的命令。
我建议你每天都学1到2个新的命令。
在两到三周后,你会感到vim的强大的。
有时候,学习VIM就像是在死背一些东西。
幸运的是,vim有很多很不错的工具和优秀的文档。
运行vimtutor直到你熟悉了那些基本命令。
其在线帮助文档中你应该要仔细阅读的是 :help usr_02.txt.
你会学习到诸如  !, 目录,寄存器,插件等很多其它的功能。
学习vim就像学弹钢琴一样,一旦学会,受益无穷。

——————————正文结束——————————

对于vi/vim只是点评一点：这是一个你不需要使用鼠标,不需使用小键盘,只需要使用大键盘就可以完成很多复杂功能文本编辑的编辑器。不然,Visual Studio也不就会有vim的插件了。

(全文完)

ubuntu下vi/vim 的基本用法
2018年03月23日 16:50:54 漫天飞舞的雪花 阅读数：11788
版权声明：本文为博主原创文章,未经博主允许不得转载。	网址： https://blog.csdn.net/lvdepeng123/article/details/79669874
1 简介
vim是文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富,在程序员中被广泛使用。下面讲述一些必要的基本命令,而掌握好这些命令,您就能够很容易将vim当作一个通用的万能编辑器来使用了。
vim自带基础教程：在任意一台装有vim的机器上,命令行中输入vimtutor  然后就可以看到文档了。另外网上也有很多例子如：       http://blog.csdn.net/niushuai666/article/details/7275406



2 基本命令
包含vim的基本介绍、使用模式、文件的打开关闭保存、插入文本或新建行、移动光标、删除、恢复字符或行、搜索等等。
vim有3个模式：插入模式、命令模式、低行模式。
插入模式：在此模式下可以输入字符,按ESC将回到命令模式。
命令模式：可以移动光标、删除字符等。
低行模式：可以保存文件、退出vi、设置vi、查找等功能(低行模式也可以看作是命令模式里的)。按shift + : 进入插入模式



2.1 打开文件、保存、关闭文件(vim命令模式下使用), // 是注释的意思
vi filename     //打开filename文件
:w           //保存文件
:w cszhi.com    //保存至cszhi.com文件
:q           //退出编辑器,如果文件已修改请使用下面的命令
:q!//退出编辑器,且不保存
:wq          //退出编辑器,且保存文件



2.2 插入文本或行(vim命令模式下使用,执行下面命令后将进入插入模式,按ESC键可退出插入模式进入底行模式
a       //在当前光标位置的右边添加文本
i       //在当前光标位置的左边添加文本
A       //在当前行的末尾位置添加文本
I       //在当前行的开始处添加文本(非空字符的行首)
O       //在当前行的上面新建一行
o       //在当前行的下面新建一行
R       //替换(覆盖)当前光标位置及后面的若干文本
J       //合并光标所在行及下一行为一行(依然在命令模式)



2.3 移动光标(vim命令模式下使用)
①使用上下左右方向键
②命令模式下：
h   向左、j   向下、k   向上、l  向右。
空格键向右、Backspace向左、Enter移动到下一行首、-移动到上一行首。
2.3 删除、恢复字符或行(vim命令模式下使用)
x         //删除当前字符
nx        //删除从光标开始的n个字符
dd        //删除当前行
ndd        //向下删除当前行在内的n行
u         //撤销上一步操作
Ctrl+r 恢复上一步被撤销的操作
U         //撤销对当前行的所有操作



2.4 搜索(vim命令模式下使用)
/cszhi    //向光标下搜索cszhi字符串
?cszhi    //向光标上搜索cszhi字符串
n         //向下搜索前一个搜素动作
N         //向上搜索前一个搜索动作


2.5 跳至指定行(vim底行模式下使用)
n+//向下跳n行
n-//向上跳n行
nG        //跳到行号为n的行
G         //跳至文件的底部


2.6 设置行号(vim命令模式下使用)
:set number  #显示行数
:set  nu     //显示行号
:set nonu    //取消显示行号
sudo vim /etc/vim/vimrc   是系统范围的初始化配置
sudo vim ～/.vimrc     	  个人的vim初始化配置




2.7 复制、粘贴(vim命令模式下使用)
yy    //将当前行复制到缓存区,也可以用 "ayy 复制,"a 为缓冲区,a也可以替换为a到z的任意字母,可以完成多个复制任务
nyy   //将当前行向下n行复制到缓冲区,也可以用 "anyy 复制,"a 为缓冲区,a也可以替换为a到z的任意字母,可以完成多个复制任务
yw    //复制从光标开始到词尾的字符
nyw   //复制从光标开始的n个单词
y^    //复制从光标到行首的内容
y$    //复制从光标到行尾的内容
p     //粘贴剪切板里的内容在光标后,如果使用了前面的自定义缓冲区,建议使用"ap 进行粘贴
P     //粘贴剪切板里的内容在光标前,如果使用了前面的自定义缓冲区,建议使用"aP 进行粘贴



2.8 替换(vim命令模式下使用)
:s/old/new//用new替换行中首次出现的old
:s/old/new/g        //用new替换行中所有的old
:n,m s/old/new/g    //用new替换从n到m行里所有的old
:%s/old/new/g       //用new替换当前文件里所有的old



2.9 编辑其他文件
:e otherfilename    //编辑文件名为otherfilename的文件



2.10 修改文件格式
:set fileformat=unix   //将文件修改为unix格式,如win下面的文本文件在linux下会出现^M



2.11 查看当前行信息(vim命令模式下使用)
ctrl+g


2.10 跳转到制定行(vim命令模式下使用)
number + shift  + g
如果没有输入number则跳转到末尾。1+shit+g行首。



2.11 vim 取消 查找 高亮
:set hlsearch "打开高亮搜索
:set nohlsearch "关闭高亮搜索
:nohl "只取消掉当前的搜索高亮



2.12 滚屏
ctrl+u\d  向上\下滚动半屏
ctrl+e\y  向上\下滚动一行
ctrl+b\f  向上\下滚动一屏



2.13 移动
b、3b、w、3w:向前\后移动几个单词,标点也算一个单词。相应的大写状态为不含标点,即只把空格和换行符作为单词间隔符。
$(shift+4)：移动到行尾  3$：移动到3行后的行尾
0 行首有空格
^(shift+6):移动到行首,
+：移到下一行的行首
-： 移到上一行的行首




2.14 折叠
命令小结
zc	关闭当前打开的折叠
zo	打开当前的折叠
zm	关闭所有折叠
zM	关闭所有折叠及其嵌套的折叠
zr	打开所有折叠
zR	打开所有折叠及其嵌套的折叠
zd	删除当前折叠
zE	删除所有折叠
zj	移动至下一个折叠
zk	移动至上一个折叠
zn	禁用折叠
zN	启用折叠

2.15 函数折叠(命令模式)
zf

shift+%



2.16 代码格式化
#格式化全文
gg=G
 
#自动缩进当前行
==
 
#格式化当前光标接下来的10行
10=j 

#格式化当前光标向上的10行
10=k 
 
#格式化选定的行
v(向上下选择)
=
 

#命令解释
gg    #跳转到文件首行
=     #应用缩进格式
G     #直到文件结束

2.17 在函数中移动光标(命令模式)
[{ 转到上一个位于第一列的"{"
}] 转到下一个位于第一列的"{"
{    转到上一个空行
}    转到下一个空行
gd 转到当前光标所指的局部变量的定义
*    转到当前光标所指的单词下一次出现的地方
#    转到当前光标所指的单词上一次出现的地方


普通模式中使用y复制
	普通模式中,yy复制游标所在的整行（3yy表示复制3行）
	普通模式中,y^ 复制至行首,或y0。不含光标所在处字符。
	普通模式中,y$ 复制至行尾。含光标所在处字符。
	普通模式中,yw 复制一个单词。
	普通模式中,y2w 复制两个单词。
	普通模式中,yG 复制至文本末。
	普通模式中,y1G 复制至文本开头。
	
普通模式中使用 p 粘贴
	普通模式中,p(小写)代表粘贴至光标后（下）
	普通模式中,P(大写)代表粘贴至光标前（上）

永久设置行数（行号）方法：
$ sudo vim /etc/vim/vimrc # 编辑 vim的配置文件
:set number  #最后添加永久显示行数
保存退出（每回就显示行号）

2.1.1 替换和撤销(Undo)命令
替换和Undo命令都是针对普通模式下的操作

	命令	说明
	r+<待替换字母>	将游标所在字母替换为指定字母
	R	连续替换,直到按下Esc
	cc	替换整行,即删除游标所在行,并进入插入模式
	cw	替换一个单词,即删除一个单词,并进入插入模式
	C(大写)	替换游标以后至行末
	~	反转游标所在字母大小写
	u{n}	撤销一次或n次操作
	U(大写)	撤销当前行的所有修改
	Ctrl+r	redo,即撤销undo的操作


普通模式下输入>> 整行将向右缩进（使用,用于格式化代码超爽）
普通模式下输入<< 整行向左回退
普通模式s表示删除字符进入插入模式

命令模式
:set shiftwidth=10 # 设置缩进为10个字符（默认上8）
：set sw=8 # 设置缩进为8个字符（默认上8）
:ce # 本行局中（文本靠中）
:ri # 本行靠右（文本靠右）
:le # 本行靠左（文本靠左）
/搜索字符 # n向继续下查找N向上继续查找
？搜索字符 # 向上搜索（同上）
:noh 或:set noh 取消查找

使用vim编辑多个文件
$ vim 1.txt 2.txt
默认进入1.txt文件的编辑界面

命令行模式下输入 :n 编辑 2.txt 文件,可以加 ! 即 :n! 强制切换,之前一个文件的输入没有保存（:w保存）,仅仅切换到另一个文件
命令行模式下输入 :N 编辑 1.txt 文件,可以加 ! 即 :N! 强制切换,之前文件内的输入没有保存（:w保存）,仅仅是切换到另一个文件


2.1.2 进入vim后打开新文件
命令行模式下输入:e 3.txt 打开新文件3.txt
命令行模式下输入:e# 回到前一个文件
命令行模式下输入:ls可以列出以前编辑过的文档
命令行模式下输入:b 2.txt（或者编号）可以直接进入文件2.txt编辑
命令行模式下输入:bd 2.txt（或者编号）可以删除以前编辑过的列表中的文件项目
命令行模式下输入:e! 4.txt,新打开文件4.txt,放弃正在编辑的文件
命令行模式下输入:f 显示正在编辑的文件名
命令行模式下输入:f new.txt,改变正在编辑的文件名字为new.txt
2.1.3 恢复文件
由于在线环境的特殊性,请在本机尝试

如果因为断电等原因造成文档没有保存,可以采用恢复方式,vim -r进入文档后,输入:ewcover 1.txt来恢复

$ vim -r 1.txt # 断电恢复文档

v 可视模式（选择模式,选中模式, 视图模式）区域选择模式

普通模式下v进入可视模式 
普通模式下V(大写)进入可视模式(整行选中,整行选择)
V 整行选择
'<,'>normal i#  //添加多行注释（#）
'<,'>normal d#  //删除多行注释（#）
ctrl+v 区域选择模式
V+G 全选
v 可视模式 
v+$ 从光标到行尾选中
v+^ 从光标到行头选中

d 删除
y 复制
p 粘贴

:sp 1.txt # 水平添加1.txt
:vsp 2.txt # 垂直添加2.txt
:new 新建vim视窗
命令行模式下输入:sp 1.txt 打开新的水平分屏视窗来编辑1.txt
命令行模式下输入:vsp 2.txt 打开新的垂直分屏视窗来编辑2.txt
普通模式下Ctrl+w s 将当前窗口分割成两个水平的窗口
普通模式下Ctrl+w v 将当前窗口分割成两个垂直的窗口
普通模式下Ctrl+w q 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!
普通模式下Ctrl+w o 打开一个视窗并且隐藏之前的所有视窗
普通模式下Ctrl+w j 移至下面视窗
普通模式下Ctrl+w k 移至上面视窗
普通模式下Ctrl+w h 移至左边视窗
普通模式下Ctrl+w l 移至右边视窗
普通模式下Ctrl+w J 将当前视窗移至下面
普通模式下Ctrl+w K 将当前视窗移至上面
普通模式下Ctrl+w H 将当前视窗移至左边
普通模式下Ctrl+w L 将当前视窗移至右边
普通模式下Ctrl+w - 减小视窗的高度
普通模式下Ctrl+w + 增加视窗的高度（Ctrl+shift +）
2.3.2 视窗操作练习
打开练习文件

$ vim 1.txt
命令行模式下输入:new 打开一个新的vim视窗
命令行模式下输入:vsp 2.txt 打开新的横向视窗来编辑2.txt
命令行模式下输入:vsp 3.txt 打开新的横向视窗来编辑3.txt
如果使用非chrome浏览器可以使用Ctrl+w进行视窗间的跳转
分别在不同视窗的命令行模式下输入:q!退出多视窗编辑

vim -x file1 # 创建加密文本


在命令行模式中输入!可以执行外部的shell命令
:!命令 # !执行外部命令
:!ls 用于显示当前目录的内容
:!rm FILENAME用于删除名为 FILENAME 的文件
:w FILENAME可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件

Ex模式(Ex mode)
这和命令行模式比较相似,在使用:visual命令离开Ex模式前,可以一次执行多条命令。

2.6.1 vim中的查看帮助
	普通模式下按F1打开vim自己预设的帮助文档
	命令行模式下输入:h shiftwidth 打开名为shiftwidth的帮助文件
	命令行模式下输入:ver 显示版本及参数

2.7.2 获取目前的设定
	命令行模式下输入:set或者:se显示所有修改过的配置
	命令行模式下输入:set all 显示所有的设定值
	命令行模式下输入:set option? （:option,:quit返回） 显示option的设定值
	命令行模式下输入:set nooption 取消当前设定值
	
2.7.3 set功能的说明
	命令行模式下输入:set autoindent(ai) 设置自动缩进
	取消：set noai
	取消：set no命令
	命令行模式下输入:set autowrite(aw) 设置自动存档,默认未打开
	命令行模式下输入:set background=dark或light,设置背景风格
	命令行模式下输入:set backup(bk) 设置自动备份,默认未打开
	命令行模式下输入: set cindent(cin) 设置C语言风格缩进
更多详细参数请参考vim手册